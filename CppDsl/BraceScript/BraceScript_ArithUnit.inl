//the code generated by BatchCommand with genbracecode.dsl

class AddExp final : public BinaryArithLogicBaseExp
{
public:
    AddExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_STRING) {
            std::stringstream ss;
            ss << "operator +, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedStringArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteGGString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteLLString, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteGLString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteLGString, this);
            }

        }
        else if (NeedFloatArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteGGFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteLLFloat, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteGLFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteLGFloat, this);
            }

        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteLGUInt, this);
            }

        }
        else {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AddExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        double v1 = VarGetF64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        double v1 = VarGetF64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetStr(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        std::string v1 = VarGetStr(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetStr(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetStr(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetStr(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 + v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class SubExp final : public BinaryArithLogicBaseExp
{
public:
    SubExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_DOUBLE) {
            std::stringstream ss;
            ss << "operator -, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedFloatArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&SubExp::ExecuteGGFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&SubExp::ExecuteLLFloat, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&SubExp::ExecuteGLFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&SubExp::ExecuteLGFloat, this);
            }

        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&SubExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&SubExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&SubExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&SubExp::ExecuteLGUInt, this);
            }

        }
        else {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&SubExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&SubExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&SubExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&SubExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 - v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 - v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 - v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 - v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 - v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 - v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 - v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 - v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        double v1 = VarGetF64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 - v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        double v1 = VarGetF64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 - v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 - v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 - v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class MulExp final : public BinaryArithLogicBaseExp
{
public:
    MulExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_DOUBLE) {
            std::stringstream ss;
            ss << "operator *, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedFloatArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&MulExp::ExecuteGGFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&MulExp::ExecuteLLFloat, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&MulExp::ExecuteGLFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&MulExp::ExecuteLGFloat, this);
            }

        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&MulExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&MulExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&MulExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&MulExp::ExecuteLGUInt, this);
            }

        }
        else {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&MulExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&MulExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&MulExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&MulExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 * v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 * v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 * v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 * v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 * v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 * v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 * v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 * v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        double v1 = VarGetF64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 * v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        double v1 = VarGetF64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 * v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 * v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 * v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class DivExp final : public BinaryArithLogicBaseExp
{
public:
    DivExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_DOUBLE) {
            std::stringstream ss;
            ss << "operator /, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedFloatArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&DivExp::ExecuteGGFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&DivExp::ExecuteLLFloat, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&DivExp::ExecuteGLFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&DivExp::ExecuteLGFloat, this);
            }

        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&DivExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&DivExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&DivExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&DivExp::ExecuteLGUInt, this);
            }

        }
        else {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&DivExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&DivExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&DivExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&DivExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 / v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 / v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 / v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 / v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 / v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 / v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 / v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 / v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        double v1 = VarGetF64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 / v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        double v1 = VarGetF64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 / v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 / v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetF64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 / v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class ModExp final : public BinaryArithLogicBaseExp
{
public:
    ModExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_UINT64) {
            std::stringstream ss;
            ss << "operator %, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&ModExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&ModExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&ModExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&ModExp::ExecuteLGUInt, this);
            }

        }
        else {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&ModExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&ModExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&ModExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&ModExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 % v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 % v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 % v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 % v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 % v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 % v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 % v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 % v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class LShiftExp final : public BinaryArithLogicBaseExp
{
public:
    LShiftExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_UINT64) {
            std::stringstream ss;
            ss << "operator <<, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LShiftExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LShiftExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LShiftExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LShiftExp::ExecuteLGUInt, this);
            }

        }
        else {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LShiftExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LShiftExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LShiftExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LShiftExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 << v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 << v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 << v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 << v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 << v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 << v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 << v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 << v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class RShiftExp final : public BinaryArithLogicBaseExp
{
public:
    RShiftExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_UINT64) {
            std::stringstream ss;
            ss << "operator >>, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&RShiftExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&RShiftExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&RShiftExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&RShiftExp::ExecuteLGUInt, this);
            }

        }
        else {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&RShiftExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&RShiftExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&RShiftExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&RShiftExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >> v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >> v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >> v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >> v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >> v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >> v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >> v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >> v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class BitAndExp final : public BinaryArithLogicBaseExp
{
public:
    BitAndExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_UINT64) {
            std::stringstream ss;
            ss << "operator &, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitAndExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitAndExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitAndExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitAndExp::ExecuteLGUInt, this);
            }

        }
        else {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitAndExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitAndExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitAndExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitAndExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 & v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 & v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 & v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 & v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 & v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 & v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 & v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 & v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class BitOrExp final : public BinaryArithLogicBaseExp
{
public:
    BitOrExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_UINT64) {
            std::stringstream ss;
            ss << "operator |, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitOrExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitOrExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitOrExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitOrExp::ExecuteLGUInt, this);
            }

        }
        else {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitOrExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitOrExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitOrExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitOrExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 | v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 | v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 | v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 | v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 | v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 | v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 | v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 | v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class BitXorExp final : public BinaryArithLogicBaseExp
{
public:
    BitXorExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_UINT64) {
            std::stringstream ss;
            ss << "operator ^, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitXorExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitXorExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitXorExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitXorExp::ExecuteLGUInt, this);
            }

        }
        else {
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitXorExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitXorExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitXorExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&BitXorExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 ^ v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 ^ v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 ^ v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 ^ v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 ^ v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 ^ v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 ^ v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 ^ v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class GreatExp final : public BinaryArithLogicBaseExp
{
public:
    GreatExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_STRING) {
            std::stringstream ss;
            ss << "operator >, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedStringArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteGGString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteLLString, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteGLString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteLGString, this);
            }

        }
        else if (NeedFloatArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteGGFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteLLFloat, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteGLFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteLGFloat, this);
            }

        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteLGUInt, this);
            }

        }
        else {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        double v1 = VarGetF64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        double v1 = VarGetF64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        std::string v1 = VarGetStr(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 > v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class GreatEqualExp final : public BinaryArithLogicBaseExp
{
public:
    GreatEqualExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_STRING) {
            std::stringstream ss;
            ss << "operator >=, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedStringArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteGGString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteLLString, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteGLString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteLGString, this);
            }

        }
        else if (NeedFloatArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteGGFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteLLFloat, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteGLFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteLGFloat, this);
            }

        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteLGUInt, this);
            }

        }
        else {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&GreatEqualExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        double v1 = VarGetF64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        double v1 = VarGetF64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        std::string v1 = VarGetStr(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 >= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class LessExp final : public BinaryArithLogicBaseExp
{
public:
    LessExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_STRING) {
            std::stringstream ss;
            ss << "operator <, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedStringArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteGGString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteLLString, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteGLString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteLGString, this);
            }

        }
        else if (NeedFloatArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteGGFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteLLFloat, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteGLFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteLGFloat, this);
            }

        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteLGUInt, this);
            }

        }
        else {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        double v1 = VarGetF64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        double v1 = VarGetF64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        std::string v1 = VarGetStr(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 < v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class LessEqualExp final : public BinaryArithLogicBaseExp
{
public:
    LessEqualExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_STRING) {
            std::stringstream ss;
            ss << "operator <=, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedStringArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteGGString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteLLString, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteGLString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteLGString, this);
            }

        }
        else if (NeedFloatArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteGGFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteLLFloat, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteGLFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteLGFloat, this);
            }

        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteLGUInt, this);
            }

        }
        else {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&LessEqualExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        double v1 = VarGetF64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        double v1 = VarGetF64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        std::string v1 = VarGetStr(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 <= v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class EqualExp final : public BinaryArithLogicBaseExp
{
public:
    EqualExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_STRING) {
            std::stringstream ss;
            ss << "operator ==, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedStringArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteGGString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteLLString, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteGLString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteLGString, this);
            }

        }
        else if (NeedFloatArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteGGFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteLLFloat, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteGLFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteLGFloat, this);
            }

        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteLGUInt, this);
            }

        }
        else {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&EqualExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        double v1 = VarGetF64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        double v1 = VarGetF64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        std::string v1 = VarGetStr(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 == v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class NotEqualExp final : public BinaryArithLogicBaseExp
{
public:
    NotEqualExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_STRING) {
            std::stringstream ss;
            ss << "operator !=, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (NeedStringArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteGGString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteLLString, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteGLString, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteLGString, this);
            }

        }
        else if (NeedFloatArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteGGFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteLLFloat, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteGLFloat, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteLGFloat, this);
            }

        }
        else if (NeedUnsignedArithUnit(load1.Type, load2.Type)) {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteGGUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteLLUInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteGLUInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteLGUInt, this);
            }

        }
        else {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteGGInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteLLInt, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteGLInt, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&NotEqualExp::ExecuteLGInt, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        int64_t v2 = VarGetI64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        uint64_t v2 = VarGetU64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        double v1 = VarGetF64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        double v1 = VarGetF64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGFloat(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        double v1 = VarGetF64(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        double v2 = VarGetF64(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        std::string v1 = VarGetStr(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGString(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        std::string v1 = VarGetStr(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        std::string v2 = VarGetStr(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 != v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class AndExp final : public BinaryArithLogicBaseExp
{
public:
    AndExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_UINT64) {
            std::stringstream ss;
            ss << "operator &&, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AndExp::ExecuteGGBool, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AndExp::ExecuteLLBool, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AndExp::ExecuteGLBool, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&AndExp::ExecuteLGBool, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGBool(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        bool v1 = VarGetBoolean(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        bool v2 = VarGetBoolean(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 && v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLBool(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        bool v1 = VarGetBoolean(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        bool v2 = VarGetBoolean(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 && v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLBool(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        bool v1 = VarGetBoolean(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        bool v2 = VarGetBoolean(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 && v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGBool(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        bool v1 = VarGetBoolean(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        bool v2 = VarGetBoolean(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 && v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class OrExp final : public BinaryArithLogicBaseExp
{
public:
    OrExp(BraceScript& interpreter) :BinaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, const DataTypeInfo& load2, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = GetMaxType(load1.Type, load2.Type);
        if (resultType > BRACE_DATA_TYPE_UINT64) {
            std::stringstream ss;
            ss << "operator ||, operand type dismatch, " << GetDataTypeName(load1.Type) << " and " << GetDataTypeName(load2.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&OrExp::ExecuteGGBool, this);
            }
            else if (!m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&OrExp::ExecuteLLBool, this);
            }
            else if (m_LoadInfo1.IsGlobal && !m_LoadInfo2.IsGlobal) {
                executor = std::bind(&OrExp::ExecuteGLBool, this);
            }
            else if (!m_LoadInfo1.IsGlobal && m_LoadInfo2.IsGlobal) {
                executor = std::bind(&OrExp::ExecuteLGBool, this);
            }

        }

        return true;
    }
private:
    int ExecuteGGBool(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        bool v1 = VarGetBoolean(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        bool v2 = VarGetBoolean(srcVars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 || v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLLBool(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        bool v1 = VarGetBoolean(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        bool v2 = VarGetBoolean(vars, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 || v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteGLBool(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = *GlobalVariables();
        auto& srcVars2 = vars;
        bool v1 = VarGetBoolean(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        bool v2 = VarGetBoolean(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 || v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLGBool(void) const
    {
        if (m_Op1)
            m_Op1();
        if (m_Op2)
            m_Op2();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars1 = vars;
        auto& srcVars2 = *GlobalVariables();
        bool v1 = VarGetBoolean(srcVars1, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        bool v2 = VarGetBoolean(srcVars2, m_LoadInfo2.Type, m_LoadInfo2.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, v1 || v2);
        return BRACE_FLOW_CONTROL_NORMAL;
    }


};
class BitNotExp final : public UnaryArithLogicBaseExp
{
public:
    BitNotExp(BraceScript& interpreter) :UnaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = load1.Type;
        if (resultType >= BRACE_DATA_TYPE_FLOAT) {
            std::stringstream ss;
            ss << "can't bit not type " << GetDataTypeName(m_LoadInfo1.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else if (IsUnsignedType(resultType)) {
            if (m_LoadInfo1.IsGlobal) {
                executor = std::bind(&BitNotExp::ExecuteGUInt, this);
            }
            else {
                executor = std::bind(&BitNotExp::ExecuteLUInt, this);
            }

        }
        else {
            if (m_LoadInfo1.IsGlobal) {
                executor = std::bind(&BitNotExp::ExecuteGInt, this);
            }
            else {
                executor = std::bind(&BitNotExp::ExecuteLInt, this);
            }

        }
        return true;
    }
private:
    int ExecuteGInt(void) const
    {
        if (m_Op1)
            m_Op1();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        int64_t v1 = VarGetI64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, ~v1);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLInt(void) const
    {
        if (m_Op1)
            m_Op1();
        auto& vars = *CurRuntimeStack().Variables;
        int64_t v1 = VarGetI64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        VarSetI64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, ~v1);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

    int ExecuteGUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        uint64_t v1 = VarGetU64(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, ~v1);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLUInt(void) const
    {
        if (m_Op1)
            m_Op1();
        auto& vars = *CurRuntimeStack().Variables;
        uint64_t v1 = VarGetU64(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        VarSetU64(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, ~v1);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

};
class NotExp final : public UnaryArithLogicBaseExp
{
public:
    NotExp(BraceScript& interpreter) :UnaryArithLogicBaseExp(interpreter)
    {
    }
protected:
    virtual bool BuildExecutor(const DslData::FunctionData& data, const DataTypeInfo& load1, int& resultType, BraceApiExecutor& executor) const override
    {
        resultType = load1.Type;
        if (resultType >= BRACE_DATA_TYPE_FLOAT) {
            std::stringstream ss;
            ss << "can't bit not type " << GetDataTypeName(load1.Type) << ", line " << data.GetLine();
            LogError(ss.str());
            return false;
        }
        else {
            resultType = BRACE_DATA_TYPE_BOOL;
            if (m_LoadInfo1.IsGlobal) {
                executor = std::bind(&NotExp::ExecuteGBool, this);
            }
            else {
                executor = std::bind(&NotExp::ExecuteLBool, this);
            }

        }
        return true;
    }
private:
    int ExecuteGBool(void) const
    {
        if (m_Op1)
            m_Op1();
        auto& vars = *CurRuntimeStack().Variables;
        auto& srcVars = *GlobalVariables();
        bool v1 = VarGetBoolean(srcVars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, !v1);
        return BRACE_FLOW_CONTROL_NORMAL;
    }
    int ExecuteLBool(void) const
    {
        if (m_Op1)
            m_Op1();
        auto& vars = *CurRuntimeStack().Variables;
        bool v1 = VarGetBoolean(vars, m_LoadInfo1.Type, m_LoadInfo1.VarIndex);
        VarSetBoolean(vars, m_ResultInfo.Type, m_ResultInfo.VarIndex, !v1);
        return BRACE_FLOW_CONTROL_NORMAL;
    }

};
