
	enum CustomBraceObjectTypeIdEnum
	{
		CUSTOM_BRACE_OBJECT_TYPE_STRUCT = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NUM,
		CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY,
		CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY,
		CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE,
		CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE,
		CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE,
		CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE,
		BRACE_OBJECT_TYPE_NUM
	};

	class StructObj final : public Brace::BraceObjectBaseT<CUSTOM_BRACE_OBJECT_TYPE_STRUCT>
	{
	public:
		virtual ~StructObj(void) override
		{

		}
	private:
		std::vector<std::string> m_StrArray;
	};

	template<typename T, int k>
	class ArrayObjT final : public Brace::BraceObjectBaseT<k>
	{
	public:
		ArrayObjT(void):m_Array()
		{}
		virtual ~ArrayObjT(void) override
		{
		}
	public:
		const std::vector<T>& GetImpl(void)const { return m_Array; }
		std::vector<T>& GetImpl(void) { return m_Array; }
	private:
		std::vector<T> m_Array;
	};

	template<typename KeyT, typename ValT, int k>
	class HashtableObjT final : public Brace::BraceObjectBaseT<k>
	{
	public:
		HashtableObjT(void) :m_Hashtable()
		{}
		virtual ~HashtableObjT(void) override
		{

        }
	public:
        const std::unordered_map<KeyT, ValT>& GetImpl(void)const { return m_Hashtable; }
        std::unordered_map<KeyT, ValT>& GetImpl(void) { return m_Hashtable; }
	private:
		std::unordered_map<KeyT, ValT> m_Hashtable;
	};

	class MemberCallExp final : public Brace::AbstractBraceApi
	{
	public:
		MemberCallExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
		{
		}
	protected:
		virtual bool LoadFunction(const Brace::ProcInfo& proc, const DslData::FunctionData& data, Brace::BraceApiLoadInfo& resultInfo, Brace::BraceApiExecutor& executor) override
		{
			executor = nullptr;
			return true;
		}
	};
	class MemberSetExp final : public Brace::AbstractBraceApi
	{
	public:
		MemberSetExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
		{
		}
	protected:
		virtual bool LoadFunction(const Brace::ProcInfo& proc, const DslData::FunctionData& data, Brace::BraceApiLoadInfo& resultInfo, Brace::BraceApiExecutor& executor) override
		{
			executor = nullptr;
			return true;
		}
	};
	class MemberGetExp final : public Brace::AbstractBraceApi
	{
	public:
		MemberGetExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_Obj(), m_Member(), m_ResultInfo()
		{
		}
	protected:
		virtual bool LoadFunction(const Brace::ProcInfo& proc, const DslData::FunctionData& data, Brace::BraceApiLoadInfo& resultInfo, Brace::BraceApiExecutor& executor) override
		{
			if (data.GetParamNum() != 2)
				return false;
			m_Obj = LoadHelper(*data.GetParam(0), m_ObjInfo);
			m_Member = data.GetParamId(1);
			if (m_ObjInfo.Type != Brace::BRACE_DATA_TYPE_OBJECT || (m_ObjInfo.ObjectTypeId != CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY && m_ObjInfo.ObjectTypeId != CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY)) {
				std::stringstream ss;
				ss << "only support int/string array. ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			if (m_Member != "length") {
				std::stringstream ss;
				ss << "only support array.length now ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			m_ResultInfo.Type = Brace::BRACE_DATA_TYPE_INT32;
			m_ResultInfo.VarIndex = AllocVariable(GenTempVarName(), m_ResultInfo.Type, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
			resultInfo = m_ResultInfo;
			executor.attach(this, &MemberGetExp::Execute);
			return true;
		}
	private:
		int Execute(void)const
		{
			if (!m_Obj.isNull())
				m_Obj();
			auto& gvars = *GlobalVariables();
			auto& lvars = *CurRuntimeVariables();
			const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
			if (m_ObjInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY) {
				auto* ptr = p.get();
				if (nullptr != ptr) {
					auto* pArr = static_cast<ArrayObjT<int, CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY>*>(ptr);
					size_t v = pArr->GetImpl().size();
					Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
				}
			}
			else if (m_ObjInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY) {
				auto* ptr = p.get();
				if (nullptr != ptr) {
					auto* pArr = static_cast<ArrayObjT<std::string, CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY>*>(ptr);
					size_t v = pArr->GetImpl().size();
					Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
				}
			}
			return Brace::BRACE_FLOW_CONTROL_NORMAL;
		}
	private:
		Brace::BraceApiExecutor m_Obj;
		Brace::BraceApiLoadInfo m_ObjInfo;
		std::string m_Member;
		Brace::BraceApiLoadInfo m_ResultInfo;
	};
	class CollectionCallExp final : public Brace::SimpleBraceApiBase
	{
	public:
		CollectionCallExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter)
		{
		}
	protected:
		virtual bool TypeInference(const Brace::ProcInfo& proc, const DslData::FunctionData& data, const std::vector<Brace::BraceApiLoadInfo>& argInfos, Brace::BraceApiLoadInfo& resultInfo) const override
		{
			return false;
		}
		virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::BraceApiLoadInfo>& argInfos, const Brace::BraceApiLoadInfo& resultInfo)const override
		{
		}
	};
	class CollectionSetExp final : public Brace::SimpleBraceApiBase
	{
	public:
		CollectionSetExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter)
		{
		}
	protected:
		virtual bool TypeInference(const Brace::ProcInfo& proc, const DslData::FunctionData& data, const std::vector<Brace::BraceApiLoadInfo>& argInfos, Brace::BraceApiLoadInfo& resultInfo) const override
		{
			if (argInfos.size() != 3)
				return false;
			auto& arr = argInfos[0];
			auto& ix = argInfos[1];
			auto& val = argInfos[2];
			if (arr.Type != Brace::BRACE_DATA_TYPE_OBJECT || (arr.ObjectTypeId != CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY && arr.ObjectTypeId != CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY)) {
				std::stringstream ss;
				ss << "only support int/string array. ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
				std::stringstream ss;
				ss << "array's index must be integer ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			if ((arr.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY && !(val.Type >= Brace::BRACE_DATA_TYPE_INT8 && val.Type <= Brace::BRACE_DATA_TYPE_UINT64))
				|| (arr.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY && val.Type != Brace::BRACE_DATA_TYPE_STRING)) {
				std::stringstream ss;
				ss << "int/string array's value must be int/string ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			resultInfo = val;
			return true;
		}
		virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::BraceApiLoadInfo>& argInfos, const Brace::BraceApiLoadInfo& resultInfo)const override
		{
			auto& arr = argInfos[0];
			auto& ix = argInfos[1];
			auto& val = argInfos[2];
			const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
			int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
			if (arr.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY) {
				int64_t v = Brace::VarGetI64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
				auto* ptr = p.get();
				if (nullptr != ptr) {
					auto* pArr = static_cast<ArrayObjT<int, CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY>*>(ptr);
					pArr->GetImpl()[static_cast<size_t>(vix)] = static_cast<int>(v);
				}
			}
			else if (arr.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY) {
				const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
				auto* ptr = p.get();
				if (nullptr != ptr) {
					auto* pArr = static_cast<ArrayObjT<std::string, CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY>*>(ptr);
					pArr->GetImpl()[static_cast<size_t>(vix)] = v;
				}
			}
		}
	};
	class CollectionGetExp final : public Brace::SimpleBraceApiBase
	{
	public:
		CollectionGetExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter)
		{
		}
	protected:
		virtual bool TypeInference(const Brace::ProcInfo& proc, const DslData::FunctionData& data, const std::vector<Brace::BraceApiLoadInfo>& argInfos, Brace::BraceApiLoadInfo& resultInfo) const override
		{
			if (argInfos.size() != 2)
				return false;
			auto& arr = argInfos[0];
			auto& ix = argInfos[1];
			if (arr.Type != Brace::BRACE_DATA_TYPE_OBJECT || (arr.ObjectTypeId != CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY && arr.ObjectTypeId != CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY)) {
				std::stringstream ss;
				ss << "only support int/string array. ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
				std::stringstream ss;
				ss << "array's index must be integer ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			if (arr.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY)
				resultInfo.Type = Brace::BRACE_DATA_TYPE_INT32;
			else
				resultInfo.Type = Brace::BRACE_DATA_TYPE_STRING;
			resultInfo.VarIndex = AllocVariable(GenTempVarName(), resultInfo.Type, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
			return true;
		}
		virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::BraceApiLoadInfo>& argInfos, const Brace::BraceApiLoadInfo& resultInfo)const override
		{
			auto& arr = argInfos[0];
			auto& ix = argInfos[1];
			const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
			int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
			if (arr.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY) {
				auto* ptr = p.get();
				if (nullptr != ptr) {
					auto* pArr = static_cast<ArrayObjT<int, CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY>*>(ptr);
					int v = pArr->GetImpl()[static_cast<size_t>(vix)];
					Brace::VarSetInt32((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
				}
			}
			else if (arr.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY) {
				auto* ptr = p.get();
				if (nullptr != ptr) {
					auto* pArr = static_cast<ArrayObjT<std::string, CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY>*>(ptr);
					const std::string& v = pArr->GetImpl()[static_cast<size_t>(vix)];
					Brace::VarSetString((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
				}
			}
		}
	};
	class LambdaExp final : public Brace::AbstractBraceApi
	{
	public:
		LambdaExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
		{
		}
	protected:
		virtual bool LoadFunction(const Brace::ProcInfo& proc, const DslData::FunctionData& data, Brace::BraceApiLoadInfo& resultInfo, Brace::BraceApiExecutor& executor) override
		{
			//(args) => {...}; or (args)int => {...}; or [...](args) => {...}; or [...](args)int => {...};
			bool hasError = false;
			if (hasError) {
				std::stringstream ss;
				ss << "lambda syntax error, line " << data.GetLine();
				LogError(ss.str());
			}
			return false;
		}
	};
	class LinqExp final : public Brace::AbstractBraceApi
	{
	public:
		LinqExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
		{
		}
	protected:
		virtual bool LoadFunction(const Brace::ProcInfo& proc, const DslData::FunctionData& data, Brace::BraceApiLoadInfo& resultInfo, Brace::BraceApiExecutor& executor) override
		{
			executor = nullptr;
			return true;
		}
	};
	class ArrayExp final : public Brace::AbstractBraceApi
	{
	public:
		ArrayExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ArrayType(INVALID_ID), m_Args(), m_ArgLoadInfos(), m_ResultInfo()
		{
		}
	protected:
		virtual bool LoadFunction(const Brace::ProcInfo& curProc, const DslData::FunctionData& data, Brace::BraceApiLoadInfo& resultInfo, Brace::BraceApiExecutor& executor)
		{
			if (data.IsHighOrder()) {
				auto& lowerFunc = data.GetLowerOrderFunction();
                if (lowerFunc.GetParamNum() == 1 && lowerFunc.GetParamClassUnmasked() == DslData::FunctionData::PARAM_CLASS_ANGLE_BRACKET_COLON) {
					const std::string& id = lowerFunc.GetParamId(0);
					if (id == "int32") {
						m_ArrayType = 0;
					}
					else if (id == "string") {
						m_ArrayType = 1;
					}
					std::vector<Brace::BraceApiExecutor> args;
					std::vector<Brace::BraceApiLoadInfo> argLoadInfos;
					int num = data.GetParamNum();
					for (int ix = 0; ix < num; ++ix) {
						auto* param = data.GetParam(ix);
						Brace::BraceApiLoadInfo argLoadInfo;
						auto p = LoadHelper(*param, argLoadInfo);
						args.push_back(std::move(p));
						argLoadInfos.push_back(std::move(argLoadInfo));
					}
					if (m_ArrayType == 0) {
						bool good = true;
						for (auto& ai : argLoadInfos) {
							if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
							}
							else {
								good = false;
								break;
							}
						}
						if (good) {
							std::swap(m_Args, args);
							std::swap(m_ArgLoadInfos, argLoadInfos);
							m_ResultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
							m_ResultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY;
							m_ResultInfo.VarIndex = AllocVariable(GenTempVarName(), m_ResultInfo.Type, m_ResultInfo.ObjectTypeId);
							resultInfo = m_ResultInfo;
							executor.attach(this, &ArrayExp::Execute);
							return true;
						}
					}
					else if (m_ArrayType == 1) {
						bool good = true;
						for (auto& ai : argLoadInfos) {
							if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
							}
							else {
								good = false;
								break;
							}
						}
						if (good) {
							std::swap(m_Args, args);
							std::swap(m_ArgLoadInfos, argLoadInfos);
							m_ResultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
							m_ResultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY;
							m_ResultInfo.VarIndex = AllocVariable(GenTempVarName(), m_ResultInfo.Type, m_ResultInfo.ObjectTypeId);
							resultInfo = m_ResultInfo;
							executor.attach(this, &ArrayExp::Execute);
							return true;
						}
					}
				}
			}
			std::stringstream ss;
			ss << "array syntax error ! array<: int|string :>(v1, v2, ...) line: " << data.GetLine();
			LogError(ss.str());
			return false;
		}
	private:
		int Execute(void)const
		{
			for (auto& arg : m_Args) {
				if (!arg.isNull())
					arg();
			}
			auto& gvars = *GlobalVariables();
			auto& lvars = *CurRuntimeVariables();
			if (m_ArrayType == 0) {
				using IntArrayObj = ArrayObjT<int, CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY>;
				auto* p = new IntArrayObj();
				for (auto& ai : m_ArgLoadInfos) {
					int64_t v = VarGetI64((ai.IsGlobal ? gvars : lvars), ai.Type, ai.VarIndex);
					p->GetImpl().push_back(static_cast<int>(v));
				}
				Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
			}
			else if (m_ArrayType == 1) {
				using StrArrayObj = ArrayObjT<std::string, CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY>;
				auto* p = new StrArrayObj();
				for (auto& ai : m_ArgLoadInfos) {
					const std::string& v = VarGetString((ai.IsGlobal ? gvars : lvars), ai.VarIndex);
					p->GetImpl().push_back(v);
				}
				Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
			}
			return Brace::BRACE_FLOW_CONTROL_NORMAL;
		}
	private:
		int m_ArrayType;
		std::vector<Brace::BraceApiExecutor> m_Args;
		std::vector<Brace::BraceApiLoadInfo> m_ArgLoadInfos;
		Brace::BraceApiLoadInfo m_ResultInfo;
	};
	class HashtableExp final : public Brace::AbstractBraceApi
	{
	public:
		HashtableExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
		{
		}
	protected:
		virtual bool LoadFunction(const Brace::ProcInfo& proc, const DslData::FunctionData& data, Brace::BraceApiLoadInfo& resultInfo, Brace::BraceApiExecutor& executor) override
		{
			executor = nullptr;
			return true;
		}
	};
	class LoopListExp final : public Brace::AbstractBraceApi
	{
	public:
		LoopListExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_IteratorIndex(INVALID_INDEX), m_List(), m_LoadInfo(), m_Statements()
		{
		}
	protected:
		virtual bool LoadFunction(const Brace::ProcInfo& proc, const DslData::FunctionData& funcData, Brace::BraceApiLoadInfo& resultInfo, Brace::BraceApiExecutor& executor) override
		{
			if (funcData.IsHighOrder()) {
				auto* list = funcData.GetLowerOrderFunction().GetParam(0);
				m_List = LoadHelper(*list, m_LoadInfo);
				PushBlock();
				if (m_LoadInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
					if (m_LoadInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY)
						m_IteratorIndex = AllocVariable("$$", m_LoadInfo.Type, Brace::BRACE_DATA_TYPE_INT32);
					else if (m_LoadInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY)
						m_IteratorIndex = AllocVariable("$$", m_LoadInfo.Type, Brace::BRACE_DATA_TYPE_STRING);
				}
				for (int ix = 0; ix < funcData.GetParamNum(); ++ix) {
					Brace::BraceApiLoadInfo argLoadInfo;
					auto statement = LoadHelper(*funcData.GetParam(ix), argLoadInfo);
					if (!statement.isNull())
						m_Statements.push_back(std::move(statement));
				}
				m_ObjVars = CurBlockObjVars();
				PopBlock();
				executor.attach(this, &LoopListExp::Execute);
			}
			else {
				//error
				std::stringstream ss;
				ss << "BraceScript error, " << funcData.GetId() << " line " << funcData.GetLine();
				LogError(ss.str());
			}
			return true;
		}
		virtual bool LoadStatement(const Brace::ProcInfo& proc, const DslData::StatementData& statementData, Brace::BraceApiLoadInfo& resultInfo, Brace::BraceApiExecutor& executor) override
		{
			//looplist(exp) func(args);
			if (statementData.GetFunctionNum() == 2) {
				auto* first = statementData.GetFirst()->AsFunction();
				auto* second = statementData.GetSecond()->AsFunction();
				const std::string& firstId = first->GetId();
				const std::string& secondId = second->GetId();
				if (firstId == "looplist" && !first->HaveStatement() && !first->HaveExternScript() &&
					!secondId.empty() && !second->HaveStatement() && !second->HaveExternScript()) {
					if (first->GetParamNum() > 0) {
						auto* exp = first->GetParam(0);
						m_List = LoadHelper(*exp, m_LoadInfo);
						if (m_LoadInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
							if (m_LoadInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY)
								m_IteratorIndex = AllocVariable("$$", m_LoadInfo.Type, Brace::BRACE_DATA_TYPE_INT32);
							else if (m_LoadInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY)
								m_IteratorIndex = AllocVariable("$$", m_LoadInfo.Type, Brace::BRACE_DATA_TYPE_STRING);
						}
					}
					else {
						//error
						std::stringstream ss;
						ss << "BraceScript error, " << first->GetId() << " line " << first->GetLine();
						LogError(ss.str());
					}
					Brace::BraceApiLoadInfo argLoadInfo;
					auto statement = LoadHelper(*second, argLoadInfo);
					if (!statement.isNull())
						m_Statements.push_back(std::move(statement));
					executor.attach(this, &LoopListExp::Execute);
					return true;
				}
			}
			return false;
		}
	private:
		int Execute(void)const
		{
			auto& gvars = *GlobalVariables();
			auto& vars = *CurRuntimeVariables();
			if (!m_List.isNull())
				m_List();
			auto& obj = Brace::VarGetObject((m_LoadInfo.IsGlobal ? gvars : vars), m_LoadInfo.VarIndex);
			if (nullptr != obj) {
				if (m_LoadInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
					if (m_LoadInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY) {
						auto* ptr = obj.get();
						if (nullptr != ptr) {
							auto* pArr = static_cast<ArrayObjT<int, CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY>*>(ptr);
							for (auto& val : pArr->GetImpl()) {
								Brace::VarSetInt32(vars, m_IteratorIndex, val);
								for (auto& statement : m_Statements) {
									int v = statement();
									if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
										break;
									}
									else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
										FreeObjVars(vars, m_ObjVars);
										if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
											return Brace::BRACE_FLOW_CONTROL_NORMAL;
										return v;
									}
								}
							}
						}
					}
					else if (m_LoadInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY) {
						auto* ptr = obj.get();
						if (nullptr != ptr) {
							auto* pArr = static_cast<ArrayObjT<std::string, CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY>*>(ptr);
							for (auto& val : pArr->GetImpl()) {
								Brace::VarSetString(vars, m_IteratorIndex, val);
								for (auto& statement : m_Statements) {
									int v = statement();
									if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
										break;
									}
									else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
										FreeObjVars(vars, m_ObjVars);
										if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
											return Brace::BRACE_FLOW_CONTROL_NORMAL;
										return v;
									}
								}
							}
						}
					}
				}
			}
			FreeObjVars(vars, m_ObjVars);
			return Brace::BRACE_FLOW_CONTROL_NORMAL;
		}
	private:
		int m_IteratorIndex;
		Brace::BraceApiExecutor m_List;
		Brace::BraceApiLoadInfo m_LoadInfo;
		std::vector<Brace::BraceApiExecutor> m_Statements;
		std::vector<int> m_ObjVars;
	};