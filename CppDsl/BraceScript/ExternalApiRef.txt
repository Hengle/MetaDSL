

    enum BraceObjectCategoryEnum
    {
        /// <summary>
        /// Internal objects, no inheritance, handled specifically in the MemberCall/MemberSet/MemberGet/CollectionCall/CollectionSet/CollectionGet/LoopList APIs.
        /// </summary>
        BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT = 0,
        /// <summary>
        /// Internal special objects, handled specifically in the MemberCall/MemberSet/MemberGet/CollectionCall/CollectionSet/CollectionGet/LoopList APIs.
        /// </summary>
        BRACE_OBJECT_CATEGORY_OBJ_ARRAY,
        BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE,
        BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE,
        /// <summary>
        /// Custom structs, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_STRUCT,
        /// <summary>
        /// Custom objects, has inheritance, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_CUSTOM,
        /// <summary>
        /// Custom objects, inherit from UObject, can be used in UE api, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_UOBJECT,
        /// <summary>
        /// Custom objects, inherit from AActor, can be used in UE api, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_ACTOR,
        /// <summary>
        /// Custom objects, inherit from UActorComponent, can be used in UE api, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_ACTOR_COMPONENT,
        BRACE_OBJECT_CATEGORY_NUM
    };
    enum CustomBraceObjectTypeIdEnum
    {
        CUSTOM_BRACE_OBJECT_TYPE_STRING = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NUM,
        CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY,
        CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY,
        CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY,
        CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY,
        CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT,
        CUSTOM_BRACE_OBJECT_TYPE_CPP_ACTOR,
        BRACE_INNER_FIXED_OBJECT_TYPE_NUM
    };

    struct MethodInfo final
    {
        Brace::DataTypeInfo ReturnType;
        std::vector<Brace::ParamTypeInfo> ParamTypes;
        std::string Name;
    };
    struct BraceObjectInfo;
    struct FieldInfo final
    {
        Brace::DataTypeInfo Type;
        int Offset;
        int Size;
        bool IsPtr;
        std::string Name;
        const BraceObjectInfo* BraceObjInfo;
    };
    struct MethodTableInfo final
    {
        std::vector<MethodInfo> Methods;
    };
    struct FieldTableInfo final
    {
        int Size;
        std::vector<FieldInfo> Fields;
    };
    struct BraceObjectInfo final
    {
        std::string TypeName;
        int ObjectTypeId;
        int ObjectCategory;
        std::vector<int> TypeParams;
        MethodTableInfo MethodTable;
        FieldTableInfo FieldTable;
    };

    class MemberCallExp;
    class MemberSetExp;
    class MemberGetExp;
    class CollectionCallExp;
    class CollectionSetExp;
    class CollectionGetExp;
    class LoopListExp;
    class AbstractMemberCallApiProvider : public Brace::BraceApiImplHelper
    {
        friend class MemberCallExp;
    protected:
        virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) = 0;
    protected:
        AbstractMemberCallApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractMemberSetApiProvider : public Brace::BraceApiImplHelper
    {
        friend class MemberSetExp;
    protected:
        virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) = 0;
    protected:
        AbstractMemberSetApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractMemberGetApiProvider : public Brace::BraceApiImplHelper
    {
        friend class MemberGetExp;
    protected:
        virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) = 0;
    protected:
        AbstractMemberGetApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractCollectionCallApiProvider : public Brace::BraceApiImplHelper
    {
        friend class CollectionCallExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) const = 0;
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo) const = 0;
    protected:
        AbstractCollectionCallApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractCollectionSetApiProvider : public Brace::BraceApiImplHelper
    {
        friend class CollectionSetExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, const Brace::OperandLoadtimeInfo& val, Brace::OperandLoadtimeInfo& resultInfo) const = 0;
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& val, const Brace::OperandRuntimeInfo& resultInfo) const = 0;
    protected:
        AbstractCollectionSetApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractCollectionGetApiProvider : public Brace::BraceApiImplHelper
    {
        friend class CollectionGetExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, Brace::OperandLoadtimeInfo& resultInfo) const = 0;
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& resultInfo) const = 0;
    protected:
        AbstractCollectionGetApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractLoopListApiProvider : public Brace::BraceApiImplHelper
    {
        friend class LoopListExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::ISyntaxComponent& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor) = 0;
        virtual void StoreRuntimeInfo(Brace::OperandRuntimeInfo&& listInfo, Brace::BraceApiExecutor&& list, std::vector<Brace::BraceApiExecutor>&& statements, std::vector<int>&& objVars) = 0;
    protected:
        AbstractLoopListApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    /// <summary>
    /// We make a objtypeid -> BraceObjectInfo map, which allows object category info to process class by category, 
    /// Such as DispatchObject, CustomObject, UObject etc.
    /// </summary>
    class BraceObjectInfoManager final
    {
    public:
        int GetObjectTypeId(const std::string& key)const
        {
            auto it = m_ObjTypeIdMap.find(key);
            if (it != m_ObjTypeIdMap.end())
                return it->second;
            return Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN;
        }
        int AddNewObjectTypeId(const std::string& key)
        {
            int newId = GenNextObjectTypeId();
            m_ObjTypeIdMap.insert(std::make_pair(key, newId));
            return newId;
        }
        BraceObjectInfo* AddBraceObjectInfo(int objTypeId, int objCategory, const std::string& typeName)
        {
            std::string name = typeName;
            return AddBraceObjectInfo(objTypeId, objCategory, std::move(name));
        }
        BraceObjectInfo* AddBraceObjectInfo(int objTypeId, int objCategory, std::string&& typeName)
        {
            auto it = m_ObjTypeIdMap.find(typeName);
            if (it == m_ObjTypeIdMap.end()) {
                m_ObjTypeIdMap.insert(std::make_pair(typeName, objTypeId));
            }
            BraceObjectInfo info{};
            info.TypeName = std::move(typeName);
            info.ObjectCategory = objCategory;
            info.ObjectTypeId = objTypeId;
            auto pair = m_ObjInfoMap.insert(std::make_pair(objTypeId, std::move(info)));
            return pair.second ? &(pair.first->second) : nullptr;
        }
        const BraceObjectInfo* GetBraceObjectInfo(int objTypeId)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end())
                return &(it->second);
            return nullptr;
        }
        BraceObjectInfo* GetBraceObjectInfo(int objTypeId)
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end())
                return &(it->second);
            return nullptr;
        }
    public:
        BraceObjectInfoManager(void) :m_ObjTypeIdMap(), m_ObjInfoMap(), m_NextObjectTypeId(BRACE_INNER_FIXED_OBJECT_TYPE_NUM)
        {}
    private:
        int GenNextObjectTypeId(void)
        {
            return m_NextObjectTypeId++;
        }
    private:
        std::unordered_map<std::string, int> m_ObjTypeIdMap;
        std::unordered_map<int, BraceObjectInfo> m_ObjInfoMap;
        int m_NextObjectTypeId;
    public:
        static void CalcObjTypeKey(const DslData::ISyntaxComponent& syntax, std::stringstream& ss)
        {
            if (syntax.GetSyntaxType() == DslData::ISyntaxComponent::TYPE_FUNCTION) {
                ss << syntax.GetId();
                ss << "<:";
                auto& funcData = static_cast<const DslData::FunctionData&>(syntax);
                for (int ix = 0; ix < funcData.GetParamNum(); ++ix) {
                    auto& p = *funcData.GetParam(ix);
                    CalcObjTypeKey(p, ss);
                }
                ss << ":>";
            }
            else if (syntax.GetSyntaxType() == DslData::ISyntaxComponent::TYPE_VALUE) {
                ss << syntax.GetId();
            }
        }
        static std::string CalcObjTypeKey(const DslData::ISyntaxComponent& syntax)
        {
            std::stringstream ss;
            CalcObjTypeKey(syntax, ss);
            return ss.str();
        }
    };
    static BraceObjectInfoManager g_ObjectInfoMgr;

class UObjectMemberCallProvider final : public AbstractMemberCallApiProvider
{
	friend class MemberCallExp;
protected:
	virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	UObjectMemberCallProvider(Brace::BraceScript& interpreter) :AbstractMemberCallApiProvider(interpreter)
	{}
};
class UObjectMemberSetProvider final : public AbstractMemberSetApiProvider
{
	friend class MemberSetExp;
protected:
	virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	UObjectMemberSetProvider(Brace::BraceScript& interpreter) :AbstractMemberSetApiProvider(interpreter)
	{}
};
class UObjectMemberGetProvider final : public AbstractMemberGetApiProvider
{
	friend class MemberGetExp;
protected:
	virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	UObjectMemberGetProvider(Brace::BraceScript& interpreter) :AbstractMemberGetApiProvider(interpreter)
	{}
};

class AActorMemberCallProvider final : public AbstractMemberCallApiProvider
{
	friend class MemberCallExp;
protected:
	virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	AActorMemberCallProvider(Brace::BraceScript& interpreter) :AbstractMemberCallApiProvider(interpreter)
	{}
};
class AActorMemberSetProvider final : public AbstractMemberSetApiProvider
{
	friend class MemberSetExp;
protected:
	virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	AActorMemberSetProvider(Brace::BraceScript& interpreter) :AbstractMemberSetApiProvider(interpreter)
	{}
};
class AActorMemberGetProvider final : public AbstractMemberGetApiProvider
{
	friend class MemberGetExp;
protected:
	virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	AActorMemberGetProvider(Brace::BraceScript& interpreter) :AbstractMemberGetApiProvider(interpreter)
	{}
};

template<typename T>
class ArrayObjT final : public Brace::IBraceObject
{
public:
	ArrayObjT(void) :m_Array()
	{}
	virtual ~ArrayObjT(void) override
	{
	}
public:
	const std::vector<T>& GetImpl(void)const { return m_Array; }
	std::vector<T>& GetImpl(void) { return m_Array; }
private:
	std::vector<T> m_Array;
};
class ObjectArray final : public Brace::IBraceObject
{
public:
	using ObjArrayType = std::vector<std::shared_ptr<Brace::IBraceObject>>;
public:
	ObjectArray(void) :m_Array()
	{}
	virtual ~ObjectArray(void) override
	{
	}
public:
	const ObjArrayType& GetImpl(void)const { return m_Array; }
	ObjArrayType& GetImpl(void) { return m_Array; }
private:
	ObjArrayType m_Array;
};

template<typename KeyT, typename ValT>
class HashtableObjT final : public Brace::IBraceObject
{
public:
	HashtableObjT(void) :m_Hashtable()
	{}
	virtual ~HashtableObjT(void) override
	{

	}
public:
	const std::unordered_map<KeyT, ValT>& GetImpl(void)const { return m_Hashtable; }
	std::unordered_map<KeyT, ValT>& GetImpl(void) { return m_Hashtable; }
private:
	std::unordered_map<KeyT, ValT> m_Hashtable;
};
class StrObjHashtable final : public Brace::IBraceObject
{
public:
	using StrObjHashtableType = std::unordered_map<std::string, std::shared_ptr<Brace::IBraceObject>>;
public:
	StrObjHashtable(void) :m_Hashtable()
	{}
	virtual ~StrObjHashtable(void) override
	{}
public:
	const StrObjHashtableType& GetImpl(void)const { return m_Hashtable; }
	StrObjHashtableType& GetImpl(void) { return m_Hashtable; }
private:
	StrObjHashtableType m_Hashtable;
};
class IntObjHashtable final : public Brace::IBraceObject
{
public:
	using IntObjHashtableType = std::unordered_map<int64_t, std::shared_ptr<Brace::IBraceObject>>;
public:
	IntObjHashtable(void) :m_Hashtable()
	{}
	virtual ~IntObjHashtable(void) override
	{}
public:
	const IntObjHashtableType& GetImpl(void)const { return m_Hashtable; }
	IntObjHashtableType& GetImpl(void) { return m_Hashtable; }
private:
	IntObjHashtableType m_Hashtable;
};

/// Internally fixed collection objects use switch-case rather than virtual-function-dispatch, simply because switch-case may require less code.
/// and virtual-function-dispatch must define one class for each API, and dozens may be required.
class ArrayHashtableMemberCallProvider final : public AbstractMemberCallApiProvider
{
	friend class MemberCallExp;
protected:
	virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		int num = data.GetParamNum();
		if (num < 2)
			return false;
		std::swap(m_Obj, obj);
		m_ObjInfo = objInfo;
		std::swap(m_Member, member);
		std::swap(m_Args, args);
		Brace::OperandLoadtimeInfo firstArgInfo;
		bool first = true;
		for(auto& argInfo : argInfos) {
			m_ArgInfos.push_back(argInfo);
			if (first) {
				first = false;
				firstArgInfo = std::move(argInfo);
			}
		}
		bool isArray = false;
		bool isHashtable = false;
		bool isIntKey = true;
		int dataType = Brace::BRACE_DATA_TYPE_OBJECT;
		int objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		switch (objInfo.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		}
		switch (braceObjInfo.ObjectCategory) {
		case BRACE_OBJECT_CATEGORY_OBJ_ARRAY:
			isArray = true;
			objTypeId = braceObjInfo.TypeParams.back();
			break;
		case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE:
			isHashtable = true;
			break;
		case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			break;
		}
		if (isArray) {
			if (m_Member == "resize") {
				bool good = false;
				if (m_ArgInfos.size() == 1) {
					auto& argInfo = m_ArgInfos[0];
					if (argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
						good = true;
					}
				}
				if (good) {
					resultInfo = Brace::OperandLoadtimeInfo();
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayResize);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Array.resize's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "push") {
				bool good = false;
				if (m_ArgInfos.size() == 1) {
					if (CanAssign(dataType, objTypeId, firstArgInfo.Type, firstArgInfo.ObjectTypeId)) {
						good = true;
					}
				}
				if (good) {
					resultInfo = Brace::OperandLoadtimeInfo();
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayPush);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Array.push's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "pop") {
				resultInfo.Type = dataType;
				resultInfo.ObjectTypeId = objTypeId;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayPop);
				return true;
			}
			else if (m_Member == "insert") {
				bool good = false;
				if (m_ArgInfos.size() == 2) {
					auto& keyArgInfo = m_ArgInfos[0];
					auto& valArgInfo = m_ArgInfos[1];
					if (keyArgInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && keyArgInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
						if (CanAssign(dataType, objTypeId, valArgInfo.Type, valArgInfo.VarIndex)) {
							good = true;
						}
					}
				}
				if (good) {
					resultInfo = Brace::OperandLoadtimeInfo();
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayInsert);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Array.insert's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "remove") {
				bool good = false;
				if (m_ArgInfos.size() == 1) {
					auto& argInfo = m_ArgInfos[0];
					if (argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
						good = true;
					}
				}
				if (good) {
					resultInfo = Brace::OperandLoadtimeInfo();
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayRemove);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Array.remove's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "clear") {
				resultInfo = Brace::OperandLoadtimeInfo();
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayClear);
				return true;
			}
		}
		else if (isHashtable) {
			if (m_Member == "contains") {
				bool good = false;
				if (m_ArgInfos.size() == 1) {
					auto& argInfo = m_ArgInfos[0];
					if ((isIntKey && argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) ||
						(!isIntKey && argInfo.Type == Brace::BRACE_DATA_TYPE_STRING)) {
						good = true;
					}
				}
				if (good) {
					resultInfo.Type = Brace::BRACE_DATA_TYPE_BOOL;
					resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
					resultInfo.Name = GenTempVarName();
					resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteHashtableContains);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Hashtable.contains's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "add") {
				bool good = false;
				if (m_ArgInfos.size() == 2) {
					auto& keyArgInfo = m_ArgInfos[0];
					auto& valArgInfo = m_ArgInfos[1];
					if ((isIntKey && keyArgInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && keyArgInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) ||
						(!isIntKey && keyArgInfo.Type == Brace::BRACE_DATA_TYPE_STRING)) {
						if (CanAssign(dataType, objTypeId, valArgInfo.Type, valArgInfo.VarIndex)) {
							good = true;
						}
					}
				}
				if (good) {
					resultInfo = Brace::OperandLoadtimeInfo();
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteHashtableAdd);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Hashtable.add's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "remove") {
				bool good = false;
				if (m_ArgInfos.size() == 1) {
					auto& argInfo = m_ArgInfos[0];
					if ((isIntKey && argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) ||
						(!isIntKey && argInfo.Type == Brace::BRACE_DATA_TYPE_STRING)) {
						good = true;
					}
				}
				if (good) {
					resultInfo = Brace::OperandLoadtimeInfo();
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteHashtableRemove);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Hashtable.remove's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "clear") {
				resultInfo = Brace::OperandLoadtimeInfo();
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteHashtableClear);
				return true;
			}
		}
		std::stringstream ss;
		ss << "Unknown member " << m_Member << " line: " << data.GetLine();
		LogError(ss.str());
		executor = nullptr;
		return false;
	}
private:
	int ExecuteArrayResize(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& arr = m_ObjInfo;
		auto& arg = m_ArgInfos[0];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		switch (arr.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().resize(varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().resize(varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().resize(varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().resize(varg);
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().resize(varg);
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteArrayPush(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& arr = m_ObjInfo;
		auto& arg = m_ArgInfos[0];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		switch (arr.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				bool varg = Brace::VarGetBoolean((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().push_back(varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().push_back(varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				double varg = Brace::VarGetF64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().push_back(varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				std::string varg = Brace::VarGetStr((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().push_back(std::move(varg));
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				auto varg = Brace::VarGetObject((arg.IsGlobal ? gvars : lvars), arg.VarIndex);
				pArr->GetImpl().push_back(varg);
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteArrayPop(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		auto& arr = m_ObjInfo;
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		switch (arr.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				bool v = pArr->GetImpl().back();
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
				pArr->GetImpl().pop_back();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				int64_t v = pArr->GetImpl().back();
				Brace::VarSetInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
				pArr->GetImpl().pop_back();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				double v = pArr->GetImpl().back();
				Brace::VarSetDouble((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
				pArr->GetImpl().pop_back();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				const std::string& v = pArr->GetImpl().back();
				Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
				pArr->GetImpl().pop_back();
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				auto v = pArr->GetImpl().back();
				Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
				pArr->GetImpl().pop_back();
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteArrayInsert(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& arr = m_ObjInfo;
		auto& arg = m_ArgInfos[0];
		auto& val = m_ArgInfos[1];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		switch (arr.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				bool v = Brace::VarGetBoolean((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
				VectorInsert(pArr->GetImpl(), varg, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				int64_t v = Brace::VarGetI64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
				VectorInsert(pArr->GetImpl(), varg, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				double v = Brace::VarGetF64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
				VectorInsert(pArr->GetImpl(), varg, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				std::string v = Brace::VarGetStr((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
				VectorInsert(pArr->GetImpl(), varg, std::move(v));
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				auto v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
				VectorInsert(pArr->GetImpl(), varg, v);
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteArrayRemove(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& arr = m_ObjInfo;
		auto& arg = m_ArgInfos[0];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		switch (arr.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				VectorErase(pArr->GetImpl(), varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				VectorErase(pArr->GetImpl(), varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				VectorErase(pArr->GetImpl(), varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				VectorErase(pArr->GetImpl(), varg);
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				VectorErase(pArr->GetImpl(), varg);
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteArrayClear(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		auto& arr = m_ObjInfo;
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		switch (arr.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				pArr->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				pArr->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				pArr->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				pArr->GetImpl().clear();
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				pArr->GetImpl().clear();
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteHashtableContains(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& hash = m_ObjInfo;
		auto& ix = m_ArgInfos[0];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((hash.IsGlobal ? gvars : lvars), hash.VarIndex);
		int objTypeId = hash.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		default: {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
			if (nullptr != pInfo) {
				if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
					auto* ptr = p.get();
					if (nullptr != ptr) {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						bool v = HashtableContains(pHashtable->GetImpl(), vix);
						Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
					}
				}
				else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
					auto* ptr = p.get();
					if (nullptr != ptr) {
						std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						bool v = HashtableContains(pHashtable->GetImpl(), vix);
						Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
					}
				}
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteHashtableAdd(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& hash = m_ObjInfo;
		auto& ix = m_ArgInfos[0];
		auto& val = m_ArgInfos[1];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((hash.IsGlobal ? gvars : lvars), hash.VarIndex);
		int objTypeId = hash.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			int64_t v = Brace::VarGetInt64((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			double v = Brace::VarGetDouble((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			bool v = Brace::VarGetBool((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			int64_t v = Brace::VarGetInt64((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			double v = Brace::VarGetDouble((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			bool v = Brace::VarGetBool((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		default: {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
			if (nullptr != pInfo) {
				if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
					auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
					auto* ptr = p.get();
					if (nullptr != ptr) {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
					}
				}
				else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
					auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
					auto* ptr = p.get();
					if (nullptr != ptr) {
						std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						pHashtable->GetImpl()[vix] = v;
					}
				}
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteHashtableRemove(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& hash = m_ObjInfo;
		auto& ix = m_ArgInfos[0];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((hash.IsGlobal ? gvars : lvars), hash.VarIndex);
		int objTypeId = hash.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		default: {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
			if (nullptr != pInfo) {
				if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
					auto* ptr = p.get();
					if (nullptr != ptr) {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						pHashtable->GetImpl().erase(vix);
					}
				}
				else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
					auto* ptr = p.get();
					if (nullptr != ptr) {
						std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						pHashtable->GetImpl().erase(vix);
					}
				}
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteHashtableClear(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		auto& hash = m_ObjInfo;
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((hash.IsGlobal ? gvars : lvars), hash.VarIndex);
		int objTypeId = hash.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		default: {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
			if (nullptr != pInfo) {
				if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
					auto* ptr = p.get();
					if (nullptr != ptr) {
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						pHashtable->GetImpl().clear();
					}
				}
				else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
					auto* ptr = p.get();
					if (nullptr != ptr) {
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						pHashtable->GetImpl().clear();
					}
				}
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	ArrayHashtableMemberCallProvider(Brace::BraceScript& interpreter) :AbstractMemberCallApiProvider(interpreter), m_Obj(), m_ObjInfo(), m_Member(), m_Args(), m_ArgInfos(), m_ResultInfo()
	{
	}
private:
	Brace::BraceApiExecutor m_Obj;
	Brace::OperandRuntimeInfo m_ObjInfo;
	std::string m_Member;
	std::vector<Brace::BraceApiExecutor> m_Args;
	std::vector<Brace::OperandRuntimeInfo> m_ArgInfos;
	Brace::OperandRuntimeInfo m_ResultInfo;
private:
	template<typename VectorT, typename ValT>
	static inline void VectorInsert(VectorT& vr, int64_t pos, const ValT& val)
	{
		auto it = vr.begin();
		std::advance(it, pos);
		if (it != vr.end())
			vr.insert(it, val);
		else
			vr.push_back(val);
	}
	template<typename VectorT, typename ValT>
	static inline void VectorInsert(VectorT& vr, int64_t pos, ValT&& val)
	{
		auto it = vr.begin();
		std::advance(it, pos);
		if (it != vr.end())
			vr.insert(it, std::move(val));
		else
			vr.push_back(std::move(val));
	}
	template<typename VectorT>
	static inline void VectorErase(VectorT& vr, int64_t pos)
	{
		auto it = vr.begin();
		std::advance(it, pos);
		if (it != vr.end())
			vr.erase(it);
	}
	template<typename HashtableT, typename ValT>
	static inline bool HashtableContains(const HashtableT& hash, const ValT& val)
	{
		auto it = hash.find(val);
		return it != hash.end();
	}
};
class ArrayHashtableMemberSetProvider final : public AbstractMemberSetApiProvider
{
	friend class MemberSetExp;
protected:
	virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	ArrayHashtableMemberSetProvider(Brace::BraceScript& interpreter) :AbstractMemberSetApiProvider(interpreter)
	{
	}
};
class ArrayHashtableMemberGetProvider final : public AbstractMemberGetApiProvider
{
	friend class MemberGetExp;
protected:
	virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		if (data.GetParamNum() != 2)
			return false;
		std::swap(m_Obj, obj);
		m_ObjInfo = objInfo;
		std::swap(m_Member, member);
		bool isArray = false;
		bool isHashtable = false;
		switch (objInfo.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY:
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY:
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY:
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY:
			isArray = true;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE:
			isHashtable = true;
			break;
		}
		switch (braceObjInfo.ObjectCategory) {
		case BRACE_OBJECT_CATEGORY_OBJ_ARRAY:
			isArray = true;
			break;
		case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE:
			isHashtable = true;
			break;
		case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE:
			isHashtable = true;
			break;
		}
		if (isArray) {
			if (m_Member == "length") {
				resultInfo.Type = Brace::BRACE_DATA_TYPE_INT32;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayHashtableMemberGetProvider::ExecuteArrayLength);
				return true;
			}
		}
		else if (isHashtable) {
			if (m_Member == "count") {
				resultInfo.Type = Brace::BRACE_DATA_TYPE_INT32;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayHashtableMemberGetProvider::ExecuteHashtableCount);
				return true;
			}
		}
		std::stringstream ss;
		ss << "Unknown member " << m_Member << " line: " << data.GetLine();
		LogError(ss.str());
		return false;
	}
private:
	int ExecuteArrayLength(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
		int objTypeId = m_ObjInfo.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				size_t v = pArr->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int>*>(ptr);
				size_t v = pArr->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				size_t v = pArr->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				size_t v = pArr->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				size_t v = pArr->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteHashtableCount(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
		int objTypeId = m_ObjInfo.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, int64_t>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
				if (nullptr != pInfo) {
					if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						size_t v = pHashtable->GetImpl().size();
						Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
					}
					else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						size_t v = pHashtable->GetImpl().size();
						Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
					}
				}
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	ArrayHashtableMemberGetProvider(Brace::BraceScript& interpreter) :AbstractMemberGetApiProvider(interpreter), m_Obj(), m_ObjInfo(), m_Member(), m_ResultInfo()
	{
	}
private:
	Brace::BraceApiExecutor m_Obj;
	Brace::OperandRuntimeInfo m_ObjInfo;
	std::string m_Member;
	Brace::OperandRuntimeInfo m_ResultInfo;
};
class ArrayHashtableCollectionCallProvider final : public AbstractCollectionCallApiProvider
{
	friend class CollectionCallExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) const override
	{
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo) const override
	{
	}
private:
	ArrayHashtableCollectionCallProvider(Brace::BraceScript& interpreter) :AbstractCollectionCallApiProvider(interpreter)
	{}
};
class ArrayHashtableCollectionSetProvider final : public AbstractCollectionSetApiProvider
{
	friend class CollectionSetExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, const Brace::OperandLoadtimeInfo& val, Brace::OperandLoadtimeInfo& resultInfo) const override
	{
		bool isArray = false;
		bool isHashtable = false;
		bool isIntKey = true;
		int dataType = Brace::BRACE_DATA_TYPE_OBJECT;
		int objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		switch (braceObjInfo.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		}
		switch (braceObjInfo.ObjectCategory) {
		case BRACE_OBJECT_CATEGORY_OBJ_ARRAY:
			isArray = true;
			objTypeId = braceObjInfo.TypeParams.back();
			break;
		case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE:
			isHashtable = true;
			break;
		case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			break;
		}
		if (isArray) {
			if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
				std::stringstream ss;
				ss << "Array's index must be integer ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			if (!CanAssign(dataType, objTypeId, val.Type, val.ObjectTypeId)) {
				std::stringstream ss;
				ss << "Array element's type and val type dismatch ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			resultInfo = val;
			return true;
		}
		else if (isHashtable) {
			if (isIntKey) {
				if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
					std::stringstream ss;
					ss << "key must be integer ! line: " << data.GetLine();
					LogError(ss.str());
					return false;
				}
			}
			else {
				if (ix.Type != Brace::BRACE_DATA_TYPE_STRING) {
					std::stringstream ss;
					ss << "key must be string ! line: " << data.GetLine();
					LogError(ss.str());
					return false;
				}
			}
			if (!CanAssign(dataType, objTypeId, val.Type, val.ObjectTypeId)) {
				std::stringstream ss;
				ss << "Hashtable type and val type dismatch ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			resultInfo = val;
			return true;
		}
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& val, const Brace::OperandRuntimeInfo& resultInfo) const override
	{
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		int objTypeId = arr.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			bool v = Brace::VarGetBoolean((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				pArr->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			int64_t v = Brace::VarGetI64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				pArr->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			double v = Brace::VarGetF64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				pArr->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				pArr->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			int64_t v = Brace::VarGetInt64((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			double v = Brace::VarGetDouble((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			bool v = Brace::VarGetBool((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			int64_t v = Brace::VarGetInt64((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			double v = Brace::VarGetDouble((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			bool v = Brace::VarGetBool((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		default: {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
			if (nullptr != pInfo) {
				if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_OBJ_ARRAY) {
					auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
					auto* ptr = p.get();
					if (nullptr != ptr) {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pArr = static_cast<ObjectArray*>(ptr);
						pArr->GetImpl()[static_cast<size_t>(vix)] = v;
					}
				}
				else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
					auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
					auto* ptr = p.get();
					if (nullptr != ptr) {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
					}
				}
				else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
					auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
					auto* ptr = p.get();
					if (nullptr != ptr) {
						std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						pHashtable->GetImpl()[vix] = v;
					}
				}
			}
		}break;
		}
	}
private:
	ArrayHashtableCollectionSetProvider(Brace::BraceScript& interpreter) :AbstractCollectionSetApiProvider(interpreter)
	{}
};
class ArrayHashtableCollectionGetProvider final : public AbstractCollectionGetApiProvider
{
	friend class CollectionGetExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, Brace::OperandLoadtimeInfo& resultInfo) const override
	{
		bool isArray = false;
		bool isHashtable = false;
		bool isIntKey = true;
		int dataType = Brace::BRACE_DATA_TYPE_OBJECT;
		int objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		switch (braceObjInfo.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		}
		switch (braceObjInfo.ObjectCategory) {
		case BRACE_OBJECT_CATEGORY_OBJ_ARRAY:
			isArray = true;
			objTypeId = braceObjInfo.TypeParams.back();
			break;
		case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE:
			isHashtable = true;
			break;
		case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			break;
		}
		if (isArray) {
			if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
				std::stringstream ss;
				ss << "Array's index must be integer ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			resultInfo.Type = dataType;
			resultInfo.ObjectTypeId = objTypeId;
			resultInfo.Name = GenTempVarName();
			resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
			return true;
		}
		else if (isHashtable) {
			if (isIntKey) {
				if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
					std::stringstream ss;
					ss << "key must be integer ! line: " << data.GetLine();
					LogError(ss.str());
					return false;
				}
			}
			else {
				if (ix.Type != Brace::BRACE_DATA_TYPE_STRING) {
					std::stringstream ss;
					ss << "key must be string ! line: " << data.GetLine();
					LogError(ss.str());
					return false;
				}
			}
			resultInfo.Type = dataType;
			resultInfo.ObjectTypeId = objTypeId;
			resultInfo.Name = GenTempVarName();
			resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
			return true;
		}
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& resultInfo) const override
	{
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		int objTypeId = arr.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				bool v = pArr->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetBool((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				int64_t v = pArr->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetInt64((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				double v = pArr->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetDouble((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				const std::string& v = pArr->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetString((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				bool v = pHashtable->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetBool((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				int64_t v = pHashtable->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetInt64((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				double v = pHashtable->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetDouble((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				const std::string& v = pHashtable->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetString((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				bool v = pHashtable->GetImpl()[vix];
				Brace::VarSetBool((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, int64_t>*>(ptr);
				int64_t v = pHashtable->GetImpl()[vix];
				Brace::VarSetInt64((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				double v = pHashtable->GetImpl()[vix];
				Brace::VarSetDouble((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				const std::string& v = pHashtable->GetImpl()[vix];
				Brace::VarSetString((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
				if (nullptr != pInfo) {
					switch (pInfo->ObjectCategory) {
					case BRACE_OBJECT_CATEGORY_OBJ_ARRAY: {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pArr = static_cast<ObjectArray*>(ptr);
						auto& v = pArr->GetImpl()[static_cast<size_t>(vix)];
						Brace::VarSetObject((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
					}break;
					case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE: {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						auto& v = pHashtable->GetImpl()[static_cast<size_t>(vix)];
						Brace::VarSetObject((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
					}break;
					case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE: {
						std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						auto& v = pHashtable->GetImpl()[vix];
						Brace::VarSetObject((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
					}break;
					}
				}
			}
		}break;
		}
	}
private:
	ArrayHashtableCollectionGetProvider(Brace::BraceScript& interpreter) :AbstractCollectionGetApiProvider(interpreter)
	{}
};
class ArrayHashtableLoopListProvider final : public AbstractLoopListApiProvider
{
	friend class LoopListExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::ISyntaxComponent& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor) override
	{		
		return TypeInference(listInfo, executor);
	}
	virtual void StoreRuntimeInfo(Brace::OperandRuntimeInfo&& listInfo, Brace::BraceApiExecutor&& list, std::vector<Brace::BraceApiExecutor>&& statements, std::vector<int>&& objVars) override
	{
		std::swap(m_ListInfo, listInfo);
		std::swap(m_List, list);
		std::swap(m_Statements, statements);
		std::swap(m_ObjVars, objVars);
	}
private:
	ArrayHashtableLoopListProvider(Brace::BraceScript& interpreter) :AbstractLoopListApiProvider(interpreter), m_IteratorIndex(INVALID_INDEX), m_IteratorIndexV(INVALID_INDEX), m_List(), m_ListInfo(), m_Statements(), m_ObjVars()
	{}
private:
	bool TypeInference(const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor)
	{
		if (listInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY) {
				m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_BOOL, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteBoolArray);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY) {
				m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntArray);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY) {
				m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_DOUBLE, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteFloatArray);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY) {
				m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStringArray);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_BOOL, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntBoolHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntIntHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_DOUBLE, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntFloatHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntStrHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_BOOL, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrBoolHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrIntHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_DOUBLE, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrFloatHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrStrHashtable);
				return true;
			}
			else {
				auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(listInfo.ObjectTypeId);
				if (nullptr != pInfo) {
					if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_OBJ_ARRAY) {
						m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_OBJECT, pInfo->TypeParams.back());
						executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteObjectArray);
						return true;
					}
					else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
						m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
						m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_OBJECT, pInfo->TypeParams.back());
						executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntObjHashtable);
						return true;
					}
					else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
						m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
						m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_OBJECT, pInfo->TypeParams.back());
						executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrObjHashtable);
						return true;
					}
				}
			}
		}
		return false;
	}
private:
	int ExecuteBoolArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				for (auto val : pArr->GetImpl()) {
					Brace::VarSetBool(lvars, m_IteratorIndex, val);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				for (auto val : pArr->GetImpl()) {
					Brace::VarSetInt64(lvars, m_IteratorIndex, val);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteFloatArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				for (auto val : pArr->GetImpl()) {
					Brace::VarSetDouble(lvars, m_IteratorIndex, val);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStringArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				for (auto& val : pArr->GetImpl()) {
					Brace::VarSetString(lvars, m_IteratorIndex, val);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteObjectArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				for (auto& val : pArr->GetImpl()) {
					Brace::VarSetObject(lvars, m_IteratorIndex, val);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntBoolHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
					Brace::VarSetBool(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntIntHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
					Brace::VarSetInt64(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntFloatHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
					Brace::VarSetInt64(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntStrHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
					Brace::VarSetString(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntObjHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
					Brace::VarSetObject(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrBoolHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetString(lvars, m_IteratorIndex, val.first);
					Brace::VarSetBool(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrIntHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, int64_t>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetString(lvars, m_IteratorIndex, val.first);
					Brace::VarSetInt64(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrFloatHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetString(lvars, m_IteratorIndex, val.first);
					Brace::VarSetDouble(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrStrHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetString(lvars, m_IteratorIndex, val.first);
					Brace::VarSetString(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrObjHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetString(lvars, m_IteratorIndex, val.first);
					Brace::VarSetObject(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	int m_IteratorIndex;
	int m_IteratorIndexV;
	Brace::BraceApiExecutor m_List;
	Brace::OperandRuntimeInfo m_ListInfo;
	std::vector<Brace::BraceApiExecutor> m_Statements;
	std::vector<int> m_ObjVars;
};

class StringMemberCallProvider final : public AbstractMemberCallApiProvider
{
	friend class MemberCallExp;
protected:
	virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		std::swap(m_Obj, obj);
		m_ObjInfo = objInfo;
		std::swap(m_Member, member);
		std::swap(m_Args, args);
		for (auto& argInfo : argInfos) {
			m_ArgInfos.push_back(argInfo);
		}
		auto& m = m_Member;
		if (m == "ReplaceAll") {
			if (argInfos.size() == 2) {
				auto& argInfo = argInfos[0];
				auto& argInfo2 = argInfos[1];
				if (Brace::IsStringType(argInfo.Type) && Brace::IsStringType(argInfo2.Type)) {
					resultInfo = objInfo;
					executor.attach(this, &StringMemberCallProvider::ExecuteReplaceAll);
					return true;
				}
			}
			std::stringstream ss;
			ss << "expected String.ReplaceAll(string, string) ! line: " << data.GetLine();
			LogError(ss.str());
			return false;
		}
		return false;
	}
private:
	int ExecuteReplaceAll(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& strInfo = m_ObjInfo;
		auto& strInfo1 = m_ArgInfos[0];
		auto& strInfo2 = m_ArgInfos[1];
		std::string& str = Brace::VarGetString((strInfo.IsGlobal ? gvars : lvars), strInfo.VarIndex);
		const std::string& what = Brace::VarGetString((strInfo1.IsGlobal ? gvars : lvars), strInfo1.VarIndex);
		const std::string& with = Brace::VarGetString((strInfo2.IsGlobal ? gvars : lvars), strInfo2.VarIndex);
		for (std::string::size_type pos{}; str.npos != (pos = str.find(what.data(), pos, what.length())); pos += with.length()) {
			str.replace(pos, what.length(), with.data(), with.length());
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	StringMemberCallProvider(Brace::BraceScript& interpreter) :AbstractMemberCallApiProvider(interpreter), m_Obj(), m_ObjInfo(), m_Member(), m_Args(), m_ArgInfos(), m_ResultInfo()
	{
	}
private:
	Brace::BraceApiExecutor m_Obj;
	Brace::OperandRuntimeInfo m_ObjInfo;
	std::string m_Member;
	std::vector<Brace::BraceApiExecutor> m_Args;
	std::vector<Brace::OperandRuntimeInfo> m_ArgInfos;
	Brace::OperandRuntimeInfo m_ResultInfo;
};
class StringMemberSetProvider final : public AbstractMemberSetApiProvider
{
	friend class MemberSetExp;
protected:
	virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	StringMemberSetProvider(Brace::BraceScript& interpreter) :AbstractMemberSetApiProvider(interpreter)
	{}
};
class StringMemberGetProvider final : public AbstractMemberGetApiProvider
{
	friend class MemberGetExp;
protected:
	virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	StringMemberGetProvider(Brace::BraceScript& interpreter) :AbstractMemberGetApiProvider(interpreter)
	{}
};
class StringCollectionCallProvider final : public AbstractCollectionCallApiProvider
{
	friend class CollectionCallExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) const override
	{
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo) const override
	{
	}
private:
	StringCollectionCallProvider(Brace::BraceScript& interpreter) :AbstractCollectionCallApiProvider(interpreter)
	{}
};
class StringCollectionSetProvider final : public AbstractCollectionSetApiProvider
{
	friend class CollectionSetExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, const Brace::OperandLoadtimeInfo& val, Brace::OperandLoadtimeInfo& resultInfo) const override
	{
		if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
			std::stringstream ss;
			ss << "String's index must be integer ! line: " << data.GetLine();
			LogError(ss.str());
			return false;
		}
		if (!CanAssign(Brace::BRACE_DATA_TYPE_UINT8, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, val.Type, val.ObjectTypeId)) {
			std::stringstream ss;
			ss << "String element's type and val type dismatch ! line: " << data.GetLine();
			LogError(ss.str());
			return false;
		}
		resultInfo = val;
		return true;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& val, const Brace::OperandRuntimeInfo& resultInfo) const override
    {
		std::string& str = Brace::VarGetString((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
        int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
		uint64_t v = Brace::VarGetU64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
		if (vix >= 0 && vix < static_cast<int64_t>(str.length())) {
			str.replace(static_cast<size_t>(vix), 1, 1, static_cast<char>(static_cast<uint8_t>(v)));
		}
	}
private:
	StringCollectionSetProvider(Brace::BraceScript& interpreter) :AbstractCollectionSetApiProvider(interpreter)
	{}
};
class StringCollectionGetProvider final : public AbstractCollectionGetApiProvider
{
	friend class CollectionGetExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, Brace::OperandLoadtimeInfo& resultInfo) const override
	{
		if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
			std::stringstream ss;
			ss << "String's index must be integer ! line: " << data.GetLine();
			LogError(ss.str());
			return false;
		}
		resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT8;
		resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		resultInfo.Name = GenTempVarName();
		resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
		return true;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& resultInfo) const override
	{
		const std::string& str = Brace::VarGetString((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
		char v = 0;
		if (vix >= 0 && vix < static_cast<int64_t>(str.length())) {
			v = str[vix];
		}
		Brace::VarSetUInt8((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, static_cast<uint8_t>(v));
	}
private:
	StringCollectionGetProvider(Brace::BraceScript& interpreter) :AbstractCollectionGetApiProvider(interpreter)
	{}
};
class StringLoopListProvider final : public AbstractLoopListApiProvider
{
	friend class LoopListExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::ISyntaxComponent& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor) override
	{
		return TypeInference(listInfo, executor);
	}
	virtual void StoreRuntimeInfo(Brace::OperandRuntimeInfo&& listInfo, Brace::BraceApiExecutor&& list, std::vector<Brace::BraceApiExecutor>&& statements, std::vector<int>&& objVars) override
	{
		std::swap(m_ListInfo, listInfo);
		std::swap(m_List, list);
		std::swap(m_Statements, statements);
		std::swap(m_ObjVars, objVars);
	}
private:
	StringLoopListProvider(Brace::BraceScript& interpreter) :AbstractLoopListApiProvider(interpreter), m_IteratorIndex(INVALID_INDEX), m_List(), m_ListInfo(), m_Statements(), m_ObjVars()
	{}
private:
	bool TypeInference(const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor)
	{
		if (listInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
			m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_UINT8, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
			executor.attach(this, &StringLoopListProvider::Execute);
			return true;
		}
		return false;
	}
	int Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& str = Brace::VarGetString((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
        for (char val : str) {
            Brace::VarSetUInt8(lvars, m_IteratorIndex, static_cast<uint8_t>(val));
            for (auto& statement : m_Statements) {
                int v = statement(gvars, lvars);
                if (IsForceQuit()) {
                    FreeObjVars(lvars, m_ObjVars);
                    return v;
                }
                if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                    break;
                }
                else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                    FreeObjVars(lvars, m_ObjVars);
                    if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                        return Brace::BRACE_FLOW_CONTROL_NORMAL;
                    return v;
                }
            }
        }
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	int m_IteratorIndex;
	Brace::BraceApiExecutor m_List;
	Brace::OperandRuntimeInfo m_ListInfo;
	std::vector<Brace::BraceApiExecutor> m_Statements;
	std::vector<int> m_ObjVars;
};

class MemberCallExp final : public Brace::AbstractBraceApi
{
public:
	MemberCallExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		int num = data.GetParamNum();
		if (num < 2)
			return false;
		Brace::OperandLoadtimeInfo loadInfo;
		auto obj = LoadHelper(*data.GetParam(0), loadInfo);
		auto& objInfo = loadInfo;
		auto& m = data.GetParamId(1);
		auto member = m;
		std::vector<Brace::OperandLoadtimeInfo> argInfos;
		std::vector<Brace::BraceApiExecutor> args;
		Brace::OperandLoadtimeInfo firstArgInfo;
		for (int ix = 2; ix < num; ++ix) {
			auto* param = data.GetParam(ix);
			Brace::OperandLoadtimeInfo argLoadInfo;
			auto p = LoadHelper(*param, argLoadInfo);
			args.push_back(std::move(p));
			argInfos.push_back(argLoadInfo);
			if (ix == 2)
				firstArgInfo = std::move(argLoadInfo);
		}
		if (objInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(loadInfo.ObjectTypeId);
			if (nullptr != pInfo) {
				AbstractMemberCallApiProvider* pProvider = nullptr;
				switch (pInfo->ObjectCategory) {
				case BRACE_OBJECT_CATEGORY_UOBJECT:
					pProvider = new UObjectMemberCallProvider(GetInterpreter());
					break;
				case BRACE_OBJECT_CATEGORY_ACTOR:
					pProvider = new AActorMemberCallProvider(GetInterpreter());
					break;
				case BRACE_OBJECT_CATEGORY_STRUCT:
					pProvider = new StructMemberCallProvider(GetInterpreter());
					break;
				default:
					pProvider = new ArrayHashtableMemberCallProvider(GetInterpreter());
					break;
				}
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->LoadMemberCall(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), std::move(argInfos), std::move(args), resultInfo, executor);
				}
			}			
		}
		else if (objInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
			if (nullptr != pInfo) {
				AbstractMemberCallApiProvider* pProvider = new StringMemberCallProvider(GetInterpreter());
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->LoadMemberCall(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), std::move(argInfos), std::move(args), resultInfo, executor);
				}
			}
		}
		std::stringstream ss;
		ss << "Unknown member " << m << " line: " << data.GetLine();
		LogError(ss.str());
		executor = nullptr;
		return false;
	}
private:
	std::unique_ptr<AbstractMemberCallApiProvider> m_ApiProvider;
};
class MemberSetExp final : public Brace::AbstractBraceApi
{
public:
	MemberSetExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		if (data.GetParamNum() != 3)
			return false;
		Brace::OperandLoadtimeInfo loadInfo;
		auto obj = LoadHelper(*data.GetParam(0), loadInfo);
		auto& objInfo = loadInfo;
		auto& m = data.GetParamId(1);
		auto member = m;
		auto* param = data.GetParam(2);
		Brace::OperandLoadtimeInfo argLoadInfo;
		auto p = LoadHelper(*param, argLoadInfo);
		if (objInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(loadInfo.ObjectTypeId);
			if (nullptr != pInfo) {
				AbstractMemberSetApiProvider* pProvider = nullptr;
				switch (pInfo->ObjectCategory) {
				case BRACE_OBJECT_CATEGORY_UOBJECT:
					pProvider = new UObjectMemberSetProvider(GetInterpreter());
					break;
				case BRACE_OBJECT_CATEGORY_ACTOR:
					pProvider = new AActorMemberSetProvider(GetInterpreter());
					break;
				case BRACE_OBJECT_CATEGORY_STRUCT:
					pProvider = new StructMemberSetProvider(GetInterpreter());
					break;
				default:
					pProvider = new ArrayHashtableMemberSetProvider(GetInterpreter());
					break;
				}
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->LoadMemberSet(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), std::move(argLoadInfo), std::move(p), resultInfo, executor);
				}
			}
		}
		else if (objInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
			if (nullptr != pInfo) {
				AbstractMemberSetApiProvider* pProvider = new StringMemberSetProvider(GetInterpreter());
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->LoadMemberSet(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), std::move(argLoadInfo), std::move(p), resultInfo, executor);
				}
			}
		}
		executor = nullptr;
		return true;
	}
private:
	std::unique_ptr<AbstractMemberSetApiProvider> m_ApiProvider;
};
class MemberGetExp final : public Brace::AbstractBraceApi
{
public:
	MemberGetExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		if (data.GetParamNum() != 2)
			return false;
		Brace::OperandLoadtimeInfo loadInfo;
		auto obj = LoadHelper(*data.GetParam(0), loadInfo);
		auto& objInfo = loadInfo;
		auto& m = data.GetParamId(1);
		auto member = m;
		if (objInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(loadInfo.ObjectTypeId);
			if (nullptr != pInfo) {
				AbstractMemberGetApiProvider* pProvider = nullptr;
				switch (pInfo->ObjectCategory) {
				case BRACE_OBJECT_CATEGORY_UOBJECT:
					pProvider = new UObjectMemberGetProvider(GetInterpreter());
					break;
				case BRACE_OBJECT_CATEGORY_ACTOR:
					pProvider = new AActorMemberGetProvider(GetInterpreter());
					break;
				case BRACE_OBJECT_CATEGORY_STRUCT:
					pProvider = new StructMemberGetProvider(GetInterpreter());
					break;
				default:
					pProvider = new ArrayHashtableMemberGetProvider(GetInterpreter());
					break;
				}
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->LoadMemberGet(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), resultInfo, executor);
				}
			}
		}
		else if (objInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
			if (nullptr != pInfo) {
				AbstractMemberGetApiProvider* pProvider = new StringMemberGetProvider(GetInterpreter());
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->LoadMemberGet(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), resultInfo, executor);
				}
			}
		}
		std::stringstream ss;
		ss << "Unknown member " << m << " line: " << data.GetLine();
		LogError(ss.str());
		return false;
	}
private:
	std::unique_ptr<AbstractMemberGetApiProvider> m_ApiProvider;
};
class CollectionCallExp final : public Brace::SimpleBraceApiBase
{
public:
	CollectionCallExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
	{
		/// how to interpret this, f = obj[m] and f(args) or obj[m](obj, args) ?
		if (argInfos.size() < 2)
			return false;
		auto& arr = argInfos[0];
		if (arr.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(arr.ObjectTypeId);
			if (nullptr != pInfo) {
				AbstractCollectionCallApiProvider* pProvider = nullptr;
				switch (pInfo->ObjectCategory) {
				case BRACE_OBJECT_CATEGORY_UOBJECT:
				case BRACE_OBJECT_CATEGORY_ACTOR:
				default:
					pProvider = new ArrayHashtableCollectionCallProvider(GetInterpreter());
					break;
				}
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->TypeInference(func, data, *pInfo, argInfos, resultInfo);
				}
			}
		}
		else if (arr.Type == Brace::BRACE_DATA_TYPE_STRING) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
			if (nullptr != pInfo) {
				AbstractCollectionCallApiProvider* pProvider = new StringCollectionCallProvider(GetInterpreter());
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->TypeInference(func, data, *pInfo, argInfos, resultInfo);
				}
			}
		}
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
	{
		/// how to interpret this, f = obj[m] and f(args) or obj[m](obj, args) ?
		m_ApiProvider->Execute(gvars, lvars, argInfos, resultInfo);
	}
private:
	std::unique_ptr<AbstractCollectionCallApiProvider> m_ApiProvider;
};
class CollectionSetExp final : public Brace::SimpleBraceApiBase
{
public:
	CollectionSetExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
	{
		if (argInfos.size() != 3)
			return false;
		auto& arr = argInfos[0];
		auto& ix = argInfos[1];
		auto& val = argInfos[2];
		if (arr.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(arr.ObjectTypeId);
			if (nullptr != pInfo) {
				AbstractCollectionSetApiProvider* pProvider = nullptr;
				switch (pInfo->ObjectCategory) {
				case BRACE_OBJECT_CATEGORY_UOBJECT:
				case BRACE_OBJECT_CATEGORY_ACTOR:
				default:
					pProvider = new ArrayHashtableCollectionSetProvider(GetInterpreter());
					break;
				}
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->TypeInference(func, data, *pInfo, arr, ix, val, resultInfo);
				}
			}
		}
		else if (arr.Type == Brace::BRACE_DATA_TYPE_STRING) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
			if (nullptr != pInfo) {
				AbstractCollectionSetApiProvider* pProvider = new StringCollectionSetProvider(GetInterpreter());
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->TypeInference(func, data, *pInfo, arr, ix, val, resultInfo);
				}
			}
		}
		std::stringstream ss;
		ss << "Unknown collection type ! line: " << data.GetLine();
		LogError(ss.str());
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
	{
		auto& arr = argInfos[0];
		auto& ix = argInfos[1];
		auto& val = argInfos[2];
		m_ApiProvider->Execute(gvars, lvars, arr, ix, val, resultInfo);
	}
private:
	std::unique_ptr<AbstractCollectionSetApiProvider> m_ApiProvider;
};
class CollectionGetExp final : public Brace::SimpleBraceApiBase
{
public:
	CollectionGetExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
	{
		if (argInfos.size() != 2)
			return false;
		auto& arr = argInfos[0];
		auto& ix = argInfos[1];
		if (arr.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(arr.ObjectTypeId);
			if (nullptr != pInfo) {
				AbstractCollectionGetApiProvider* pProvider = nullptr;
				switch (pInfo->ObjectCategory) {
				case BRACE_OBJECT_CATEGORY_UOBJECT:
				case BRACE_OBJECT_CATEGORY_ACTOR:
				default:
					pProvider = new ArrayHashtableCollectionGetProvider(GetInterpreter());
					break;
				}
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->TypeInference(func, data, *pInfo, arr, ix, resultInfo);
				}
			}
		}
		else if (arr.Type == Brace::BRACE_DATA_TYPE_STRING) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
			if (nullptr != pInfo) {
				AbstractCollectionGetApiProvider* pProvider = new StringCollectionGetProvider(GetInterpreter());
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->TypeInference(func, data, *pInfo, arr, ix, resultInfo);
				}
			}
		}
		std::stringstream ss;
		ss << "Unknown collection type ! line: " << data.GetLine();
		LogError(ss.str());
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
	{
		auto& arr = argInfos[0];
		auto& ix = argInfos[1];
		m_ApiProvider->Execute(gvars, lvars, arr, ix, resultInfo);
	}
private:
	std::unique_ptr<AbstractCollectionGetApiProvider> m_ApiProvider;
};
class LambdaExp final : public Brace::AbstractBraceApi
{
public:
	LambdaExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		//(args) => {...}; or (args)int => {...}; or [...](args) => {...}; or [...](args)int => {...};
		bool hasError = true;
		if (hasError) {
			std::stringstream ss;
			ss << "lambda syntax error, line " << data.GetLine();
			LogError(ss.str());
		}
		return false;
	}
};
class LinqExp final : public Brace::AbstractBraceApi
{
public:
	LinqExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		//linq(collection).select(fields).where(condition).groupby(fields).orderby(fields);
		bool hasError = true;
		if (hasError) {
			std::stringstream ss;
			ss << "linq syntax error, line " << data.GetLine();
			LogError(ss.str());
		}
		return true;
	}
};
class ArrayExp final : public Brace::AbstractBraceApi
{
	enum ArrayCategory
	{
		ARRAY_UNKNOWN = -1,
		ARRAY_BOOL = 0,
		ARRAY_INT,
		ARRAY_FLOAT,
		ARRAY_STRING,
		ARRAY_OBJ
	};
public:
	ArrayExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ObjectTypeId(Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ), m_Args(), m_ArgInfos(), m_ResultInfo()
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& curFunc, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)
	{
		std::vector<Brace::BraceApiExecutor> args;
		std::vector<Brace::OperandLoadtimeInfo> argLoadInfos;
		int num = data.GetParamNum();
		for (int ix = 0; ix < num; ++ix) {
			auto* param = data.GetParam(ix);
			Brace::OperandLoadtimeInfo argLoadInfo;
			auto p = LoadHelper(*param, argLoadInfo);
			args.push_back(std::move(p));
			argLoadInfos.push_back(std::move(argLoadInfo));
		}
		int arrayCategory = ARRAY_UNKNOWN;
		int dataType = Brace::BRACE_DATA_TYPE_UNKNOWN;
		int objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		if (data.IsHighOrder()) {
			auto& lowerFunc = data.GetLowerOrderFunction();
			if (lowerFunc.GetParamNum() == 1 && lowerFunc.GetParamClassUnmasked() == DslData::FunctionData::PARAM_CLASS_ANGLE_BRACKET_COLON) {
				const std::string& id = lowerFunc.GetParamId(0);
				dataType = Brace::GetDataType(id);
				objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
				if (dataType == Brace::BRACE_DATA_TYPE_OBJECT) {
					objTypeId = GetObjectTypeId(*lowerFunc.GetParam(0));
				}
			}
		}
		else if (!argLoadInfos.empty()) {
			auto& firstInfo = argLoadInfos.front();
			dataType = firstInfo.Type;
			objTypeId = firstInfo.ObjectTypeId;
		}
		switch (dataType) {
		case Brace::BRACE_DATA_TYPE_BOOL:
			arrayCategory = ARRAY_BOOL;
			break;
		case Brace::BRACE_DATA_TYPE_INT8:
		case Brace::BRACE_DATA_TYPE_UINT8:
		case Brace::BRACE_DATA_TYPE_INT16:
		case Brace::BRACE_DATA_TYPE_UINT16:
		case Brace::BRACE_DATA_TYPE_INT32:
		case Brace::BRACE_DATA_TYPE_UINT32:
		case Brace::BRACE_DATA_TYPE_INT64:
		case Brace::BRACE_DATA_TYPE_UINT64:
			arrayCategory = ARRAY_INT;
			break;
		case Brace::BRACE_DATA_TYPE_FLOAT:
		case Brace::BRACE_DATA_TYPE_DOUBLE:
			arrayCategory = ARRAY_FLOAT;
			break;
		case Brace::BRACE_DATA_TYPE_STRING:
			arrayCategory = ARRAY_STRING;
			break;
		case Brace::BRACE_DATA_TYPE_OBJECT:
			arrayCategory = ARRAY_OBJ;
			break;
		}
		switch (arrayCategory) {
		case ARRAY_BOOL: {
			bool good = true;
			for (auto& ai : argLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_BOOL && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_Args, args);
				SetArgInfos(argLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayExp::ExecuteBool);
				return true;
			}
		}break;
		case ARRAY_INT: {
			bool good = true;
			for (auto& ai : argLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_Args, args);
				SetArgInfos(argLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayExp::ExecuteInt);
				return true;
			}
		}break;
		case ARRAY_FLOAT: {
			bool good = true;
			for (auto& ai : argLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_DOUBLE) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_Args, args);
				SetArgInfos(argLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayExp::ExecuteFloat);
				return true;
			}
		}break;
		case ARRAY_STRING: {
			bool good = true;
			for (auto& ai : argLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_Args, args);
				SetArgInfos(argLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayExp::ExecuteString);
				return true;
			}
		}break;
		case ARRAY_OBJ: {
			bool good = true;
			for (auto& ai : argLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_OBJECT && ai.ObjectTypeId == objTypeId) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::string typeKey = std::string("array<:") + GetObjectTypeName(objTypeId) + ":>";
				m_ObjectTypeId = g_ObjectInfoMgr.GetObjectTypeId(typeKey);
				if (m_ObjectTypeId == Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN) {
					m_ObjectTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(typeKey);
				}
				auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(m_ObjectTypeId);
				if (nullptr == pInfo) {
					pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(m_ObjectTypeId, BRACE_OBJECT_CATEGORY_OBJ_ARRAY, std::move(typeKey));
					pInfo->TypeParams.push_back(dataType);
					pInfo->TypeParams.push_back(objTypeId);
				}
				if (nullptr != pInfo) {
					std::swap(m_Args, args);
					SetArgInfos(argLoadInfos);
					resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
					resultInfo.ObjectTypeId = m_ObjectTypeId;
					resultInfo.Name = GenTempVarName();
					resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayExp::ExecuteObject);
					return true;
				}
			}
		}break;
		}
		std::stringstream ss;
		ss << "Array syntax error ! array<: bool|int32|float|string|obj :>(v1, v2, ...) line: " << data.GetLine();
		LogError(ss.str());
		return false;
    }
private:
    void SetArgInfos(std::vector<Brace::OperandLoadtimeInfo> argLoadInfos)
    {
        for (auto& info : argLoadInfos) {
            m_ArgInfos.push_back(info);
        }
    }
private:
	int ExecuteBool(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_Args) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using BoolArrayObj = ArrayObjT<bool>;
		auto* p = new BoolArrayObj();
		for (auto& ai : m_ArgInfos) {
			bool v = VarGetBoolean((ai.IsGlobal ? gvars : lvars), ai.Type, ai.VarIndex);
			p->GetImpl().push_back(v);
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteInt(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_Args) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using IntArrayObj = ArrayObjT<int64_t>;
		auto* p = new IntArrayObj();
		for (auto& ai : m_ArgInfos) {
			int64_t v = VarGetI64((ai.IsGlobal ? gvars : lvars), ai.Type, ai.VarIndex);
			p->GetImpl().push_back(v);
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteFloat(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_Args) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using FloatArrayObj = ArrayObjT<double>;
		auto* p = new FloatArrayObj();
		for (auto& ai : m_ArgInfos) {
			double v = VarGetF64((ai.IsGlobal ? gvars : lvars), ai.Type, ai.VarIndex);
			p->GetImpl().push_back(v);
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteString(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_Args) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using StrArrayObj = ArrayObjT<std::string>;
		auto* p = new StrArrayObj();
		for (auto& ai : m_ArgInfos) {
			const std::string& v = VarGetString((ai.IsGlobal ? gvars : lvars), ai.VarIndex);
			p->GetImpl().push_back(v);
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteObject(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_Args) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		auto* p = new ObjectArray();
		for (auto& ai : m_ArgInfos) {
			auto& v = VarGetObject((ai.IsGlobal ? gvars : lvars), ai.VarIndex);
			p->GetImpl().push_back(v);
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	int m_ObjectTypeId;
	std::vector<Brace::BraceApiExecutor> m_Args;
	std::vector<Brace::OperandRuntimeInfo> m_ArgInfos;
	Brace::OperandRuntimeInfo m_ResultInfo;
};
class HashtableExp final : public Brace::AbstractBraceApi
{
	enum HashtableCategory
	{
		HASHTABLE_UNKNOWN = -1,
		HASHTABLE_STR_STR = 0,
		HASHTABLE_STR_INT,
		HASHTABLE_STR_FLOAT,
		HASHTABLE_STR_BOOL,
		HASHTABLE_STR_OBJ,
		HASHTABLE_INT_STR,
		HASHTABLE_INT_INT,
		HASHTABLE_INT_FLOAT,
		HASHTABLE_INT_BOOL,
		HASHTABLE_INT_OBJ
	};
public:
	HashtableExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		std::vector<Brace::BraceApiExecutor> argKeys;
		std::vector<Brace::BraceApiExecutor> argVals;
		std::vector<Brace::OperandLoadtimeInfo> argKeyLoadInfos;
		std::vector<Brace::OperandLoadtimeInfo> argValLoadInfos;
		int num = data.GetParamNum();
		for (int ix = 0; ix < num; ++ix) {
			auto* param = data.GetParam(ix);
			if (param->GetSyntaxType() != DslData::ISyntaxComponent::TYPE_FUNCTION || (param->GetId() != "=>" && param->GetId() != ":")) {
				std::stringstream ss;
				ss << "Hashtable syntax error ! param must be pairs (k1 => v1, k2 => v2, ...) line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			auto* funcData = static_cast<DslData::FunctionData*>(param);
			if (funcData->GetParamNum() != 2) {
				std::stringstream ss;
				ss << "Hashtable syntax error ! param must be pairs (k1 => v1, k2 => v2, ...) line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			Brace::OperandLoadtimeInfo argKeyLoadInfo;
			Brace::OperandLoadtimeInfo argValLoadInfo;
			auto p_key = LoadHelper(*funcData->GetParam(0), argKeyLoadInfo);
			auto p_val = LoadHelper(*funcData->GetParam(1), argValLoadInfo);
			argKeys.push_back(std::move(p_key));
			argKeyLoadInfos.push_back(std::move(argKeyLoadInfo));
			argVals.push_back(std::move(p_val));
			argValLoadInfos.push_back(std::move(argValLoadInfo));
		}
		int hashtableCategory = HASHTABLE_UNKNOWN;
		int keyDataType = Brace::BRACE_DATA_TYPE_UNKNOWN;
		int valDataType = Brace::BRACE_DATA_TYPE_UNKNOWN;
		int keyObjTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		int valObjTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		if (data.IsHighOrder()) {
			auto& lowerFunc = data.GetLowerOrderFunction();
			if (lowerFunc.GetParamNum() == 2 && lowerFunc.GetParamClassUnmasked() == DslData::FunctionData::PARAM_CLASS_ANGLE_BRACKET_COLON) {
				const std::string& key = lowerFunc.GetParamId(0);
				const std::string& val = lowerFunc.GetParamId(1);
				keyDataType = Brace::GetDataType(key);
				valDataType = Brace::GetDataType(val);
				if (valDataType == Brace::BRACE_DATA_TYPE_OBJECT) {
					valObjTypeId = GetObjectTypeId(*lowerFunc.GetParam(1));
				}
			}
		}
		else if (!argKeyLoadInfos.empty() && !argValLoadInfos.empty()) {
			auto& firstKeyInfo = argKeyLoadInfos.front();
			auto& firstValInfo = argValLoadInfos.front();
			keyDataType = firstKeyInfo.Type;
			keyObjTypeId = firstKeyInfo.ObjectTypeId;
			valDataType = firstValInfo.Type;
			valObjTypeId = firstValInfo.ObjectTypeId;
		}
		switch (keyDataType) {
		case Brace::BRACE_DATA_TYPE_STRING:
			switch (valDataType) {
			case Brace::BRACE_DATA_TYPE_BOOL:
				hashtableCategory = HASHTABLE_STR_BOOL;
				break;
			case Brace::BRACE_DATA_TYPE_INT8:
			case Brace::BRACE_DATA_TYPE_UINT8:
			case Brace::BRACE_DATA_TYPE_INT16:
			case Brace::BRACE_DATA_TYPE_UINT16:
			case Brace::BRACE_DATA_TYPE_INT32:
			case Brace::BRACE_DATA_TYPE_UINT32:
			case Brace::BRACE_DATA_TYPE_INT64:
			case Brace::BRACE_DATA_TYPE_UINT64:
				hashtableCategory = HASHTABLE_STR_INT;
				break;
			case Brace::BRACE_DATA_TYPE_FLOAT:
			case Brace::BRACE_DATA_TYPE_DOUBLE:
				hashtableCategory = HASHTABLE_STR_FLOAT;
				break;
			case Brace::BRACE_DATA_TYPE_STRING:
				hashtableCategory = HASHTABLE_STR_STR;
				break;
			case Brace::BRACE_DATA_TYPE_OBJECT:
				hashtableCategory = HASHTABLE_STR_OBJ;
				break;
			}
			break;
		case Brace::BRACE_DATA_TYPE_INT8:
		case Brace::BRACE_DATA_TYPE_UINT8:
		case Brace::BRACE_DATA_TYPE_INT16:
		case Brace::BRACE_DATA_TYPE_UINT16:
		case Brace::BRACE_DATA_TYPE_INT32:
		case Brace::BRACE_DATA_TYPE_UINT32:
		case Brace::BRACE_DATA_TYPE_INT64:
		case Brace::BRACE_DATA_TYPE_UINT64:
			switch (valDataType) {
			case Brace::BRACE_DATA_TYPE_BOOL:
				hashtableCategory = HASHTABLE_INT_BOOL;
				break;
			case Brace::BRACE_DATA_TYPE_INT8:
			case Brace::BRACE_DATA_TYPE_UINT8:
			case Brace::BRACE_DATA_TYPE_INT16:
			case Brace::BRACE_DATA_TYPE_UINT16:
			case Brace::BRACE_DATA_TYPE_INT32:
			case Brace::BRACE_DATA_TYPE_UINT32:
			case Brace::BRACE_DATA_TYPE_INT64:
			case Brace::BRACE_DATA_TYPE_UINT64:
				hashtableCategory = HASHTABLE_INT_INT;
				break;
			case Brace::BRACE_DATA_TYPE_FLOAT:
			case Brace::BRACE_DATA_TYPE_DOUBLE:
				hashtableCategory = HASHTABLE_INT_FLOAT;
				break;
			case Brace::BRACE_DATA_TYPE_STRING:
				hashtableCategory = HASHTABLE_INT_STR;
				break;
			case Brace::BRACE_DATA_TYPE_OBJECT:
				hashtableCategory = HASHTABLE_INT_OBJ;
				break;
			}
			break;
		}
		switch (hashtableCategory) {
		case HASHTABLE_INT_BOOL: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_BOOL && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteIntBool);
				return true;
			}
		}break;
		case HASHTABLE_INT_INT: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteIntInt);
				return true;
			}
		}break;
		case HASHTABLE_INT_FLOAT: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_DOUBLE) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteIntFloat);
				return true;
			}
		}break;
		case HASHTABLE_INT_STR: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteIntStr);
				return true;
			}
		}break;
		case HASHTABLE_INT_OBJ: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_OBJECT && ai.ObjectTypeId == valObjTypeId) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::string typeKey = std::string("array<:") + GetObjectTypeName(valObjTypeId) + ":>";
				int objectTypeId = g_ObjectInfoMgr.GetObjectTypeId(typeKey);
				if (objectTypeId == Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN) {
					objectTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(typeKey);
				}
				auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objectTypeId);
				if (nullptr == pInfo) {
					pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(objectTypeId, BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE, std::move(typeKey));
					pInfo->TypeParams.push_back(keyDataType);
					pInfo->TypeParams.push_back(keyObjTypeId);
					pInfo->TypeParams.push_back(valDataType);
					pInfo->TypeParams.push_back(valObjTypeId);
				}
				if (nullptr != pInfo) {
					std::swap(m_ArgKeys, argKeys);
					SetArgKeyInfos(argKeyLoadInfos);
					std::swap(m_ArgVals, argVals);
					SetArgValInfos(argValLoadInfos);
					resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
					resultInfo.ObjectTypeId = objectTypeId;
					resultInfo.Name = GenTempVarName();
					resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
					m_ResultInfo = resultInfo;
					executor.attach(this, &HashtableExp::ExecuteIntObj);
					return true;
				}
			}
		}break;
		case HASHTABLE_STR_BOOL: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_BOOL && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteStrBool);
				return true;
			}
		}break;
		case HASHTABLE_STR_INT: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteStrInt);
				return true;
			}
		}break;
		case HASHTABLE_STR_FLOAT: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_DOUBLE) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteStrFloat);
				return true;
			}
		}break;
		case HASHTABLE_STR_STR: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteStrStr);
				return true;
			}
		}break;
		case HASHTABLE_STR_OBJ: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_OBJECT && ai.ObjectTypeId == valObjTypeId) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::string typeKey = std::string("array<:") + GetObjectTypeName(valObjTypeId) + ":>";
				int objectTypeId = g_ObjectInfoMgr.GetObjectTypeId(typeKey);
				if (objectTypeId == Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN) {
					objectTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(typeKey);
				}
				auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objectTypeId);
				if (nullptr == pInfo) {
					pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(objectTypeId, BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE, std::move(typeKey));
					pInfo->TypeParams.push_back(keyDataType);
					pInfo->TypeParams.push_back(keyObjTypeId);
					pInfo->TypeParams.push_back(valDataType);
					pInfo->TypeParams.push_back(valObjTypeId);
				}
				if (nullptr != pInfo) {
					std::swap(m_ArgKeys, argKeys);
					SetArgKeyInfos(argKeyLoadInfos);
					std::swap(m_ArgVals, argVals);
					SetArgValInfos(argValLoadInfos);
					resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
					resultInfo.ObjectTypeId = objectTypeId;
					resultInfo.Name = GenTempVarName();
					resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
					m_ResultInfo = resultInfo;
					executor.attach(this, &HashtableExp::ExecuteStrObj);
					return true;
				}
			}
		}break;
		}
		std::stringstream ss;
		ss << "Hashtable syntax error ! hashtable<: int32|string, bool|int32|float|string|obj :>(k1 => v1, k2 => v2, ...) line: " << data.GetLine();
		LogError(ss.str());
		return false;
	}
private:
	void SetArgKeyInfos(std::vector<Brace::OperandLoadtimeInfo> argKeyLoadInfos)
	{
		for (auto& info : argKeyLoadInfos) {
			m_ArgKeyInfos.push_back(info);
		}
	}
	void SetArgValInfos(std::vector<Brace::OperandLoadtimeInfo> argValLoadInfos)
	{
		for (auto& info : argValLoadInfos) {
			m_ArgValInfos.push_back(info);
		}
	}
private:
	int ExecuteIntStr(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<int64_t, std::string>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			int64_t k = VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			std::string v = VarGetStr((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(k, std::move(v)));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntInt(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<int64_t, int64_t>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			int64_t k = VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			int64_t v = VarGetI64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(k, v));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntFloat(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<int64_t, double>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			int64_t k = VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			double v = VarGetF64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(k, v));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntBool(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<int64_t, bool>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			int64_t k = VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			bool v = VarGetBoolean((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(k, v));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntObj(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		auto* p = new IntObjHashtable();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			int64_t k = VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			auto v = VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
			p->GetImpl().insert(std::make_pair(k, std::move(v)));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrStr(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<std::string, std::string>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			std::string k = VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			std::string v = VarGetStr((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(std::move(k), std::move(v)));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrInt(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<std::string, int64_t>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			std::string k = VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			int64_t v = VarGetI64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(std::move(k), v));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrFloat(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<std::string, double>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			std::string k = VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			double v = VarGetF64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(std::move(k), v));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrBool(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<std::string, bool>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			std::string k = VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			bool v = VarGetBoolean((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(std::move(k), v));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrObj(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		auto* p = new StrObjHashtable();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			std::string k = VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			auto v = VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
			p->GetImpl().insert(std::make_pair(std::move(k), std::move(v)));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	std::vector<Brace::BraceApiExecutor> m_ArgKeys;
	std::vector<Brace::OperandRuntimeInfo> m_ArgKeyInfos;
	std::vector<Brace::BraceApiExecutor> m_ArgVals;
	std::vector<Brace::OperandRuntimeInfo> m_ArgValInfos;
	Brace::OperandRuntimeInfo m_ResultInfo;
};
class LoopListExp final : public Brace::AbstractBraceApi
{
public:
	LoopListExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& funcData, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		if (funcData.IsHighOrder()) {
			bool ret = false;
			auto* p = funcData.GetLowerOrderFunction().GetParam(0);
			Brace::OperandLoadtimeInfo loadInfo;
			auto list = LoadHelper(*p, loadInfo);
			auto& listInfo = loadInfo;
            PushBlock();
			BraceObjectInfo* pInfo = nullptr;
            AbstractLoopListApiProvider* pProvider = nullptr;
			if (listInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
				pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(listInfo.ObjectTypeId);
				if (nullptr != pInfo) {
					switch (pInfo->ObjectCategory) {
					case BRACE_OBJECT_CATEGORY_UOBJECT:
					case BRACE_OBJECT_CATEGORY_ACTOR:
					default:
						pProvider = new ArrayHashtableLoopListProvider(GetInterpreter());
						break;
					}
				}
			}
			else if (listInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
				pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
				if (nullptr != pInfo) {
					pProvider = new StringLoopListProvider(GetInterpreter());
				}
			}
			if (pProvider) {
				ret = true;
				m_ApiProvider.reset(pProvider);
				if (!pProvider->TypeInference(func, funcData, *pInfo, listInfo, executor)) {
					std::stringstream ss;
					ss << "BraceScript error, " << funcData.GetId() << " line " << funcData.GetLine();
					LogError(ss.str());
					ret = false;
				}
				else {
					std::vector<Brace::BraceApiExecutor> statements{};
					for (int ix = 0; ix < funcData.GetParamNum(); ++ix) {
						Brace::OperandLoadtimeInfo argLoadInfo;
						auto statement = LoadHelper(*funcData.GetParam(ix), argLoadInfo);
						if (!statement.isNull())
							statements.push_back(std::move(statement));
					}
					auto& objVars = CurBlockObjVars();
					pProvider->StoreRuntimeInfo(std::move(listInfo), std::move(list), std::move(statements), std::move(objVars));
				}
			}
			PopBlock();
			return ret;
		}
		else {
			//error
			std::stringstream ss;
			ss << "BraceScript error, " << funcData.GetId() << " line " << funcData.GetLine();
			LogError(ss.str());
		}
		return false;
	}
	virtual bool LoadStatement(const Brace::FuncInfo& func, const DslData::StatementData& statementData, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		//looplist(exp) func(args);
		if (statementData.GetFunctionNum() == 2) {
			auto* first = statementData.GetFirst()->AsFunction();
			auto* second = statementData.GetSecond()->AsFunction();
			const std::string& firstId = first->GetId();
			const std::string& secondId = second->GetId();
			if (firstId == "looplist" && !first->HaveStatement() && !first->HaveExternScript() &&
				!secondId.empty() && !second->HaveStatement() && !second->HaveExternScript()) {
				if (first->GetParamNum() > 0) {
					bool ret = false;
					auto* exp = first->GetParam(0);
					Brace::OperandLoadtimeInfo loadInfo;
					auto list = LoadHelper(*exp, loadInfo);
                    auto& listInfo = loadInfo;
					if (listInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
						auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(listInfo.ObjectTypeId);
						if (nullptr != pInfo) {
							AbstractLoopListApiProvider* pProvider = nullptr;
							switch (pInfo->ObjectCategory) {
							case BRACE_OBJECT_CATEGORY_UOBJECT:
							case BRACE_OBJECT_CATEGORY_ACTOR:
							default:
								pProvider = new ArrayHashtableLoopListProvider(GetInterpreter());
								break;
							}
							if (pProvider) {
								ret = true;
								m_ApiProvider.reset(pProvider);
								if (!pProvider->TypeInference(func, statementData, *pInfo, listInfo, executor)) {
									std::stringstream ss;
									ss << "BraceScript error, " << statementData.GetId() << " line " << statementData.GetLine();
									LogError(ss.str());
									ret = false;
								}
								else {
									Brace::OperandLoadtimeInfo argLoadInfo;
									std::vector<Brace::BraceApiExecutor> statements{};
									auto statement = LoadHelper(*second, argLoadInfo);
									if (!statement.isNull())
										statements.push_back(std::move(statement));
									pProvider->StoreRuntimeInfo(std::move(listInfo), std::move(list), std::move(statements), std::vector<int>());
								}
							}
						}
					}
					return ret;
				}
				else {
					//error
					std::stringstream ss;
					ss << "BraceScript error, " << first->GetId() << " line " << first->GetLine();
					LogError(ss.str());
					return false;
				}
				return true;
			}
		}
		return false;
	}
private:
	std::unique_ptr<AbstractLoopListApiProvider> m_ApiProvider;
};


/*
*   ========== in BraceScript init code, some callbacks must be implemented. ==========
* 
	m_pBraceScript = new Brace::BraceScript();
	m_pBraceScript->OnInfo = [](auto& str) { printf("[brace info]:%s", str.c_str()); };
	m_pBraceScript->OnWarn = [](auto& str) { printf("[brace warn]:%s", str.c_str()); };
	m_pBraceScript->OnError = [](auto& str) { printf("[brace error]:%s", str.c_str()); };

	m_pBraceScript->OnGetObjectTypeId = [](const DslData::ISyntaxComponent& syntax) {
		std::string key = g_ObjectInfoMgr.CalcObjTypeKey(syntax);
		return g_ObjectInfoMgr.GetObjectTypeId(key);
	};
	m_pBraceScript->OnGetObjectTypeName = [](int objTypeId) {
		auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
		if (nullptr != pInfo)
			return pInfo->TypeName.c_str();
		return "unknown";
	};
	m_pBraceScript->OnObjectAssignCheck = [](int destObjTypeId, int srcObjTypeId) {
		if (destObjTypeId == srcObjTypeId)
			return true;
		return false;
	};

	/// missing language features
	m_pBraceScript->RegisterApi("membercall", new Brace::BraceApiFactory<MemberCallExp>());
	m_pBraceScript->RegisterApi("memberset", new Brace::BraceApiFactory<MemberSetExp>());
	m_pBraceScript->RegisterApi("memberget", new Brace::BraceApiFactory<MemberGetExp>());
	m_pBraceScript->RegisterApi("collectioncall", new Brace::BraceApiFactory<CollectionCallExp>());
	m_pBraceScript->RegisterApi("collectionset", new Brace::BraceApiFactory<CollectionSetExp>());
	m_pBraceScript->RegisterApi("collectionget", new Brace::BraceApiFactory<CollectionGetExp>());
	m_pBraceScript->RegisterApi("linq", new Brace::BraceApiFactory<LinqExp>());
	m_pBraceScript->RegisterApi("lambda", new Brace::BraceApiFactory<LambdaExp>());
	m_pBraceScript->RegisterApi("array", new Brace::BraceApiFactory<ArrayExp>());
	m_pBraceScript->RegisterApi("hashtable", new Brace::BraceApiFactory<HashtableExp>());
	m_pBraceScript->RegisterApi("looplist", new Brace::BraceApiFactory<LoopListExp>());

	//add fixed map, obj table id <-> obj category
    	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "string");  //fake obj info for string 
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "array<:bool:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "array<:int64:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "array<:double:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "array<:string:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:int64,bool:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:int64,int64:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:int64,double:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:int64,string:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:string,bool:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:string,int64:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:string,double:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:string,string:>");
    	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT, BRACE_OBJECT_CATEGORY_UOBJECT, "uobject");
    	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_CPP_ACTOR, BRACE_OBJECT_CATEGORY_ACTOR, "actor");
*/