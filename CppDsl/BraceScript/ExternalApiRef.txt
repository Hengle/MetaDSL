

    enum BraceObjectCategoryEnum
    {
        /// <summary>
        /// Internal objects, no inheritance, handled specifically in the MemberCall/MemberSet/MemberGet/CollectionCall/CollectionSet/CollectionGet/LoopList APIs.
        /// </summary>
        BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT = 0,
        /// <summary>
        /// Internal special objects, handled specifically in the MemberCall/MemberSet/MemberGet/CollectionCall/CollectionSet/CollectionGet/LoopList APIs.
        /// </summary>
        BRACE_OBJECT_CATEGORY_OBJ_ARRAY,
        BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE,
        BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE,
        /// <summary>
        /// Custom structs, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_STRUCT,
        /// <summary>
        /// Custom objects, has inheritance, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_CUSTOM,
        /// <summary>
        /// Custom objects, inherit from UObject, can be used in UE api, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_UOBJECT,
        /// <summary>
        /// Custom objects, inherit from AActor, can be used in UE api, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_ACTOR,
        /// <summary>
        /// Custom objects, inherit from UActorComponent, can be used in UE api, we will use a class to handle member/collection operations for this category.
        /// </summary>
        BRACE_OBJECT_CATEGORY_ACTOR_COMPONENT,
        BRACE_OBJECT_CATEGORY_NUM
    };
    enum CustomBraceObjectTypeIdEnum
    {
        CUSTOM_BRACE_OBJECT_TYPE_STRING = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NUM,
        CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY,
        CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY,
        CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY,
        CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY,
        CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE,
        CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT,
        BRACE_INNER_FIXED_OBJECT_TYPE_NUM
    };

    struct MethodInfo final
    {
        Brace::DataTypeInfo ReturnType;
        std::vector<Brace::ParamTypeInfo> ParamTypes;
        std::string Name;
    };
    struct BraceObjectInfo;
    struct FieldInfo final
    {
        Brace::DataTypeInfo Type;
        int Offset;
        int Size;
        bool IsPtr;
        std::string Name;
        const BraceObjectInfo* BraceObjInfo;
    };
    struct MethodTableInfo final
    {
        std::vector<MethodInfo> Methods;
    };
    struct FieldTableInfo final
    {
        int Size;
        std::vector<FieldInfo> Fields;
    };
    struct BraceObjectInfo final
    {
        std::string TypeName;
        int ObjectTypeId;
        int ObjectCategory;
        std::vector<int> TypeParams;
        MethodTableInfo MethodTable;
        FieldTableInfo FieldTable;
    };

    class MemberCallExp;
    class MemberSetExp;
    class MemberGetExp;
    class CollectionCallExp;
    class CollectionSetExp;
    class CollectionGetExp;
    class LoopListExp;
    class LinqExp;
    class SelectExp;
    class AbstractMemberCallApiProvider : public Brace::BraceApiImplHelper
    {
        friend class MemberCallExp;
    protected:
        virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) = 0;
    protected:
        AbstractMemberCallApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractMemberSetApiProvider : public Brace::BraceApiImplHelper
    {
        friend class MemberSetExp;
    protected:
        virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) = 0;
    protected:
        AbstractMemberSetApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractMemberGetApiProvider : public Brace::BraceApiImplHelper
    {
        friend class MemberGetExp;
    protected:
        virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) = 0;
    protected:
        AbstractMemberGetApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractCollectionCallApiProvider : public Brace::BraceApiImplHelper
    {
        friend class CollectionCallExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) const = 0;
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo) const = 0;
    protected:
        AbstractCollectionCallApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractCollectionSetApiProvider : public Brace::BraceApiImplHelper
    {
        friend class CollectionSetExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, const Brace::OperandLoadtimeInfo& val, Brace::OperandLoadtimeInfo& resultInfo) const = 0;
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& val, const Brace::OperandRuntimeInfo& resultInfo) const = 0;
    protected:
        AbstractCollectionSetApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractCollectionGetApiProvider : public Brace::BraceApiImplHelper
    {
        friend class CollectionGetExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, Brace::OperandLoadtimeInfo& resultInfo) const = 0;
        virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& resultInfo) const = 0;
    protected:
        AbstractCollectionGetApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractLoopListApiProvider : public Brace::BraceApiImplHelper
    {
        friend class LoopListExp;
    protected:
        virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::ISyntaxComponent& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor) = 0;
        virtual void StoreRuntimeInfo(Brace::OperandRuntimeInfo&& listInfo, Brace::BraceApiExecutor&& list, std::vector<Brace::BraceApiExecutor>&& statements, const std::vector<int>& objVars) = 0;
    protected:
        AbstractLoopListApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractLinqApiProvider : public Brace::BraceApiImplHelper
    {
        friend class LinqExp;
    protected:
        virtual bool LoadLinqCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, Brace::OperandLoadtimeInfo&& listInfo, Brace::BraceApiExecutor&& list, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<int>&& objVars, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) = 0;
    protected:
        AbstractLinqApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    class AbstractSelectApiProvider : public Brace::BraceApiImplHelper
    {
        friend class SelectExp;
    protected:
        enum StatMethodEnum
        {
            STAT_METHOD_NONE = -1,
            STAT_METHOD_MAX = 0,
            STAT_METHOD_MIN,
            STAT_METHOD_SUM,
            STAT_METHOD_AVG,
            STAT_METHOD_COUNT,
            MAX_STAT_METHOD_NUM
        };
    protected:
        virtual bool LoadSelect(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<int>&& statMethods, std::vector<int>&& objVars) = 0;
        virtual bool LoadTop(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, std::vector<int>&& objVars) = 0;
        virtual bool LoadFromList(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg) = 0;
        virtual bool LoadFromType(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const std::string& type) = 0;
        virtual bool LoadWhere(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, std::vector<int>&& objVars) = 0;
        virtual bool LoadOrderBy(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<bool>&& ascOrDescs, std::vector<int>&& objVars) = 0;
        virtual bool LoadGroupBy(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<int>&& objVars) = 0;
        virtual bool LoadHaving(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg) = 0;
        virtual bool LoadStatements(const Brace::FuncInfo& func, const DslData::FunctionData& data, std::vector<Brace::BraceApiExecutor>&& statements, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) = 0;
        virtual void LoadResultIterator(std::vector<Brace::OperandLoadtimeInfo>&& iterators, std::vector<int>&& objVars) = 0;
    protected:
        AbstractSelectApiProvider(Brace::BraceScript& interpreter) :Brace::BraceApiImplHelper(interpreter)
        {}
    };
    /// <summary>
    /// We make a objtypeid -> BraceObjectInfo map, which allows object category info to process class by category, 
    /// Such as DispatchObject, CustomObject, UObject etc.
    /// </summary>
    class BraceObjectInfoManager final
    {
    public:
        int GetObjectTypeId(const std::string& key)const
        {
            auto it = m_ObjTypeIdMap.find(key);
            if (it != m_ObjTypeIdMap.end())
                return it->second;
            return Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN;
        }
        int AddNewObjectTypeId(const std::string& key)
        {
            int newId = GenNextObjectTypeId();
            m_ObjTypeIdMap.insert(std::make_pair(key, newId));
            return newId;
        }
        BraceObjectInfo* AddBraceObjectInfo(int objTypeId, int objCategory, const std::string& typeName)
        {
            std::string name = typeName;
            return AddBraceObjectInfo(objTypeId, objCategory, std::move(name));
        }
        BraceObjectInfo* AddBraceObjectInfo(int objTypeId, int objCategory, std::string&& typeName)
        {
            auto it = m_ObjTypeIdMap.find(typeName);
            if (it == m_ObjTypeIdMap.end()) {
                m_ObjTypeIdMap.insert(std::make_pair(typeName, objTypeId));
            }
            BraceObjectInfo info{};
            info.TypeName = std::move(typeName);
            info.ObjectCategory = objCategory;
            info.ObjectTypeId = objTypeId;
            auto pair = m_ObjInfoMap.insert(std::make_pair(objTypeId, std::move(info)));
            return pair.second ? &(pair.first->second) : nullptr;
        }
        const BraceObjectInfo* GetBraceObjectInfo(int objTypeId)const
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end())
                return &(it->second);
            return nullptr;
        }
        BraceObjectInfo* GetBraceObjectInfo(int objTypeId)
        {
            auto it = m_ObjInfoMap.find(objTypeId);
            if (it != m_ObjInfoMap.end())
                return &(it->second);
            return nullptr;
        }
    public:
        BraceObjectInfoManager(void) :m_ObjTypeIdMap(), m_ObjInfoMap(), m_NextObjectTypeId(BRACE_INNER_FIXED_OBJECT_TYPE_NUM)
        {}
    private:
        int GenNextObjectTypeId(void)
        {
            return m_NextObjectTypeId++;
        }
    private:
        std::unordered_map<std::string, int> m_ObjTypeIdMap;
        std::unordered_map<int, BraceObjectInfo> m_ObjInfoMap;
        int m_NextObjectTypeId;
    public:
        static void CalcObjTypeKey(const DslData::ISyntaxComponent& syntax, std::stringstream& ss)
        {
            if (syntax.GetSyntaxType() == DslData::ISyntaxComponent::TYPE_FUNCTION) {
                ss << syntax.GetId();
                ss << "<:";
                auto& funcData = static_cast<const DslData::FunctionData&>(syntax);
                for (int ix = 0; ix < funcData.GetParamNum(); ++ix) {
                    auto& p = *funcData.GetParam(ix);
                    CalcObjTypeKey(p, ss);
                }
                ss << ":>";
            }
            else if (syntax.GetSyntaxType() == DslData::ISyntaxComponent::TYPE_VALUE) {
                ss << syntax.GetId();
            }
        }
        static std::string CalcObjTypeKey(const DslData::ISyntaxComponent& syntax)
        {
            std::stringstream ss;
            CalcObjTypeKey(syntax, ss);
            return ss.str();
        }
    };
    static BraceObjectInfoManager g_ObjectInfoMgr;

class UObjectMemberCallProvider final : public AbstractMemberCallApiProvider
{
	friend class MemberCallExp;
protected:
	virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	UObjectMemberCallProvider(Brace::BraceScript& interpreter) :AbstractMemberCallApiProvider(interpreter)
	{}
};
class UObjectMemberSetProvider final : public AbstractMemberSetApiProvider
{
	friend class MemberSetExp;
protected:
	virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	UObjectMemberSetProvider(Brace::BraceScript& interpreter) :AbstractMemberSetApiProvider(interpreter)
	{}
};
class UObjectMemberGetProvider final : public AbstractMemberGetApiProvider
{
	friend class MemberGetExp;
protected:
	virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	UObjectMemberGetProvider(Brace::BraceScript& interpreter) :AbstractMemberGetApiProvider(interpreter)
	{}
};

template<typename T>
class ArrayObjT final : public Brace::IBraceObject
{
public:
	using ArrayType = std::vector<T>;
public:
	ArrayObjT(void) :m_Array()
	{}
	virtual ~ArrayObjT(void) override
	{
	}
public:
	const std::vector<T>& GetImpl(void)const { return m_Array; }
	std::vector<T>& GetImpl(void) { return m_Array; }
private:
	std::vector<T> m_Array;
};
class ObjectArray final : public Brace::IBraceObject
{
public:
	using ArrayType = std::vector<std::shared_ptr<Brace::IBraceObject>>;
public:
	ObjectArray(void) :m_Array()
	{}
	virtual ~ObjectArray(void) override
	{
	}
public:
	const ArrayType& GetImpl(void)const { return m_Array; }
	ArrayType& GetImpl(void) { return m_Array; }
private:
	ArrayType m_Array;
};

template<typename KeyT, typename ValT>
class HashtableObjT final : public Brace::IBraceObject
{
public:
	using HashType = std::unordered_map<KeyT, ValT>;
public:
	HashtableObjT(void) :m_Hashtable()
	{}
	virtual ~HashtableObjT(void) override
	{

	}
public:
	const std::unordered_map<KeyT, ValT>& GetImpl(void)const { return m_Hashtable; }
	std::unordered_map<KeyT, ValT>& GetImpl(void) { return m_Hashtable; }
private:
	std::unordered_map<KeyT, ValT> m_Hashtable;
};
class StrObjHashtable final : public Brace::IBraceObject
{
public:
	using HashType = std::unordered_map<std::string, std::shared_ptr<Brace::IBraceObject>>;
public:
	StrObjHashtable(void) :m_Hashtable()
	{}
	virtual ~StrObjHashtable(void) override
	{}
public:
	const HashType& GetImpl(void)const { return m_Hashtable; }
	HashType& GetImpl(void) { return m_Hashtable; }
private:
	HashType m_Hashtable;
};
class IntObjHashtable final : public Brace::IBraceObject
{
public:
	using IntObjHashtableType = std::unordered_map<int64_t, std::shared_ptr<Brace::IBraceObject>>;
public:
	IntObjHashtable(void) :m_Hashtable()
	{}
	virtual ~IntObjHashtable(void) override
	{}
public:
	const IntObjHashtableType& GetImpl(void)const { return m_Hashtable; }
	IntObjHashtableType& GetImpl(void) { return m_Hashtable; }
private:
	IntObjHashtableType m_Hashtable;
};

/// Internally fixed collection objects use switch-case rather than virtual-function-dispatch, simply because switch-case may require less code.
/// and virtual-function-dispatch must define one class for each API, and dozens may be required.
class ArrayHashtableMemberCallProvider final : public AbstractMemberCallApiProvider
{
	friend class MemberCallExp;
protected:
	virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		int num = data.GetParamNum();
		if (num < 2)
			return false;
		std::swap(m_Obj, obj);
		m_ObjInfo = objInfo;
		std::swap(m_Member, member);
		std::swap(m_Args, args);
		Brace::OperandLoadtimeInfo firstArgInfo;
		bool first = true;
		for(auto& argInfo : argInfos) {
			m_ArgInfos.push_back(argInfo);
			if (first) {
				first = false;
				firstArgInfo = std::move(argInfo);
			}
		}
		bool isArray = false;
		bool isHashtable = false;
		bool isIntKey = true;
		int dataType = Brace::BRACE_DATA_TYPE_OBJECT;
		int objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		switch (objInfo.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		}
		switch (braceObjInfo.ObjectCategory) {
		case BRACE_OBJECT_CATEGORY_OBJ_ARRAY:
			isArray = true;
			objTypeId = braceObjInfo.TypeParams.back();
			break;
		case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE:
			isHashtable = true;
			break;
		case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			break;
		}
		if (isArray) {
			if (m_Member == "resize") {
				bool good = false;
				if (m_ArgInfos.size() == 1) {
					auto& argInfo = m_ArgInfos[0];
					if (argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
						good = true;
					}
				}
				if (good) {
					resultInfo = Brace::OperandLoadtimeInfo();
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayResize);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Array.resize's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "push") {
				bool good = false;
				if (m_ArgInfos.size() == 1) {
					if (CanAssign(dataType, objTypeId, firstArgInfo.Type, firstArgInfo.ObjectTypeId)) {
						good = true;
					}
				}
				if (good) {
					resultInfo = Brace::OperandLoadtimeInfo();
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayPush);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Array.push's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "pop") {
				resultInfo.Type = dataType;
				resultInfo.ObjectTypeId = objTypeId;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayPop);
				return true;
			}
			else if (m_Member == "insert") {
				bool good = false;
				if (m_ArgInfos.size() == 2) {
					auto& keyArgInfo = m_ArgInfos[0];
					auto& valArgInfo = m_ArgInfos[1];
					if (keyArgInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && keyArgInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
						if (CanAssign(dataType, objTypeId, valArgInfo.Type, valArgInfo.VarIndex)) {
							good = true;
						}
					}
				}
				if (good) {
					resultInfo = Brace::OperandLoadtimeInfo();
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayInsert);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Array.insert's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "remove") {
				bool good = false;
				if (m_ArgInfos.size() == 1) {
					auto& argInfo = m_ArgInfos[0];
					if (argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
						good = true;
					}
				}
				if (good) {
					resultInfo = Brace::OperandLoadtimeInfo();
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayRemove);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Array.remove's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "clear") {
				resultInfo = Brace::OperandLoadtimeInfo();
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteArrayClear);
				return true;
			}
		}
		else if (isHashtable) {
			if (m_Member == "contains") {
				bool good = false;
				if (m_ArgInfos.size() == 1) {
					auto& argInfo = m_ArgInfos[0];
					if ((isIntKey && argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) ||
						(!isIntKey && argInfo.Type == Brace::BRACE_DATA_TYPE_STRING)) {
						good = true;
					}
				}
				if (good) {
					resultInfo.Type = Brace::BRACE_DATA_TYPE_BOOL;
					resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
					resultInfo.Name = GenTempVarName();
					resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteHashtableContains);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Hashtable.contains's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "add") {
				bool good = false;
				if (m_ArgInfos.size() == 2) {
					auto& keyArgInfo = m_ArgInfos[0];
					auto& valArgInfo = m_ArgInfos[1];
					if ((isIntKey && keyArgInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && keyArgInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) ||
						(!isIntKey && keyArgInfo.Type == Brace::BRACE_DATA_TYPE_STRING)) {
						if (CanAssign(dataType, objTypeId, valArgInfo.Type, valArgInfo.VarIndex)) {
							good = true;
						}
					}
				}
				if (good) {
					resultInfo = Brace::OperandLoadtimeInfo();
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteHashtableAdd);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Hashtable.add's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "remove") {
				bool good = false;
				if (m_ArgInfos.size() == 1) {
					auto& argInfo = m_ArgInfos[0];
					if ((isIntKey && argInfo.Type >= Brace::BRACE_DATA_TYPE_INT8 && argInfo.Type <= Brace::BRACE_DATA_TYPE_UINT64) ||
						(!isIntKey && argInfo.Type == Brace::BRACE_DATA_TYPE_STRING)) {
						good = true;
					}
				}
				if (good) {
					resultInfo = Brace::OperandLoadtimeInfo();
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteHashtableRemove);
					return true;
				}
				else {
					std::stringstream ss;
					ss << "Hashtable.remove's param dismatch, line: " << data.GetLine();
					LogError(ss.str());
					executor = nullptr;
					return false;
				}
			}
			else if (m_Member == "clear") {
				resultInfo = Brace::OperandLoadtimeInfo();
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayHashtableMemberCallProvider::ExecuteHashtableClear);
				return true;
			}
		}
		std::stringstream ss;
		ss << "Unknown member " << m_Member << " line: " << data.GetLine();
		LogError(ss.str());
		executor = nullptr;
		return false;
	}
private:
	int ExecuteArrayResize(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& arr = m_ObjInfo;
		auto& arg = m_ArgInfos[0];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		switch (arr.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().resize(varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().resize(varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().resize(varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().resize(varg);
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().resize(varg);
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteArrayPush(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& arr = m_ObjInfo;
		auto& arg = m_ArgInfos[0];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		switch (arr.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				bool varg = Brace::VarGetBoolean((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().push_back(varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().push_back(varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				double varg = Brace::VarGetF64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().push_back(varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				std::string varg = Brace::VarGetStr((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				pArr->GetImpl().push_back(std::move(varg));
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				auto varg = Brace::VarGetObject((arg.IsGlobal ? gvars : lvars), arg.VarIndex);
				pArr->GetImpl().push_back(varg);
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteArrayPop(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		auto& arr = m_ObjInfo;
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		switch (arr.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				bool v = pArr->GetImpl().back();
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
				pArr->GetImpl().pop_back();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				int64_t v = pArr->GetImpl().back();
				Brace::VarSetInt64((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
				pArr->GetImpl().pop_back();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				double v = pArr->GetImpl().back();
				Brace::VarSetDouble((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
				pArr->GetImpl().pop_back();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				const std::string& v = pArr->GetImpl().back();
				Brace::VarSetString((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
				pArr->GetImpl().pop_back();
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				auto v = pArr->GetImpl().back();
				Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
				pArr->GetImpl().pop_back();
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteArrayInsert(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& arr = m_ObjInfo;
		auto& arg = m_ArgInfos[0];
		auto& val = m_ArgInfos[1];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		switch (arr.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				bool v = Brace::VarGetBoolean((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
				VectorInsert(pArr->GetImpl(), varg, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				int64_t v = Brace::VarGetI64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
				VectorInsert(pArr->GetImpl(), varg, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				double v = Brace::VarGetF64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
				VectorInsert(pArr->GetImpl(), varg, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				std::string v = Brace::VarGetStr((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
				VectorInsert(pArr->GetImpl(), varg, std::move(v));
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				auto v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
				VectorInsert(pArr->GetImpl(), varg, v);
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteArrayRemove(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& arr = m_ObjInfo;
		auto& arg = m_ArgInfos[0];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		switch (arr.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				VectorErase(pArr->GetImpl(), varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				VectorErase(pArr->GetImpl(), varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				VectorErase(pArr->GetImpl(), varg);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				VectorErase(pArr->GetImpl(), varg);
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				int64_t varg = Brace::VarGetI64((arg.IsGlobal ? gvars : lvars), arg.Type, arg.VarIndex);
				VectorErase(pArr->GetImpl(), varg);
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteArrayClear(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		auto& arr = m_ObjInfo;
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		switch (arr.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				pArr->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				pArr->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				pArr->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				pArr->GetImpl().clear();
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				pArr->GetImpl().clear();
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteHashtableContains(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& hash = m_ObjInfo;
		auto& ix = m_ArgInfos[0];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((hash.IsGlobal ? gvars : lvars), hash.VarIndex);
		int objTypeId = hash.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				bool v = HashtableContains(pHashtable->GetImpl(), vix);
				Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
			}
		}break;
		default: {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
			if (nullptr != pInfo) {
				if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
					auto* ptr = p.get();
					if (nullptr != ptr) {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						bool v = HashtableContains(pHashtable->GetImpl(), vix);
						Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
					}
				}
				else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
					auto* ptr = p.get();
					if (nullptr != ptr) {
						std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						bool v = HashtableContains(pHashtable->GetImpl(), vix);
						Brace::VarSetBool((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, v);
					}
				}
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteHashtableAdd(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& hash = m_ObjInfo;
		auto& ix = m_ArgInfos[0];
		auto& val = m_ArgInfos[1];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((hash.IsGlobal ? gvars : lvars), hash.VarIndex);
		int objTypeId = hash.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			int64_t v = Brace::VarGetInt64((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			double v = Brace::VarGetDouble((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			bool v = Brace::VarGetBool((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			int64_t v = Brace::VarGetInt64((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			double v = Brace::VarGetDouble((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			bool v = Brace::VarGetBool((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		default: {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
			if (nullptr != pInfo) {
				if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
					auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
					auto* ptr = p.get();
					if (nullptr != ptr) {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
					}
				}
				else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
					auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
					auto* ptr = p.get();
					if (nullptr != ptr) {
						std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						pHashtable->GetImpl()[vix] = v;
					}
				}
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteHashtableRemove(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& hash = m_ObjInfo;
		auto& ix = m_ArgInfos[0];
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((hash.IsGlobal ? gvars : lvars), hash.VarIndex);
		int objTypeId = hash.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				pHashtable->GetImpl().erase(vix);
			}
		}break;
		default: {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
			if (nullptr != pInfo) {
				if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
					auto* ptr = p.get();
					if (nullptr != ptr) {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						pHashtable->GetImpl().erase(vix);
					}
				}
				else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
					auto* ptr = p.get();
					if (nullptr != ptr) {
						std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						pHashtable->GetImpl().erase(vix);
					}
				}
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteHashtableClear(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		auto& hash = m_ObjInfo;
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((hash.IsGlobal ? gvars : lvars), hash.VarIndex);
		int objTypeId = hash.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				pHashtable->GetImpl().clear();
			}
		}break;
		default: {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
			if (nullptr != pInfo) {
				if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
					auto* ptr = p.get();
					if (nullptr != ptr) {
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						pHashtable->GetImpl().clear();
					}
				}
				else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
					auto* ptr = p.get();
					if (nullptr != ptr) {
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						pHashtable->GetImpl().clear();
					}
				}
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	ArrayHashtableMemberCallProvider(Brace::BraceScript& interpreter) :AbstractMemberCallApiProvider(interpreter), m_Obj(), m_ObjInfo(), m_Member(), m_Args(), m_ArgInfos(), m_ResultInfo()
	{
	}
private:
	Brace::BraceApiExecutor m_Obj;
	Brace::OperandRuntimeInfo m_ObjInfo;
	std::string m_Member;
	std::vector<Brace::BraceApiExecutor> m_Args;
	std::vector<Brace::OperandRuntimeInfo> m_ArgInfos;
	Brace::OperandRuntimeInfo m_ResultInfo;
private:
	template<typename VectorT, typename ValT>
	static inline void VectorInsert(VectorT& vr, int64_t pos, const ValT& val)
	{
		auto it = vr.begin();
		std::advance(it, pos);
		if (it != vr.end())
			vr.insert(it, val);
		else
			vr.push_back(val);
	}
	template<typename VectorT, typename ValT>
	static inline void VectorInsert(VectorT& vr, int64_t pos, ValT&& val)
	{
		auto it = vr.begin();
		std::advance(it, pos);
		if (it != vr.end())
			vr.insert(it, std::move(val));
		else
			vr.push_back(std::move(val));
	}
	template<typename VectorT>
	static inline void VectorErase(VectorT& vr, int64_t pos)
	{
		auto it = vr.begin();
		std::advance(it, pos);
		if (it != vr.end())
			vr.erase(it);
	}
	template<typename HashtableT, typename ValT>
	static inline bool HashtableContains(const HashtableT& hash, const ValT& val)
	{
		auto it = hash.find(val);
		return it != hash.end();
	}
};
class ArrayHashtableMemberSetProvider final : public AbstractMemberSetApiProvider
{
	friend class MemberSetExp;
protected:
	virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	ArrayHashtableMemberSetProvider(Brace::BraceScript& interpreter) :AbstractMemberSetApiProvider(interpreter)
	{
	}
};
class ArrayHashtableMemberGetProvider final : public AbstractMemberGetApiProvider
{
	friend class MemberGetExp;
protected:
	virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		if (data.GetParamNum() != 2)
			return false;
		std::swap(m_Obj, obj);
		m_ObjInfo = objInfo;
		std::swap(m_Member, member);
		bool isArray = false;
		bool isHashtable = false;
		switch (objInfo.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY:
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY:
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY:
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY:
			isArray = true;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE:
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE:
			isHashtable = true;
			break;
		}
		switch (braceObjInfo.ObjectCategory) {
		case BRACE_OBJECT_CATEGORY_OBJ_ARRAY:
			isArray = true;
			break;
		case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE:
			isHashtable = true;
			break;
		case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE:
			isHashtable = true;
			break;
		}
		if (isArray) {
			if (m_Member == "length") {
				resultInfo.Type = Brace::BRACE_DATA_TYPE_INT32;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayHashtableMemberGetProvider::ExecuteArrayLength);
				return true;
			}
		}
		else if (isHashtable) {
			if (m_Member == "count") {
				resultInfo.Type = Brace::BRACE_DATA_TYPE_INT32;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayHashtableMemberGetProvider::ExecuteHashtableCount);
				return true;
			}
		}
		std::stringstream ss;
		ss << "Unknown member " << m_Member << " line: " << data.GetLine();
		LogError(ss.str());
		return false;
	}
private:
	int ExecuteArrayLength(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
		int objTypeId = m_ObjInfo.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				size_t v = pArr->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int>*>(ptr);
				size_t v = pArr->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				size_t v = pArr->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				size_t v = pArr->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				size_t v = pArr->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteHashtableCount(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((m_ObjInfo.IsGlobal ? gvars : lvars), m_ObjInfo.VarIndex);
		int objTypeId = m_ObjInfo.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, int64_t>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				size_t v = pHashtable->GetImpl().size();
				Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
				if (nullptr != pInfo) {
					if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						size_t v = pHashtable->GetImpl().size();
						Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
					}
					else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						size_t v = pHashtable->GetImpl().size();
						Brace::VarSetInt32((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, static_cast<int32_t>(v));
					}
				}
			}
		}break;
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	ArrayHashtableMemberGetProvider(Brace::BraceScript& interpreter) :AbstractMemberGetApiProvider(interpreter), m_Obj(), m_ObjInfo(), m_Member(), m_ResultInfo()
	{
	}
private:
	Brace::BraceApiExecutor m_Obj;
	Brace::OperandRuntimeInfo m_ObjInfo;
	std::string m_Member;
	Brace::OperandRuntimeInfo m_ResultInfo;
};
class ArrayHashtableCollectionCallProvider final : public AbstractCollectionCallApiProvider
{
	friend class CollectionCallExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) const override
	{
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo) const override
	{
	}
private:
	ArrayHashtableCollectionCallProvider(Brace::BraceScript& interpreter) :AbstractCollectionCallApiProvider(interpreter)
	{}
};
class ArrayHashtableCollectionSetProvider final : public AbstractCollectionSetApiProvider
{
	friend class CollectionSetExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, const Brace::OperandLoadtimeInfo& val, Brace::OperandLoadtimeInfo& resultInfo) const override
	{
		bool isArray = false;
		bool isHashtable = false;
		bool isIntKey = true;
		int dataType = Brace::BRACE_DATA_TYPE_OBJECT;
		int objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		switch (braceObjInfo.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		}
		switch (braceObjInfo.ObjectCategory) {
		case BRACE_OBJECT_CATEGORY_OBJ_ARRAY:
			isArray = true;
			objTypeId = braceObjInfo.TypeParams.back();
			break;
		case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE:
			isHashtable = true;
			break;
		case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			break;
		}
		if (isArray) {
			if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
				std::stringstream ss;
				ss << "Array's index must be integer ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			if (!CanAssign(dataType, objTypeId, val.Type, val.ObjectTypeId)) {
				std::stringstream ss;
				ss << "Array element's type and val type dismatch ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			resultInfo = val;
			return true;
		}
		else if (isHashtable) {
			if (isIntKey) {
				if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
					std::stringstream ss;
					ss << "key must be integer ! line: " << data.GetLine();
					LogError(ss.str());
					return false;
				}
			}
			else {
				if (ix.Type != Brace::BRACE_DATA_TYPE_STRING) {
					std::stringstream ss;
					ss << "key must be string ! line: " << data.GetLine();
					LogError(ss.str());
					return false;
				}
			}
			if (!CanAssign(dataType, objTypeId, val.Type, val.ObjectTypeId)) {
				std::stringstream ss;
				ss << "Hashtable type and val type dismatch ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			resultInfo = val;
			return true;
		}
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& val, const Brace::OperandRuntimeInfo& resultInfo) const override
	{
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		int objTypeId = arr.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			bool v = Brace::VarGetBoolean((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				pArr->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			int64_t v = Brace::VarGetI64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				pArr->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			double v = Brace::VarGetF64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				pArr->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				pArr->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			int64_t v = Brace::VarGetInt64((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			double v = Brace::VarGetDouble((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			bool v = Brace::VarGetBool((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				pHashtable->GetImpl()[vix] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			const std::string& v = Brace::VarGetString((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			int64_t v = Brace::VarGetInt64((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			double v = Brace::VarGetDouble((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			bool v = Brace::VarGetBool((val.IsGlobal ? gvars : lvars), val.VarIndex);
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
			}
		}break;
		default: {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
			if (nullptr != pInfo) {
				if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_OBJ_ARRAY) {
					auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
					auto* ptr = p.get();
					if (nullptr != ptr) {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pArr = static_cast<ObjectArray*>(ptr);
						pArr->GetImpl()[static_cast<size_t>(vix)] = v;
					}
				}
				else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
					auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
					auto* ptr = p.get();
					if (nullptr != ptr) {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						pHashtable->GetImpl()[static_cast<size_t>(vix)] = v;
					}
				}
				else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
					auto& v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
					auto* ptr = p.get();
					if (nullptr != ptr) {
						std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						pHashtable->GetImpl()[vix] = v;
					}
				}
			}
		}break;
		}
	}
private:
	ArrayHashtableCollectionSetProvider(Brace::BraceScript& interpreter) :AbstractCollectionSetApiProvider(interpreter)
	{}
};
class ArrayHashtableCollectionGetProvider final : public AbstractCollectionGetApiProvider
{
	friend class CollectionGetExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, Brace::OperandLoadtimeInfo& resultInfo) const override
	{
		bool isArray = false;
		bool isHashtable = false;
		bool isIntKey = true;
		int dataType = Brace::BRACE_DATA_TYPE_OBJECT;
		int objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		switch (braceObjInfo.ObjectTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY:
			isArray = true;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_STRING;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_INT64;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_DOUBLE;
			break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE:
			isHashtable = true;
			dataType = Brace::BRACE_DATA_TYPE_BOOL;
			break;
		}
		switch (braceObjInfo.ObjectCategory) {
		case BRACE_OBJECT_CATEGORY_OBJ_ARRAY:
			isArray = true;
			objTypeId = braceObjInfo.TypeParams.back();
			break;
		case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE:
			isHashtable = true;
			break;
		case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE:
			isHashtable = true;
			isIntKey = false;
			break;
		}
		if (isArray) {
			if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
				std::stringstream ss;
				ss << "Array's index must be integer ! line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			resultInfo.Type = dataType;
			resultInfo.ObjectTypeId = objTypeId;
			resultInfo.Name = GenTempVarName();
			resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
			return true;
		}
		else if (isHashtable) {
			if (isIntKey) {
				if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
					std::stringstream ss;
					ss << "key must be integer ! line: " << data.GetLine();
					LogError(ss.str());
					return false;
				}
			}
			else {
				if (ix.Type != Brace::BRACE_DATA_TYPE_STRING) {
					std::stringstream ss;
					ss << "key must be string ! line: " << data.GetLine();
					LogError(ss.str());
					return false;
				}
			}
			resultInfo.Type = dataType;
			resultInfo.ObjectTypeId = objTypeId;
			resultInfo.Name = GenTempVarName();
			resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
			return true;
		}
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& resultInfo) const override
	{
		const std::shared_ptr<Brace::IBraceObject>& p = Brace::VarGetObject((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		int objTypeId = arr.ObjectTypeId;
		switch (objTypeId) {
		case CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				bool v = pArr->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetBool((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				int64_t v = pArr->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetInt64((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				double v = pArr->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetDouble((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				const std::string& v = pArr->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetString((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				bool v = pHashtable->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetBool((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				int64_t v = pHashtable->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetInt64((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				double v = pHashtable->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetDouble((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				const std::string& v = pHashtable->GetImpl()[static_cast<size_t>(vix)];
				Brace::VarSetString((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				bool v = pHashtable->GetImpl()[vix];
				Brace::VarSetBool((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, int64_t>*>(ptr);
				int64_t v = pHashtable->GetImpl()[vix];
				Brace::VarSetInt64((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				double v = pHashtable->GetImpl()[vix];
				Brace::VarSetDouble((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		case CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				const std::string& v = pHashtable->GetImpl()[vix];
				Brace::VarSetString((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
			}
		}break;
		default: {
			auto* ptr = p.get();
			if (nullptr != ptr) {
				auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
				if (nullptr != pInfo) {
					switch (pInfo->ObjectCategory) {
					case BRACE_OBJECT_CATEGORY_OBJ_ARRAY: {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pArr = static_cast<ObjectArray*>(ptr);
						auto& v = pArr->GetImpl()[static_cast<size_t>(vix)];
						Brace::VarSetObject((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
					}break;
					case BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE: {
						int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
						auto& v = pHashtable->GetImpl()[static_cast<size_t>(vix)];
						Brace::VarSetObject((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
					}break;
					case BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE: {
						std::string vix = Brace::VarGetStr((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
						auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
						auto& v = pHashtable->GetImpl()[vix];
						Brace::VarSetObject((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, v);
					}break;
					}
				}
			}
		}break;
		}
	}
private:
	ArrayHashtableCollectionGetProvider(Brace::BraceScript& interpreter) :AbstractCollectionGetApiProvider(interpreter)
	{}
};
class ArrayHashtableLoopListProvider final : public AbstractLoopListApiProvider
{
	friend class LoopListExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::ISyntaxComponent& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor) override
	{		
		return TypeInference(listInfo, executor);
	}
	virtual void StoreRuntimeInfo(Brace::OperandRuntimeInfo&& listInfo, Brace::BraceApiExecutor&& list, std::vector<Brace::BraceApiExecutor>&& statements, const std::vector<int>& objVars) override
	{
		std::swap(m_ListInfo, listInfo);
		std::swap(m_List, list);
		std::swap(m_Statements, statements);
		m_ObjVars = objVars;
	}
private:
	ArrayHashtableLoopListProvider(Brace::BraceScript& interpreter) :AbstractLoopListApiProvider(interpreter), m_IteratorIndex(INVALID_INDEX), m_IteratorIndexV(INVALID_INDEX), m_List(), m_ListInfo(), m_Statements(), m_ObjVars()
	{}
private:
	bool TypeInference(const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor)
	{
		if (listInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY) {
				m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_BOOL, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteBoolArray);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY) {
				m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntArray);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY) {
				m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_DOUBLE, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteFloatArray);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY) {
				m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStringArray);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_BOOL, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntBoolHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntIntHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_DOUBLE, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntFloatHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntStrHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_BOOL, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrBoolHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrIntHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_DOUBLE, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrFloatHashtable);
				return true;
			}
			else if (listInfo.ObjectTypeId == CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE) {
				m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
				executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrStrHashtable);
				return true;
			}
			else {
				auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(listInfo.ObjectTypeId);
				if (nullptr != pInfo) {
					if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_OBJ_ARRAY) {
						m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_OBJECT, pInfo->TypeParams.back());
						executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteObjectArray);
						return true;
					}
					else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE) {
						m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_INT64, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
						m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_OBJECT, pInfo->TypeParams.back());
						executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteIntObjHashtable);
						return true;
					}
					else if (pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE) {
						m_IteratorIndex = AllocVariable("$$k", Brace::BRACE_DATA_TYPE_STRING, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
						m_IteratorIndexV = AllocVariable("$$v", Brace::BRACE_DATA_TYPE_OBJECT, pInfo->TypeParams.back());
						executor.attach(this, &ArrayHashtableLoopListProvider::ExecuteStrObjHashtable);
						return true;
					}
				}
			}
		}
		return false;
	}
private:
	int ExecuteBoolArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<bool>*>(ptr);
				for (auto val : pArr->GetImpl()) {
					Brace::VarSetBool(lvars, m_IteratorIndex, val);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<int64_t>*>(ptr);
				for (auto val : pArr->GetImpl()) {
					Brace::VarSetInt64(lvars, m_IteratorIndex, val);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteFloatArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<double>*>(ptr);
				for (auto val : pArr->GetImpl()) {
					Brace::VarSetDouble(lvars, m_IteratorIndex, val);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStringArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ArrayObjT<std::string>*>(ptr);
				for (auto& val : pArr->GetImpl()) {
					Brace::VarSetString(lvars, m_IteratorIndex, val);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteObjectArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pArr = static_cast<ObjectArray*>(ptr);
				for (auto& val : pArr->GetImpl()) {
					Brace::VarSetObject(lvars, m_IteratorIndex, val);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntBoolHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, bool>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
					Brace::VarSetBool(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntIntHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, int64_t>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
					Brace::VarSetInt64(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntFloatHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, double>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
					Brace::VarSetInt64(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntStrHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<int64_t, std::string>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
					Brace::VarSetString(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntObjHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<IntObjHashtable*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetInt64(lvars, m_IteratorIndex, val.first);
					Brace::VarSetObject(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrBoolHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, bool>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetString(lvars, m_IteratorIndex, val.first);
					Brace::VarSetBool(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrIntHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, int64_t>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetString(lvars, m_IteratorIndex, val.first);
					Brace::VarSetInt64(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrFloatHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, double>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetString(lvars, m_IteratorIndex, val.first);
					Brace::VarSetDouble(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrStrHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<HashtableObjT<std::string, std::string>*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetString(lvars, m_IteratorIndex, val.first);
					Brace::VarSetString(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrObjHashtable(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pHashtable = static_cast<StrObjHashtable*>(ptr);
				for (auto& val : pHashtable->GetImpl()) {
					Brace::VarSetString(lvars, m_IteratorIndex, val.first);
					Brace::VarSetObject(lvars, m_IteratorIndexV, val.second);
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
				}
			}
		}
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	int m_IteratorIndex;
	int m_IteratorIndexV;
	Brace::BraceApiExecutor m_List;
	Brace::OperandRuntimeInfo m_ListInfo;
	std::vector<Brace::BraceApiExecutor> m_Statements;
	std::vector<int> m_ObjVars;
};
class ArrayHashtableLinqProvider final : public AbstractLinqApiProvider
{
	friend class LinqExp;
	enum OperationType
	{
		OPERATION_UNKNOWN = -1,
		OPERATION_ORDERBY = 0,
		OPERATION_ORDERBYDESC,
		OPERATION_TOP,
		OPERATION_WHERE,
		OPERATION_NUM
	};
	struct CmpVal
	{
		double NumVal;
		std::string StrVal;
	};
protected:
	virtual bool LoadLinqCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, Brace::OperandLoadtimeInfo&& listInfo, Brace::BraceApiExecutor&& list, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<int>&& objVars, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		if (member == "orderby") {
			m_Operation = OPERATION_ORDERBY;
		}
		else if (member == "orderbydesc") {
			m_Operation = OPERATION_ORDERBYDESC;
		}
		else if (member == "top") {
			m_Operation = OPERATION_TOP;
		}
		else if (member == "where") {
			m_Operation = OPERATION_WHERE;
		}

		m_IteratorIndex = iteratorIndex;
		m_ListInfo = listInfo;
		std::swap(m_List, list);
		for (auto& argInfo : argInfos) {
			m_ArgInfos.push_back(argInfo);
		}
		std::swap(m_Args, args);
		resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
		resultInfo.ObjectTypeId = listInfo.ObjectTypeId;
		resultInfo.Name = GenTempVarName();
		resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
		m_ResultInfo = resultInfo;
		std::swap(m_ObjVars, objVars);
		executor.attach(this, &ArrayHashtableLinqProvider::ExecuteObjectArray);
		return true;
	}
private:
	ArrayHashtableLinqProvider(Brace::BraceScript& interpreter) :AbstractLinqApiProvider(interpreter), m_Operation(OPERATION_UNKNOWN), m_IteratorIndex(INVALID_INDEX), m_List(), m_ListInfo(), m_ArgInfos(), m_Args(), m_ResultInfo(), m_ObjVars()
	{}
private:
	int ExecuteObjectArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
		if (nullptr != obj) {
			auto* ptr = obj.get();
			if (nullptr != ptr) {
				auto* pNewArr = new ObjectArray();
				std::shared_ptr<Brace::IBraceObject> newArr(pNewArr);
				Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, newArr);
				auto* pArr = static_cast<ObjectArray*>(ptr);
				switch (m_Operation) {
				case OPERATION_ORDERBY:
				case OPERATION_ORDERBYDESC:
                    			ExecuteOrderBy(gvars, lvars, pArr, pNewArr, m_Operation == OPERATION_ORDERBY);
					break;
				case OPERATION_TOP:
					ExecuteTop(gvars, lvars, pArr, pNewArr);
					break;
				case OPERATION_WHERE:
					ExecuteWhere(gvars, lvars, pArr, pNewArr);
					break;
				}
			}
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	void ExecuteOrderBy(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const ObjectArray* pArr, ObjectArray* pNewArr, bool asc)const
	{
		for (auto& val : pArr->GetImpl()) {
			pNewArr->GetImpl().push_back(val);
		}
		std::vector<CmpVal> sortVals{};
		std::sort(pNewArr->GetImpl().begin(), pNewArr->GetImpl().end(), [&](auto& e1, auto& e2) {
			Brace::VarSetObject(lvars, m_IteratorIndex, e1);
			for (auto& arg : m_Args) {
				if (!arg.isNull())
					arg(gvars, lvars);
			}
			sortVals.clear();
			for (auto& argInfo : m_ArgInfos) {
				CmpVal cv;
				if (Brace::IsStringType(argInfo.Type))
					cv.StrVal = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
				else
					cv.NumVal = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
				sortVals.push_back(cv);
			}
			Brace::VarSetObject(lvars, m_IteratorIndex, e2);
			for (auto& arg : m_Args) {
				if (!arg.isNull())
					arg(gvars, lvars);
			}
			int ix = 0;
			for (auto& argInfo : m_ArgInfos) {
				const CmpVal& cv = sortVals[ix++];
				if (Brace::IsStringType(argInfo.Type)) {
					const std::string& v2 = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
					if (asc) {
						if (cv.StrVal < v2)
							return true;
						else if (cv.StrVal > v2)
							return false;
					}
					else {
						if (cv.StrVal > v2)
							return true;
						else if (cv.StrVal < v2)
							return false;
					}
				}
				else {
					double v2 = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
					if (asc) {
						if (cv.NumVal < v2)
							return true;
						else if (cv.NumVal > v2)
							return false;
					}
					else {
						if (cv.NumVal > v2)
							return true;
						else if (cv.NumVal < v2)
							return false;
					}
				}
			}
			return false;
		});
		FreeObjVars(lvars, m_ObjVars);
	}
	void ExecuteTop(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const ObjectArray* pArr, ObjectArray* pNewArr)const
	{
		for (auto& arg : m_Args) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		auto& argInfo = m_ArgInfos[0];
		int64_t n = Brace::VarGetI64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
		int64_t ct = 0;
		for (auto& val : pArr->GetImpl()) {
			pNewArr->GetImpl().push_back(val);
			++ct;
			if (ct >= n)
				break;
		}
		FreeObjVars(lvars, m_ObjVars);
	}
	void ExecuteWhere(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const ObjectArray* pArr, ObjectArray* pNewArr)const
	{
		for (auto& val : pArr->GetImpl()) {
			Brace::VarSetObject(lvars, m_IteratorIndex, val);
			for (auto& arg : m_Args) {
				if (!arg.isNull())
					arg(gvars, lvars);
			}
			auto& argInfo = m_ArgInfos[0];
			bool v = Brace::VarGetBoolean((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
			if (v)
				pNewArr->GetImpl().push_back(val);
		}
		FreeObjVars(lvars, m_ObjVars);
	}
private:
	OperationType m_Operation;
	int m_IteratorIndex;
	Brace::BraceApiExecutor m_List;
	Brace::OperandRuntimeInfo m_ListInfo;
	std::vector<Brace::OperandRuntimeInfo> m_ArgInfos;
	std::vector<Brace::BraceApiExecutor> m_Args;
	Brace::OperandRuntimeInfo m_ResultInfo;
	std::vector<int> m_ObjVars;
};
class ArrayHashtableSelectProvider final : public AbstractSelectApiProvider
{
	friend class SelectExp;
	struct CmpVal
	{
		bool IsStr;
		double NumVal;
		std::string StrVal;
		double NewNumVal;
		std::string NewStrVal;
	};
protected:
	virtual bool LoadSelect(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<int>&& statMethods, std::vector<int>&& objVars) override
	{
		m_SelectIteratorIndex = iteratorIndex;
		for (auto& argInfo : argInfos) {
			m_SelectArgInfos.push_back(argInfo);
		}
		std::swap(m_SelectArgs, args);
		std::swap(m_SelectStats, statMethods);
		std::swap(m_SelectObjVars, objVars);
		return true;
	}
	virtual bool LoadTop(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, std::vector<int>&& objVars) override
	{
		m_TopArgInfo = argInfo;
		std::swap(m_TopArg, arg);
		std::swap(m_TopObjVars, objVars);
		return true;
	}
	virtual bool LoadFromList(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg) override
	{
		m_ListInfo = argInfo;
		std::swap(m_List, arg);
		return true;
	}
	virtual bool LoadFromType(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const std::string& type) override
	{
		m_Type = type;
		return true;
	}
	virtual bool LoadWhere(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, std::vector<int>&& objVars) override
	{
		m_WhereIteratorIndex = iteratorIndex;
		m_WhereArgInfo = argInfo;
		std::swap(m_WhereArg, arg);
		std::swap(m_WhereObjVars, objVars);
		return true;
	}
	virtual bool LoadOrderBy(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<bool>&& ascOrDescs, std::vector<int>&& objVars) override
	{
		m_OrderIteratorIndex = iteratorIndex;
		for (auto& argInfo : argInfos) {
			m_OrderArgInfos.push_back(argInfo);
		}
		std::swap(m_OrderArgs, args);
		std::swap(m_OrderAscs, ascOrDescs);
		std::swap(m_OrderObjVars, objVars);
		return true;
	}
	virtual bool LoadGroupBy(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, int iteratorIndex, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, std::vector<int>&& objVars) override
	{
		m_GroupIteratorIndex = iteratorIndex;
		for (auto& argInfo : argInfos) {
			m_GroupArgInfos.push_back(argInfo);
		}
		std::swap(m_GroupArgs, args);
		std::swap(m_GroupObjVars, objVars);
		return true;
	}
	virtual bool LoadHaving(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg) override
	{
		m_HavingArgInfo = argInfo;
		std::swap(m_HavingArg, arg);
		return true;
	}
	virtual bool LoadStatements(const Brace::FuncInfo& func, const DslData::FunctionData& data, std::vector<Brace::BraceApiExecutor>&& statements, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		std::swap(m_Statements, statements);
		executor.attach(this, &ArrayHashtableSelectProvider::ExecuteObjectArray);
		return true;
	}
	virtual void LoadResultIterator(std::vector<Brace::OperandLoadtimeInfo>&& iterators, std::vector<int>&& objVars) override
	{
		for (auto& itInfo : iterators) {
			m_Iterators.push_back(itInfo);
			m_IteratorAssigns.push_back(Brace::GetVarAssignPtr(itInfo.Type, false, itInfo.Type, false));
		}
		std::swap(m_ObjVars, objVars);
	}
private:
	ArrayHashtableSelectProvider(Brace::BraceScript& interpreter) :AbstractSelectApiProvider(interpreter)
		, m_Type()
		, m_List()
		, m_ListInfo()
		, m_SelectIteratorIndex(INVALID_INDEX)
		, m_SelectArgInfos()
		, m_SelectArgs()
		, m_SelectStats()
		, m_SelectObjVars()
		, m_TopArgInfo()
		, m_TopArg()
		, m_TopObjVars()
		, m_WhereIteratorIndex(INVALID_INDEX)
		, m_WhereArgInfo()
		, m_WhereArg()
		, m_WhereObjVars()
		, m_OrderIteratorIndex(INVALID_INDEX)
		, m_OrderArgInfos()
		, m_OrderArgs()
		, m_OrderAscs()
		, m_OrderObjVars()
		, m_GroupIteratorIndex(INVALID_INDEX)
		, m_GroupArgInfos()
		, m_GroupArgs()
		, m_GroupObjVars()
		, m_Iterators()
		, m_IteratorAssigns()
		, m_HavingArgInfo()
		, m_HavingArg()
		, m_Statements()
		, m_ObjVars()
	{}
private:
	int ExecuteObjectArray(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		ObjectArray* pArr = nullptr;
		std::shared_ptr<Brace::IBraceObject> arrFromType;
		if (!m_Type.empty()) {
			pArr = BuildObjectArray(m_Type);
			arrFromType.reset(pArr);
		}
		else {
			auto& obj = Brace::VarGetObject((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
			if (nullptr != obj) {
				auto* ptr = obj.get();
				if (nullptr != ptr) {
					pArr = static_cast<ObjectArray*>(ptr);
				}
			}
		}
		if (nullptr == pArr)
			return Brace::BRACE_FLOW_CONTROL_NORMAL;
		auto* pNewArr = new ObjectArray();
		std::shared_ptr<Brace::IBraceObject> newArr(pNewArr);
		// where
		ExecuteWhere(gvars, lvars, pArr, pNewArr);
		// orderby
		ExecuteOrderBy(gvars, lvars, pNewArr);
		// groupby
		if (m_GroupIteratorIndex != INVALID_INDEX) {
			std::vector<ObjectArray> groups{};
			ExecuteGroupBy(gvars, lvars, pNewArr, groups);
			return ExecuteGroupSelect(gvars, lvars, groups);
		}
		else {
			return ExecuteSelect(gvars, lvars, pNewArr);
		}
	}
	ObjectArray* BuildObjectArray(const std::string& className)const
	{
		UClass* pClass = FindObject<UClass>(ANY_PACKAGE, UTF8_TO_TCHAR(className.c_str()));
		if (nullptr != pClass) {
			TArray<UObject*> results;
			GetObjectsOfClass(pClass, results);
			auto* p = new ObjectArray();
			for (auto* pObj : results) {
				std::shared_ptr<Brace::IBraceObject> ptr(new UObjectBraceObject(pObj));
				p->GetImpl().push_back(ptr);
			}
			return p;
		}
		return nullptr;
	}
	void ExecuteWhere(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const ObjectArray* pArr, ObjectArray* pNewArr)const
	{
		if (m_WhereIteratorIndex != INVALID_INDEX) {
			for (auto& val : pArr->GetImpl()) {
				Brace::VarSetObject(lvars, m_WhereIteratorIndex, val);
				if (!m_WhereArg.isNull())
					m_WhereArg(gvars, lvars);
				bool v = Brace::VarGetBoolean((m_WhereArgInfo.IsGlobal ? gvars : lvars), m_WhereArgInfo.Type, m_WhereArgInfo.VarIndex);
				if (v)
					pNewArr->GetImpl().push_back(val);
			}
			FreeObjVars(lvars, m_WhereObjVars);
		}
		else {
			for (auto& val : pArr->GetImpl()) {
				pNewArr->GetImpl().push_back(val);
			}
		}
	}
	void ExecuteOrderBy(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, ObjectArray* pNewArr)const
	{
		if (m_OrderIteratorIndex != INVALID_INDEX) {
			std::vector<CmpVal> sortVals{};
			std::sort(pNewArr->GetImpl().begin(), pNewArr->GetImpl().end(), [&](auto& e1, auto& e2) {
				Brace::VarSetObject(lvars, m_OrderIteratorIndex, e1);
				for (auto& arg : m_OrderArgs) {
					if (!arg.isNull())
						arg(gvars, lvars);
				}
				sortVals.clear();
				for (auto& argInfo : m_OrderArgInfos) {
					CmpVal cv;
					if (Brace::IsStringType(argInfo.Type))
						cv.StrVal = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
					else
						cv.NumVal = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
					sortVals.push_back(cv);
				}
				Brace::VarSetObject(lvars, m_OrderIteratorIndex, e2);
				for (auto& arg : m_OrderArgs) {
					if (!arg.isNull())
						arg(gvars, lvars);
				}
				int ix = 0;
				for (auto& argInfo : m_OrderArgInfos) {
					bool asc = m_OrderAscs[ix];
					const CmpVal& cv = sortVals[ix++];
					if (Brace::IsStringType(argInfo.Type)) {
						const std::string& v2 = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
						if (asc) {
							if (cv.StrVal < v2)
								return true;
							else if (cv.StrVal > v2)
								return false;
						}
						else {
							if (cv.StrVal > v2)
								return true;
							else if (cv.StrVal < v2)
								return false;
						}
					}
					else {
						double v2 = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
						if (asc) {
							if (cv.NumVal < v2)
								return true;
							else if (cv.NumVal > v2)
								return false;
						}
						else {
							if (cv.NumVal > v2)
								return true;
							else if (cv.NumVal < v2)
								return false;
						}
					}
				}
				return false;
			});
			FreeObjVars(lvars, m_OrderObjVars);
		}
	}
	void ExecuteGroupBy(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, ObjectArray* pNewArr, std::vector<ObjectArray>& groups)const
	{
		std::vector<CmpVal> groupVals{};
		auto& arr = pNewArr->GetImpl();
		for (auto& optr : arr) {
			Brace::VarSetObject(lvars, m_GroupIteratorIndex, optr);
			for (auto& arg : m_GroupArgs) {
				if (!arg.isNull())
					arg(gvars, lvars);
			}
			bool newGroup = false;
			if (groupVals.empty()) {
				newGroup = true;
				for (auto& argInfo : m_GroupArgInfos) {
					CmpVal cv;
					if (Brace::IsStringType(argInfo.Type))
						cv.StrVal = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
					else
						cv.NumVal = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
					groupVals.push_back(cv);
				}
			}
			else {
				int ix = 0;
				for (auto& argInfo : m_GroupArgInfos) {
					CmpVal& cv = groupVals[ix++];
					if (Brace::IsStringType(argInfo.Type)) {
						const std::string& v2 = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
						if (cv.StrVal != v2) {
							newGroup = true;
							cv.StrVal = v2;
						}
					}
					else {
						double v2 = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
						if (cv.NumVal < v2 - DBL_EPSILON || cv.NumVal > v2 + DBL_EPSILON) {
							newGroup = true;
							cv.NumVal = v2;
						}
					}
				}
			}
			if (newGroup) {
				ObjectArray ng;
				ng.GetImpl().push_back(optr);
				groups.push_back(std::move(ng));
			}
			else {
				groups.back().GetImpl().push_back(optr);
			}
		}
		FreeObjVars(lvars, m_GroupObjVars);
	}
	int ExecuteGroupSelect(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<ObjectArray>& groups)const
	{
		// top
		int64_t topn = -1;
		if (m_TopArgInfo.VarIndex != INVALID_INDEX) {
			if (!m_TopArg.isNull())
				m_TopArg(gvars, lvars);
			topn = Brace::VarGetI64((m_TopArgInfo.IsGlobal ? gvars : lvars), m_TopArgInfo.Type, m_TopArgInfo.VarIndex);
			FreeObjVars(lvars, m_TopObjVars);
		}
		// select and having
		if (m_SelectIteratorIndex != INVALID_INDEX) {
			if (m_Statements.size() > 0) {
				std::vector<CmpVal> selectVals{};
				int64_t resultCount = 0;
				for (auto& group : groups) {
					if (!ExecuteGroupStatAndHaving(gvars, lvars, group, selectVals)) {
						continue;
					}
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
					FreeObjVars(lvars, m_SelectObjVars);
					FreeObjVars(lvars, m_ObjVars);
					++resultCount;
					if (topn > 0 && resultCount >= topn)
						break;
				}
			}
			else {
				//same as csvecho
				std::vector<CmpVal> selectVals{};
				std::stringstream ss;
				int64_t resultCount = 0;
				for (auto& group : groups) {
					if (!ExecuteGroupStatAndHaving(gvars, lvars, group, selectVals)) {
						continue;
					}
					ss.str(std::string());
					bool first = true;
					for (auto& cv : selectVals) {
						bool needQuote = false;
						if (cv.IsStr && cv.StrVal.length() > 0 && cv.StrVal[0] != '"' && cv.StrVal[0] != '\'') {
							for (auto c : cv.StrVal) {
								if (c == ' ' || c == '\t') {
									needQuote = true;
									break;
								}
							}
						}
						if (first) {
							first = false;
						}
						else {
							ss << ", ";
						}
						if (needQuote)
							ss << '"' << cv.StrVal << '"';
						else if (cv.IsStr)
							ss << cv.StrVal;
						else
							ss << std::fixed << std::setprecision(3) << cv.NumVal;
					}
					LogInfo(ss.str());
					if (GEngine)
						GEngine->AddOnScreenDebugMessage(-1, 12.0f, FColor::Yellow, UTF8_TO_TCHAR(ss.str().c_str()));
					FreeObjVars(lvars, m_SelectObjVars);
					if (m_HavingArgInfo.VarIndex != INVALID_INDEX) {
						FreeObjVars(lvars, m_ObjVars);
					}
					++resultCount;
					if (topn > 0 && resultCount >= topn)
						break;
				}
			}
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	bool ExecuteGroupStatAndHaving(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const ObjectArray& group, std::vector<CmpVal>& selectVals)const
	{
		selectVals.clear();
		bool first = true;
		for (auto& optr : group.GetImpl()) {
			Brace::VarSetObject(lvars, m_SelectIteratorIndex, optr);
			for (auto& arg : m_SelectArgs) {
				if (!arg.isNull())
					arg(gvars, lvars);
			}
			bool update = false;
			int six = 0;
			for (auto& argInfo : m_SelectArgInfos) {
				int stat = m_SelectStats[six];
				bool isStr = false;
				std::string str{};
				double val{};
				if (Brace::IsObjectType(argInfo.Type)) {
					auto& ptr = Brace::VarGetObject((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
					switch (argInfo.ObjectTypeId) {
					case CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT: {
						auto* p = static_cast<UObjectBraceObject*>(ptr.get());
						if (p && p->GetImpl()) {
							UObject* pObj = p->GetImpl();
							str = TCHAR_TO_UTF8(*pObj->GetFullName());
						}
					}break;
					}
					isStr = true;
				}
				else if (Brace::IsStringType(argInfo.Type)) {
					str = Brace::VarGetString((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
					isStr = true;
				}
				else {
					val = Brace::VarGetF64((argInfo.IsGlobal ? gvars : lvars), argInfo.Type, argInfo.VarIndex);
				}
				if (first) {
					CmpVal cv;
					cv.IsStr = isStr;
					if (isStr) {
						switch (stat) {
						case STAT_METHOD_NONE:
							cv.StrVal = str;
							break;
						case STAT_METHOD_MAX:
							cv.StrVal = str;
							break;
						case STAT_METHOD_MIN:
							cv.StrVal = str;
							break;
						case STAT_METHOD_AVG:
							break;
						case STAT_METHOD_SUM:
							break;
						case STAT_METHOD_COUNT:
							cv.IsStr = false;
							cv.NumVal = 1;
							break;
						}
					}
					else {
						switch (stat) {
						case STAT_METHOD_NONE:
							cv.NumVal = val;
							break;
						case STAT_METHOD_MAX:
							cv.NumVal = val;
							break;
						case STAT_METHOD_MIN:
							cv.NumVal = val;
							break;
						case STAT_METHOD_AVG:
							cv.NumVal = val;
							break;
						case STAT_METHOD_SUM:
							cv.NumVal = val;
							break;
						case STAT_METHOD_COUNT:
							cv.NumVal = 1;
							break;
						}
					}
					selectVals.push_back(std::move(cv));
				}
				else {
					CmpVal& cv = selectVals[six];
					if (isStr) {
						switch (stat) {
						case STAT_METHOD_NONE:
							cv.NewStrVal = str;
							break;
						case STAT_METHOD_MAX:
							if (cv.StrVal < str) {
								cv.StrVal = str;
								update = true;
							}
							break;
						case STAT_METHOD_MIN:
							if (cv.StrVal > str) {
								cv.StrVal = str;
								update = true;
							}
							break;
						case STAT_METHOD_AVG:
							break;
						case STAT_METHOD_SUM:
							break;
						case STAT_METHOD_COUNT:
							cv.NumVal = cv.NumVal + 1;
							break;
						}
					}
					else {
						switch (stat) {
						case STAT_METHOD_NONE:
							cv.NewNumVal = val;
							break;
						case STAT_METHOD_MAX:
							if (cv.NumVal < val) {
								cv.NumVal = val;
								update = true;
							}
							break;
						case STAT_METHOD_MIN:
							if (cv.NumVal > val) {
								cv.NumVal = val;
								update = true;
							}
							break;
						case STAT_METHOD_AVG:
							cv.NumVal = cv.NumVal + val;
							break;
						case STAT_METHOD_SUM:
							cv.NumVal = cv.NumVal + val;
							break;
						case STAT_METHOD_COUNT:
							cv.NumVal = cv.NumVal + 1;
							break;
						}
					}
				}
				++six;
			}
			if (update) {
				six = 0;
				for (auto& cv : selectVals) {
					int stat = m_SelectStats[six++];
					if (stat == STAT_METHOD_NONE) {
						if (cv.IsStr)
							cv.StrVal = cv.NewStrVal;
						else
							cv.NumVal = cv.NewNumVal;
					}
				}
			}
			first = false;
		}
		int vix = 0;
		for (auto& cv : selectVals) {
			int stat = m_SelectStats[vix];
			auto& itInfo = m_Iterators[vix++];
			if (stat == STAT_METHOD_AVG) {
				cv.NumVal /= group.GetImpl().size();
			}
			if (Brace::IsStringType(itInfo.Type))
				Brace::VarSetString(lvars, itInfo.VarIndex, cv.StrVal);
			else
				Brace::VarSetF64(lvars, itInfo.Type, itInfo.VarIndex, cv.NumVal);
		}
		if (m_HavingArgInfo.VarIndex != INVALID_INDEX) {
			if (!m_HavingArg.isNull())
				m_HavingArg(gvars, lvars);
			bool v = Brace::VarGetBoolean((m_HavingArgInfo.IsGlobal ? gvars : lvars), m_HavingArgInfo.Type, m_HavingArgInfo.VarIndex);
			if (!v) {
				FreeObjVars(lvars, m_SelectObjVars);
				return false;
			}
		}
		return true;
	}
	int ExecuteSelect(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, ObjectArray* pNewArr)const
	{
		// top
		if (m_TopArgInfo.VarIndex != INVALID_INDEX) {
			if (!m_TopArg.isNull())
				m_TopArg(gvars, lvars);
			int64_t n = Brace::VarGetI64((m_TopArgInfo.IsGlobal ? gvars : lvars), m_TopArgInfo.Type, m_TopArgInfo.VarIndex);
			auto& arr = pNewArr->GetImpl();
			if (static_cast<int64_t>(arr.size()) > n) {
				auto it = arr.begin();
				std::advance(it, n);
				arr.erase(it, arr.end());
			}
			FreeObjVars(lvars, m_TopObjVars);
		}
		// select
		if (m_SelectIteratorIndex != INVALID_INDEX) {
			if (m_Statements.size() > 0) {
				auto& arr = pNewArr->GetImpl();
				for (auto& optr : arr) {
					Brace::VarSetObject(lvars, m_SelectIteratorIndex, optr);
					for (auto& arg : m_SelectArgs) {
						if (!arg.isNull())
							arg(gvars, lvars);
					}
					int itIndex = 0;
					for (auto& argInfo : m_SelectArgInfos) {
						int vix = m_Iterators[itIndex].VarIndex;
						auto* fptr = m_IteratorAssigns[itIndex++];
						(*fptr)(lvars, vix, lvars, argInfo.VarIndex);
					}
					for (auto& statement : m_Statements) {
						int v = statement(gvars, lvars);
						if (IsForceQuit()) {
							FreeObjVars(lvars, m_SelectObjVars);
							FreeObjVars(lvars, m_ObjVars);
							return v;
						}
						if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
							break;
						}
						else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
							FreeObjVars(lvars, m_SelectObjVars);
							FreeObjVars(lvars, m_ObjVars);
							if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
								return Brace::BRACE_FLOW_CONTROL_NORMAL;
							return v;
						}
					}
					FreeObjVars(lvars, m_SelectObjVars);
					FreeObjVars(lvars, m_ObjVars);
				}
			}
			else {
				//same as csvecho
				auto& arr = pNewArr->GetImpl();
				for (auto& optr : arr) {
					Brace::VarSetObject(lvars, m_SelectIteratorIndex, optr);
					for (auto& arg : m_SelectArgs) {
						if (!arg.isNull())
							arg(gvars, lvars);
					}
					std::stringstream ss;
					bool first = true;
					for (auto& argInfo : m_SelectArgInfos) {
						std::string str;
						if (Brace::IsObjectType(argInfo.Type)) {
							auto& ptr = Brace::VarGetObject((argInfo.IsGlobal ? gvars : lvars), argInfo.VarIndex);
							switch (argInfo.ObjectTypeId) {
							case CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT: {
								auto* p = static_cast<UObjectBraceObject*>(ptr.get());
								if (p && p->GetImpl()) {
									UObject* pObj = p->GetImpl();
									str = TCHAR_TO_UTF8(*pObj->GetFullName());
								}
							}break;
							}
						}
						else if (Brace::IsFloatType(argInfo.Type)) {
							double dv;
							if (argInfo.IsGlobal)
								dv = Brace::VarGetF64(gvars, argInfo.Type, argInfo.VarIndex);
							else
								dv = Brace::VarGetF64(lvars, argInfo.Type, argInfo.VarIndex);
							std::stringstream tss;
							tss << std::fixed << std::setprecision(3) << dv;
							str = tss.str();
						}
						else {
							if (argInfo.IsGlobal)
								str = Brace::VarGetStr(gvars, argInfo.Type, argInfo.VarIndex);
							else
								str = Brace::VarGetStr(lvars, argInfo.Type, argInfo.VarIndex);
						}
						bool needQuote = false;
						if (str.length() > 0 && str[0] != '"' && str[0] != '\'') {
							for (auto c : str) {
								if (c == ' ' || c == '\t') {
									needQuote = true;
									break;
								}
							}
						}
						if (first) {
							first = false;
						}
						else {
							ss << ", ";
						}
						if (needQuote)
							ss << '"' << str << '"';
						else
							ss << str;
					}
					LogInfo(ss.str());
					if (GEngine)
						GEngine->AddOnScreenDebugMessage(-1, 12.0f, FColor::Yellow, UTF8_TO_TCHAR(ss.str().c_str()));
					FreeObjVars(lvars, m_SelectObjVars);
				}
			}
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	std::string m_Type;
	Brace::BraceApiExecutor m_List;
	Brace::OperandRuntimeInfo m_ListInfo;

	int m_SelectIteratorIndex;
	std::vector<Brace::OperandRuntimeInfo> m_SelectArgInfos;
	std::vector<Brace::BraceApiExecutor> m_SelectArgs;
	std::vector<int> m_SelectStats;
	std::vector<int> m_SelectObjVars;

	Brace::OperandRuntimeInfo m_TopArgInfo;
	Brace::BraceApiExecutor m_TopArg;
	std::vector<int> m_TopObjVars;

	int m_WhereIteratorIndex;
	Brace::OperandRuntimeInfo m_WhereArgInfo;
	Brace::BraceApiExecutor m_WhereArg;
	std::vector<int> m_WhereObjVars;

	int m_OrderIteratorIndex;
	std::vector<Brace::OperandRuntimeInfo> m_OrderArgInfos;
	std::vector<Brace::BraceApiExecutor> m_OrderArgs;
	std::vector<bool> m_OrderAscs;
	std::vector<int> m_OrderObjVars;

	int m_GroupIteratorIndex;
	std::vector<Brace::OperandRuntimeInfo> m_GroupArgInfos;
	std::vector<Brace::BraceApiExecutor> m_GroupArgs;
	std::vector<int> m_GroupObjVars;

	std::vector<Brace::OperandRuntimeInfo> m_Iterators;
	std::vector<Brace::VarAssignPtr> m_IteratorAssigns;

	Brace::OperandRuntimeInfo m_HavingArgInfo;
	Brace::BraceApiExecutor m_HavingArg;

	std::vector<Brace::BraceApiExecutor> m_Statements;
	std::vector<int> m_ObjVars;
};

class StringMemberCallProvider final : public AbstractMemberCallApiProvider
{
	friend class MemberCallExp;
protected:
	virtual bool LoadMemberCall(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, std::vector<Brace::OperandLoadtimeInfo>&& argInfos, std::vector<Brace::BraceApiExecutor>&& args, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		std::swap(m_Obj, obj);
		m_ObjInfo = objInfo;
		std::swap(m_Member, member);
		std::swap(m_Args, args);
		for (auto& argInfo : argInfos) {
			m_ArgInfos.push_back(argInfo);
		}
		auto& m = m_Member;
		if (m == "ReplaceAll") {
			if (argInfos.size() == 2) {
				auto& argInfo = argInfos[0];
				auto& argInfo2 = argInfos[1];
				if (Brace::IsStringType(argInfo.Type) && Brace::IsStringType(argInfo2.Type)) {
					resultInfo = objInfo;
					executor.attach(this, &StringMemberCallProvider::ExecuteReplaceAll);
					return true;
				}
			}
			std::stringstream ss;
			ss << "expected String.ReplaceAll(string, string) ! line: " << data.GetLine();
			LogError(ss.str());
			return false;
		}
		return false;
	}
private:
	int ExecuteReplaceAll(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_Obj.isNull())
			m_Obj(gvars, lvars);
		for (auto& _arg : m_Args) {
			if (!_arg.isNull())
				_arg(gvars, lvars);
		}
		auto& strInfo = m_ObjInfo;
		auto& strInfo1 = m_ArgInfos[0];
		auto& strInfo2 = m_ArgInfos[1];
		std::string& str = Brace::VarGetString((strInfo.IsGlobal ? gvars : lvars), strInfo.VarIndex);
		const std::string& what = Brace::VarGetString((strInfo1.IsGlobal ? gvars : lvars), strInfo1.VarIndex);
		const std::string& with = Brace::VarGetString((strInfo2.IsGlobal ? gvars : lvars), strInfo2.VarIndex);
		for (std::string::size_type pos{}; str.npos != (pos = str.find(what.data(), pos, what.length())); pos += with.length()) {
			str.replace(pos, what.length(), with.data(), with.length());
		}
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	StringMemberCallProvider(Brace::BraceScript& interpreter) :AbstractMemberCallApiProvider(interpreter), m_Obj(), m_ObjInfo(), m_Member(), m_Args(), m_ArgInfos(), m_ResultInfo()
	{
	}
private:
	Brace::BraceApiExecutor m_Obj;
	Brace::OperandRuntimeInfo m_ObjInfo;
	std::string m_Member;
	std::vector<Brace::BraceApiExecutor> m_Args;
	std::vector<Brace::OperandRuntimeInfo> m_ArgInfos;
	Brace::OperandRuntimeInfo m_ResultInfo;
};
class StringMemberSetProvider final : public AbstractMemberSetApiProvider
{
	friend class MemberSetExp;
protected:
	virtual bool LoadMemberSet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo&& argInfo, Brace::BraceApiExecutor&& arg, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	StringMemberSetProvider(Brace::BraceScript& interpreter) :AbstractMemberSetApiProvider(interpreter)
	{}
};
class StringMemberGetProvider final : public AbstractMemberGetApiProvider
{
	friend class MemberGetExp;
protected:
	virtual bool LoadMemberGet(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, Brace::OperandLoadtimeInfo&& objInfo, Brace::BraceApiExecutor&& obj, std::string&& member, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)override
	{
		return false;
	}
private:
	StringMemberGetProvider(Brace::BraceScript& interpreter) :AbstractMemberGetApiProvider(interpreter)
	{}
};
class StringCollectionCallProvider final : public AbstractCollectionCallApiProvider
{
	friend class CollectionCallExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) const override
	{
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo) const override
	{
	}
private:
	StringCollectionCallProvider(Brace::BraceScript& interpreter) :AbstractCollectionCallApiProvider(interpreter)
	{}
};
class StringCollectionSetProvider final : public AbstractCollectionSetApiProvider
{
	friend class CollectionSetExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, const Brace::OperandLoadtimeInfo& val, Brace::OperandLoadtimeInfo& resultInfo) const override
	{
		if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
			std::stringstream ss;
			ss << "String's index must be integer ! line: " << data.GetLine();
			LogError(ss.str());
			return false;
		}
		if (!CanAssign(Brace::BRACE_DATA_TYPE_UINT8, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ, val.Type, val.ObjectTypeId)) {
			std::stringstream ss;
			ss << "String element's type and val type dismatch ! line: " << data.GetLine();
			LogError(ss.str());
			return false;
		}
		resultInfo = val;
		return true;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& val, const Brace::OperandRuntimeInfo& resultInfo) const override
    {
		std::string& str = Brace::VarGetString((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
        int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
		uint64_t v = Brace::VarGetU64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
		if (vix >= 0 && vix < static_cast<int64_t>(str.length())) {
			str.replace(static_cast<size_t>(vix), 1, 1, static_cast<char>(static_cast<uint8_t>(v)));
		}
	}
private:
	StringCollectionSetProvider(Brace::BraceScript& interpreter) :AbstractCollectionSetApiProvider(interpreter)
	{}
};
class StringCollectionGetProvider final : public AbstractCollectionGetApiProvider
{
	friend class CollectionGetExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& arr, const Brace::OperandLoadtimeInfo& ix, Brace::OperandLoadtimeInfo& resultInfo) const override
	{
		if (!(ix.Type >= Brace::BRACE_DATA_TYPE_INT8 && ix.Type <= Brace::BRACE_DATA_TYPE_UINT64)) {
			std::stringstream ss;
			ss << "String's index must be integer ! line: " << data.GetLine();
			LogError(ss.str());
			return false;
		}
		resultInfo.Type = Brace::BRACE_DATA_TYPE_UINT8;
		resultInfo.ObjectTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		resultInfo.Name = GenTempVarName();
		resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
		return true;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const Brace::OperandRuntimeInfo& arr, const Brace::OperandRuntimeInfo& ix, const Brace::OperandRuntimeInfo& resultInfo) const override
	{
		const std::string& str = Brace::VarGetString((arr.IsGlobal ? gvars : lvars), arr.VarIndex);
		int64_t vix = Brace::VarGetI64((ix.IsGlobal ? gvars : lvars), ix.Type, ix.VarIndex);
		char v = 0;
		if (vix >= 0 && vix < static_cast<int64_t>(str.length())) {
			v = str[vix];
		}
		Brace::VarSetUInt8((resultInfo.IsGlobal ? gvars : lvars), resultInfo.VarIndex, static_cast<uint8_t>(v));
	}
private:
	StringCollectionGetProvider(Brace::BraceScript& interpreter) :AbstractCollectionGetApiProvider(interpreter)
	{}
};
class StringLoopListProvider final : public AbstractLoopListApiProvider
{
	friend class LoopListExp;
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::ISyntaxComponent& data, const BraceObjectInfo& braceObjInfo, const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor) override
	{
		return TypeInference(listInfo, executor);
	}
	virtual void StoreRuntimeInfo(Brace::OperandRuntimeInfo&& listInfo, Brace::BraceApiExecutor&& list, std::vector<Brace::BraceApiExecutor>&& statements, const std::vector<int>& objVars) override
	{
		std::swap(m_ListInfo, listInfo);
		std::swap(m_List, list);
		std::swap(m_Statements, statements);
		m_ObjVars = objVars;
	}
private:
	StringLoopListProvider(Brace::BraceScript& interpreter) :AbstractLoopListApiProvider(interpreter), m_IteratorIndex(INVALID_INDEX), m_List(), m_ListInfo(), m_Statements(), m_ObjVars()
	{}
private:
	bool TypeInference(const Brace::OperandLoadtimeInfo& listInfo, Brace::BraceApiExecutor& executor)
	{
		if (listInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
			m_IteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_UINT8, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ);
			executor.attach(this, &StringLoopListProvider::Execute);
			return true;
		}
		return false;
	}
	int Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		if (!m_List.isNull())
			m_List(gvars, lvars);
		auto& str = Brace::VarGetString((m_ListInfo.IsGlobal ? gvars : lvars), m_ListInfo.VarIndex);
        for (char val : str) {
            Brace::VarSetUInt8(lvars, m_IteratorIndex, static_cast<uint8_t>(val));
            for (auto& statement : m_Statements) {
                int v = statement(gvars, lvars);
                if (IsForceQuit()) {
                    FreeObjVars(lvars, m_ObjVars);
                    return v;
                }
                if (v == Brace::BRACE_FLOW_CONTROL_CONTINUE) {
                    break;
                }
                else if (v != Brace::BRACE_FLOW_CONTROL_NORMAL) {
                    FreeObjVars(lvars, m_ObjVars);
                    if (v == Brace::BRACE_FLOW_CONTROL_BREAK)
                        return Brace::BRACE_FLOW_CONTROL_NORMAL;
                    return v;
                }
            }
        }
		FreeObjVars(lvars, m_ObjVars);
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	int m_IteratorIndex;
	Brace::BraceApiExecutor m_List;
	Brace::OperandRuntimeInfo m_ListInfo;
	std::vector<Brace::BraceApiExecutor> m_Statements;
	std::vector<int> m_ObjVars;
};

class MemberCallExp final : public Brace::AbstractBraceApi
{
public:
	MemberCallExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		int num = data.GetParamNum();
		if (num < 2)
			return false;
		Brace::OperandLoadtimeInfo loadInfo;
		auto obj = LoadHelper(*data.GetParam(0), loadInfo);
		auto& objInfo = loadInfo;
		auto& m = data.GetParamId(1);
		auto member = m;
		std::vector<Brace::OperandLoadtimeInfo> argInfos;
		std::vector<Brace::BraceApiExecutor> args;
		Brace::OperandLoadtimeInfo firstArgInfo;
		for (int ix = 2; ix < num; ++ix) {
			auto* param = data.GetParam(ix);
			Brace::OperandLoadtimeInfo argLoadInfo;
			auto p = LoadHelper(*param, argLoadInfo);
			args.push_back(std::move(p));
			argInfos.push_back(argLoadInfo);
			if (ix == 2)
				firstArgInfo = std::move(argLoadInfo);
		}
		if (objInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(loadInfo.ObjectTypeId);
			if (nullptr != pInfo) {
				AbstractMemberCallApiProvider* pProvider = nullptr;
				switch (pInfo->ObjectCategory) {
				case BRACE_OBJECT_CATEGORY_UOBJECT:
					pProvider = new UObjectMemberCallProvider(GetInterpreter());
					break;
				case BRACE_OBJECT_CATEGORY_STRUCT:
					pProvider = new StructMemberCallProvider(GetInterpreter());
					break;
				default:
					pProvider = new ArrayHashtableMemberCallProvider(GetInterpreter());
					break;
				}
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->LoadMemberCall(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), std::move(argInfos), std::move(args), resultInfo, executor);
				}
			}			
		}
		else if (objInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
			if (nullptr != pInfo) {
				AbstractMemberCallApiProvider* pProvider = new StringMemberCallProvider(GetInterpreter());
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->LoadMemberCall(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), std::move(argInfos), std::move(args), resultInfo, executor);
				}
			}
		}
		std::stringstream ss;
		ss << "Unknown member " << m << " line: " << data.GetLine();
		LogError(ss.str());
		executor = nullptr;
		return false;
	}
private:
	std::unique_ptr<AbstractMemberCallApiProvider> m_ApiProvider;
};
class MemberSetExp final : public Brace::AbstractBraceApi
{
public:
	MemberSetExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		if (data.GetParamNum() != 3)
			return false;
		Brace::OperandLoadtimeInfo loadInfo;
		auto obj = LoadHelper(*data.GetParam(0), loadInfo);
		auto& objInfo = loadInfo;
		auto& m = data.GetParamId(1);
		auto member = m;
		auto* param = data.GetParam(2);
		Brace::OperandLoadtimeInfo argLoadInfo;
		auto p = LoadHelper(*param, argLoadInfo);
		if (objInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(loadInfo.ObjectTypeId);
			if (nullptr != pInfo) {
				AbstractMemberSetApiProvider* pProvider = nullptr;
				switch (pInfo->ObjectCategory) {
				case BRACE_OBJECT_CATEGORY_UOBJECT:
					pProvider = new UObjectMemberSetProvider(GetInterpreter());
					break;
				case BRACE_OBJECT_CATEGORY_STRUCT:
					pProvider = new StructMemberSetProvider(GetInterpreter());
					break;
				default:
					pProvider = new ArrayHashtableMemberSetProvider(GetInterpreter());
					break;
				}
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->LoadMemberSet(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), std::move(argLoadInfo), std::move(p), resultInfo, executor);
				}
			}
		}
		else if (objInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
			if (nullptr != pInfo) {
				AbstractMemberSetApiProvider* pProvider = new StringMemberSetProvider(GetInterpreter());
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->LoadMemberSet(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), std::move(argLoadInfo), std::move(p), resultInfo, executor);
				}
			}
		}
		executor = nullptr;
		return true;
	}
private:
	std::unique_ptr<AbstractMemberSetApiProvider> m_ApiProvider;
};
class MemberGetExp final : public Brace::AbstractBraceApi
{
public:
	MemberGetExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		if (data.GetParamNum() != 2)
			return false;
		Brace::OperandLoadtimeInfo loadInfo;
		auto obj = LoadHelper(*data.GetParam(0), loadInfo);
		auto& objInfo = loadInfo;
		auto& m = data.GetParamId(1);
		auto member = m;
		if (objInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(loadInfo.ObjectTypeId);
			if (nullptr != pInfo) {
				AbstractMemberGetApiProvider* pProvider = nullptr;
				switch (pInfo->ObjectCategory) {
				case BRACE_OBJECT_CATEGORY_UOBJECT:
					pProvider = new UObjectMemberGetProvider(GetInterpreter());
					break;
				case BRACE_OBJECT_CATEGORY_STRUCT:
					pProvider = new StructMemberGetProvider(GetInterpreter());
					break;
				default:
					pProvider = new ArrayHashtableMemberGetProvider(GetInterpreter());
					break;
				}
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->LoadMemberGet(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), resultInfo, executor);
				}
			}
		}
		else if (objInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
			if (nullptr != pInfo) {
				AbstractMemberGetApiProvider* pProvider = new StringMemberGetProvider(GetInterpreter());
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->LoadMemberGet(func, data, *pInfo, std::move(objInfo), std::move(obj), std::move(member), resultInfo, executor);
				}
			}
		}
		std::stringstream ss;
		ss << "Unknown member " << m << " line: " << data.GetLine();
		LogError(ss.str());
		return false;
	}
private:
	std::unique_ptr<AbstractMemberGetApiProvider> m_ApiProvider;
};
class CollectionCallExp final : public Brace::SimpleBraceApiBase
{
public:
	CollectionCallExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
	{
		/// how to interpret this, f = obj[m] and f(args) or obj[m](obj, args) ?
		if (argInfos.size() < 2)
			return false;
		auto& arr = argInfos[0];
		if (arr.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(arr.ObjectTypeId);
			if (nullptr != pInfo) {
				AbstractCollectionCallApiProvider* pProvider = nullptr;
				switch (pInfo->ObjectCategory) {
				case BRACE_OBJECT_CATEGORY_UOBJECT:
				case BRACE_OBJECT_CATEGORY_ACTOR:
				default:
					pProvider = new ArrayHashtableCollectionCallProvider(GetInterpreter());
					break;
				}
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->TypeInference(func, data, *pInfo, argInfos, resultInfo);
				}
			}
		}
		else if (arr.Type == Brace::BRACE_DATA_TYPE_STRING) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
			if (nullptr != pInfo) {
				AbstractCollectionCallApiProvider* pProvider = new StringCollectionCallProvider(GetInterpreter());
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->TypeInference(func, data, *pInfo, argInfos, resultInfo);
				}
			}
		}
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
	{
		/// how to interpret this, f = obj[m] and f(args) or obj[m](obj, args) ?
		m_ApiProvider->Execute(gvars, lvars, argInfos, resultInfo);
	}
private:
	std::unique_ptr<AbstractCollectionCallApiProvider> m_ApiProvider;
};
class CollectionSetExp final : public Brace::SimpleBraceApiBase
{
public:
	CollectionSetExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
	{
		if (argInfos.size() != 3)
			return false;
		auto& arr = argInfos[0];
		auto& ix = argInfos[1];
		auto& val = argInfos[2];
		if (arr.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(arr.ObjectTypeId);
			if (nullptr != pInfo) {
				AbstractCollectionSetApiProvider* pProvider = nullptr;
				switch (pInfo->ObjectCategory) {
				case BRACE_OBJECT_CATEGORY_UOBJECT:
				case BRACE_OBJECT_CATEGORY_ACTOR:
				default:
					pProvider = new ArrayHashtableCollectionSetProvider(GetInterpreter());
					break;
				}
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->TypeInference(func, data, *pInfo, arr, ix, val, resultInfo);
				}
			}
		}
		else if (arr.Type == Brace::BRACE_DATA_TYPE_STRING) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
			if (nullptr != pInfo) {
				AbstractCollectionSetApiProvider* pProvider = new StringCollectionSetProvider(GetInterpreter());
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->TypeInference(func, data, *pInfo, arr, ix, val, resultInfo);
				}
			}
		}
		std::stringstream ss;
		ss << "Unknown collection type ! line: " << data.GetLine();
		LogError(ss.str());
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
	{
		auto& arr = argInfos[0];
		auto& ix = argInfos[1];
		auto& val = argInfos[2];
		m_ApiProvider->Execute(gvars, lvars, arr, ix, val, resultInfo);
	}
private:
	std::unique_ptr<AbstractCollectionSetApiProvider> m_ApiProvider;
};
class CollectionGetExp final : public Brace::SimpleBraceApiBase
{
public:
	CollectionGetExp(Brace::BraceScript& interpreter) :Brace::SimpleBraceApiBase(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool TypeInference(const Brace::FuncInfo& func, const DslData::FunctionData& data, const std::vector<Brace::OperandLoadtimeInfo>& argInfos, Brace::OperandLoadtimeInfo& resultInfo) override
	{
		if (argInfos.size() != 2)
			return false;
		auto& arr = argInfos[0];
		auto& ix = argInfos[1];
		if (arr.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(arr.ObjectTypeId);
			if (nullptr != pInfo) {
				AbstractCollectionGetApiProvider* pProvider = nullptr;
				switch (pInfo->ObjectCategory) {
				case BRACE_OBJECT_CATEGORY_UOBJECT:
				case BRACE_OBJECT_CATEGORY_ACTOR:
				default:
					pProvider = new ArrayHashtableCollectionGetProvider(GetInterpreter());
					break;
				}
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->TypeInference(func, data, *pInfo, arr, ix, resultInfo);
				}
			}
		}
		else if (arr.Type == Brace::BRACE_DATA_TYPE_STRING) {
			auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
			if (nullptr != pInfo) {
				AbstractCollectionGetApiProvider* pProvider = new StringCollectionGetProvider(GetInterpreter());
				if (pProvider) {
					m_ApiProvider.reset(pProvider);
					return pProvider->TypeInference(func, data, *pInfo, arr, ix, resultInfo);
				}
			}
		}
		std::stringstream ss;
		ss << "Unknown collection type ! line: " << data.GetLine();
		LogError(ss.str());
		return false;
	}
	virtual void Execute(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars, const std::vector<Brace::OperandRuntimeInfo>& argInfos, const Brace::OperandRuntimeInfo& resultInfo)const override
	{
		auto& arr = argInfos[0];
		auto& ix = argInfos[1];
		m_ApiProvider->Execute(gvars, lvars, arr, ix, resultInfo);
	}
private:
	std::unique_ptr<AbstractCollectionGetApiProvider> m_ApiProvider;
};
class LambdaExp final : public Brace::AbstractBraceApi
{
public:
	LambdaExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		//(args) => {...}; or (args)int => {...}; or [...](args) => {...}; or [...](args)int => {...};
		bool hasError = true;
		if (hasError) {
			std::stringstream ss;
			ss << "lambda syntax error, line " << data.GetLine();
			LogError(ss.str());
		}
		return false;
	}
};
class LinqExp final : public Brace::AbstractBraceApi
{
public:
	LinqExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		//objs.where(condition) => linq(objs, "where", condition)
		//objs.orderby(fields) => linq(objs, "orderby", fields)
		//objs.orderbydesc(fields) => linq(objs, "orderbydesc", fields)
		//objs.top(count) => linq(objs, "top", count)
		int pnum = data.GetParamNum();
		if (pnum > 2) {
			Brace::OperandLoadtimeInfo listInfo;
			Brace::BraceApiExecutor list = LoadHelper(*data.GetParam(0), listInfo);
			std::string mid = data.GetParamId(1);
			BraceObjectInfo* pInfo = nullptr;
			AbstractLinqApiProvider* pProvider = nullptr;
			if (listInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
				pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(listInfo.ObjectTypeId);
				if (nullptr != pInfo && pInfo->ObjectCategory == BRACE_OBJECT_CATEGORY_OBJ_ARRAY) {
					pProvider = new ArrayHashtableLinqProvider(GetInterpreter());
				}
			}
			if (nullptr != pInfo && nullptr != pProvider) {
				PushBlock();
				int iteratorIndex = INVALID_INDEX;
				if (mid != "top") {
					iteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_OBJECT, pInfo->TypeParams.back());
				}
				std::vector<Brace::OperandLoadtimeInfo> argInfos;
				std::vector<Brace::BraceApiExecutor> args;
				for (int ix = 2; ix < pnum; ++ix) {
					auto* param = data.GetParam(ix);
					Brace::OperandLoadtimeInfo argLoadInfo;
					auto p = LoadHelper(*param, argLoadInfo);
					argInfos.push_back(std::move(argLoadInfo));
					args.push_back(std::move(p));
				}
                auto objVars = CurBlockObjVars();
                PopBlock();
                if (nullptr != pProvider) {
                    bool ret = pProvider->LoadLinqCall(func, data, *pInfo, iteratorIndex, std::move(listInfo), std::move(list), std::move(mid), std::move(argInfos), std::move(args), std::move(objVars), resultInfo, executor);
                    return ret;
                }
			}
		}
		std::stringstream ss;
		ss << "linq syntax error, line " << data.GetLine();
		LogError(ss.str());
		return false;
	}
private:
	std::unique_ptr<AbstractLinqApiProvider> m_ApiProvider;
};
class SelectExp final : public Brace::AbstractBraceApi
{
public:
	SelectExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
	{
	}
protected:
	virtual bool LoadStatement(const Brace::FuncInfo& func, const DslData::StatementData& statementData, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		//select(fields)top(10)from(objlist)where(exp)oderby(exps)groupby(exps)having(exp){statements;};
		std::string uobjArrKey = "array<:uobject:>";
		int uobjArrTypeId = g_ObjectInfoMgr.GetObjectTypeId(uobjArrKey);
		if (uobjArrTypeId == Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN) {
			uobjArrTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(uobjArrKey);
		}
		auto* pNewInfo = g_ObjectInfoMgr.GetBraceObjectInfo(uobjArrTypeId);
		if (nullptr == pNewInfo) {
			pNewInfo = g_ObjectInfoMgr.AddBraceObjectInfo(uobjArrTypeId, BRACE_OBJECT_CATEGORY_OBJ_ARRAY, uobjArrKey);
			pNewInfo->TypeParams.push_back(Brace::BRACE_DATA_TYPE_OBJECT);
			pNewInfo->TypeParams.push_back(CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT);
		}

		int fnum = statementData.GetFunctionNum();
		BraceObjectInfo* pInfo = nullptr;
		AbstractSelectApiProvider* pProvider = new ArrayHashtableSelectProvider(GetInterpreter());
		for (int ix = 0; ix < fnum; ++ix) {
			DslData::FunctionData* pFuncData = statementData.GetFunction(ix)->AsFunction();
			if (nullptr != pFuncData) {
				const std::string& fid = pFuncData->GetId();
				DslData::FunctionData* pCallData = pFuncData;
				if (pFuncData->IsHighOrder()) {
					pCallData = &pFuncData->GetLowerOrderFunction();
					if (ix != fnum - 1)
						return false;
				}
				if (fid == "from") {
					DslData::ISyntaxComponent* pSyntax = pCallData->GetParam(0);
					if (pSyntax->GetSyntaxType() == DslData::ISyntaxComponent::TYPE_VALUE) {
						pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(uobjArrTypeId);
						pProvider->LoadFromType(func, *pFuncData, *pInfo, pSyntax->GetId());
					}
					else {
						Brace::OperandLoadtimeInfo listInfo;
						Brace::BraceApiExecutor list;
						list = LoadHelper(*pCallData->GetParam(0), listInfo);
						if (listInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
							pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(listInfo.ObjectTypeId);
						}
						else {
							pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(uobjArrTypeId);
						}
						pProvider->LoadFromList(func, *pCallData, *pInfo, std::move(listInfo), std::move(list));
					}
					break;
				}
			}
		}
		DslData::FunctionData* pHavingCallData = nullptr;
		std::vector<Brace::DataTypeInfo> selectItTypes;
		for (int fix = 0; fix < fnum; ++fix) {
			DslData::FunctionData* pFuncData = statementData.GetFunction(fix)->AsFunction();
			if (nullptr != pFuncData) {
				const std::string& fid = pFuncData->GetId();
				DslData::FunctionData* pCallData = pFuncData;
				if (pFuncData->IsHighOrder()) {
					pCallData = &pFuncData->GetLowerOrderFunction();
					if (fix != fnum - 1)
						return false;
				}
				if (fid == "select") {
					PushBlock();
					int iteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_OBJECT, nullptr != pInfo ? pInfo->TypeParams.back() : CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT);
					std::vector<Brace::OperandLoadtimeInfo> argInfos;
					std::vector<Brace::BraceApiExecutor> args;
					std::vector<int> stats;
					int pnum = pCallData->GetParamNum();
					for (int pix = 0; pix < pnum; ++pix) {
						auto* param = pCallData->GetParam(pix);
						int stat = AbstractSelectApiProvider::STAT_METHOD_NONE;
						if (param->GetSyntaxType() == DslData::ISyntaxComponent::TYPE_FUNCTION) {
							auto* pParamFunc = static_cast<DslData::FunctionData*>(param);
							const std::string& pid = param->GetId();
							if (pid == "max") {
								stat = AbstractSelectApiProvider::STAT_METHOD_MAX;
								param = pParamFunc->GetParam(0);
							}
							else if (pid == "min") {
								stat = AbstractSelectApiProvider::STAT_METHOD_MIN;
								param = pParamFunc->GetParam(0);
							}
							else if (pid == "sum") {
								stat = AbstractSelectApiProvider::STAT_METHOD_SUM;
								param = pParamFunc->GetParam(0);
							}
							else if (pid == "avg") {
								stat = AbstractSelectApiProvider::STAT_METHOD_AVG;
								param = pParamFunc->GetParam(0);
							}
							else if (pid == "count") {
								stat = AbstractSelectApiProvider::STAT_METHOD_COUNT;
								param = pParamFunc->GetParam(0);
							}
						}
						Brace::OperandLoadtimeInfo argLoadInfo;
						auto p = LoadHelper(*param, argLoadInfo);
						switch(stat){
						case AbstractSelectApiProvider::STAT_METHOD_COUNT:
							selectItTypes.push_back(Brace::DataTypeInfo(Brace::BRACE_DATA_TYPE_INT32, Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ));
							break;
						case AbstractSelectApiProvider::STAT_METHOD_NONE:
						default:
							selectItTypes.push_back(argLoadInfo);
							break;
						}
						argInfos.push_back(std::move(argLoadInfo));
						args.push_back(std::move(p));
						stats.push_back(stat);
					}
					auto objVars = CurBlockObjVars();
					PopBlock();
					bool ret = pProvider->LoadSelect(func, *pCallData, *pInfo, iteratorIndex, std::move(argInfos), std::move(args), std::move(stats), std::move(objVars));
					if (!ret)
						return false;
				}
				else if (fid == "top") {
					PushBlock();
					Brace::OperandLoadtimeInfo argInfo;
					Brace::BraceApiExecutor arg;
					int pnum = pCallData->GetParamNum();
					auto* param = pCallData->GetParam(0);
					arg = LoadHelper(*param, argInfo);
					auto objVars = CurBlockObjVars();
					PopBlock();
					bool ret = pProvider->LoadTop(func, *pCallData, std::move(argInfo), std::move(arg), std::move(objVars));
					if (!ret)
						return false;
				}
				else if (fid == "from") {

				}
				else if (fid == "where") {
					PushBlock();
					int iteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_OBJECT, nullptr != pInfo ? pInfo->TypeParams.back() : CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT);
					Brace::OperandLoadtimeInfo argInfo;
					Brace::BraceApiExecutor arg;
					int pnum = pCallData->GetParamNum();
					auto* param = pCallData->GetParam(0);
					arg = LoadHelper(*param, argInfo);
					auto objVars = CurBlockObjVars();
					PopBlock();
					bool ret = pProvider->LoadWhere(func, *pCallData, *pInfo, iteratorIndex, std::move(argInfo), std::move(arg), std::move(objVars));
					if (!ret)
						return false;
				}
				else if (fid == "orderby") {
					PushBlock();
					int iteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_OBJECT, nullptr != pInfo ? pInfo->TypeParams.back() : CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT);
					std::vector<Brace::OperandLoadtimeInfo> argInfos;
					std::vector<Brace::BraceApiExecutor> args;
					std::vector<bool> ascOrDescs;
					int pnum = pCallData->GetParamNum();
					for (int pix = 0; pix < pnum; ++pix) {
						auto* param = pCallData->GetParam(pix);
						bool asc = true;
						if (param->GetSyntaxType() == DslData::ISyntaxComponent::TYPE_FUNCTION && param->GetId() == ":") {
							auto* pParamFunc = static_cast<DslData::FunctionData*>(param);
							param = pParamFunc->GetParam(0);
							asc = pParamFunc->GetParamId(1) != "desc";
						}
						Brace::OperandLoadtimeInfo argLoadInfo;
						auto p = LoadHelper(*param, argLoadInfo);
						argInfos.push_back(std::move(argLoadInfo));
						args.push_back(std::move(p));
						ascOrDescs.push_back(asc);
					}
					auto objVars = CurBlockObjVars();
					PopBlock();
					bool ret = pProvider->LoadOrderBy(func, *pCallData, *pInfo, iteratorIndex, std::move(argInfos), std::move(args), std::move(ascOrDescs), std::move(objVars));
					if (!ret)
						return false;
				}
				else if (fid == "groupby") {
					PushBlock();
					int iteratorIndex = AllocVariable("$$", Brace::BRACE_DATA_TYPE_OBJECT, nullptr != pInfo ? pInfo->TypeParams.back() : CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT);
					std::vector<Brace::OperandLoadtimeInfo> argInfos;
					std::vector<Brace::BraceApiExecutor> args;
					int pnum = pCallData->GetParamNum();
					for (int pix = 0; pix < pnum; ++pix) {
						auto* param = pCallData->GetParam(pix);
						Brace::OperandLoadtimeInfo argLoadInfo;
						auto p = LoadHelper(*param, argLoadInfo);
						argInfos.push_back(std::move(argLoadInfo));
						args.push_back(std::move(p));
					}
					auto objVars = CurBlockObjVars();
					PopBlock();
					bool ret = pProvider->LoadGroupBy(func, *pCallData, *pInfo, iteratorIndex, std::move(argInfos), std::move(args), std::move(objVars));
					if (!ret)
						return false;
				}
				else if (fid == "having") {
					pHavingCallData = pCallData;
				}
				else {
					return false;
				}
				if (fix == fnum - 1) {
					std::vector<Brace::OperandLoadtimeInfo> iterators;
					std::vector<Brace::BraceApiExecutor> statements;
					PushBlock();
					for (int i = 0; i < selectItTypes.size(); ++i) {
						auto& dt = selectItTypes[i];
						Brace::OperandLoadtimeInfo itInfo;
						itInfo.Type = dt.Type;
						itInfo.ObjectTypeId = dt.ObjectTypeId;
						itInfo.Name = std::string("$") + std::to_string(i);
						itInfo.VarIndex = AllocVariable(itInfo.Name, itInfo.Type, itInfo.ObjectTypeId);
						iterators.push_back(std::move(itInfo));
					}
					bool ret = true;
					if (nullptr != pHavingCallData) {
						Brace::OperandLoadtimeInfo argInfo;
						Brace::BraceApiExecutor arg;
						auto* param = pHavingCallData->GetParam(0);
						arg = LoadHelper(*param, argInfo);
						ret = pProvider->LoadHaving(func, *pHavingCallData, std::move(argInfo), std::move(arg));
					}
					if (pFuncData->IsHighOrder()) {
						std::vector<Brace::OperandLoadtimeInfo> argInfos;
						std::vector<Brace::BraceApiExecutor> args;
						int pnum = pFuncData->GetParamNum();
						for (int pix = 0; pix < pnum; ++pix) {
							auto* param = pFuncData->GetParam(pix);
							Brace::OperandLoadtimeInfo argLoadInfo;
							auto p = LoadHelper(*param, argLoadInfo);
                            				if (!p.isNull())
                                				statements.push_back(std::move(p));
						}
					}
					auto objVars = CurBlockObjVars();
					PopBlock();
					ret = pProvider->LoadStatements(func, *pFuncData, std::move(statements), resultInfo, executor) && ret;
					pProvider->LoadResultIterator(std::move(iterators), std::move(objVars));
					if (!ret)
						return false;
				}
			}
		}
		return true;
	}
private:
	std::unique_ptr<AbstractSelectApiProvider> m_ApiProvider;
};
class ArrayExp final : public Brace::AbstractBraceApi
{
	enum ArrayCategory
	{
		ARRAY_UNKNOWN = -1,
		ARRAY_BOOL = 0,
		ARRAY_INT,
		ARRAY_FLOAT,
		ARRAY_STRING,
		ARRAY_OBJ
	};
public:
	ArrayExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ObjectTypeId(Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ), m_Args(), m_ArgInfos(), m_ResultInfo()
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& curFunc, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor)
	{
		std::vector<Brace::BraceApiExecutor> args;
		std::vector<Brace::OperandLoadtimeInfo> argLoadInfos;
		int num = data.GetParamNum();
		for (int ix = 0; ix < num; ++ix) {
			auto* param = data.GetParam(ix);
			Brace::OperandLoadtimeInfo argLoadInfo;
			auto p = LoadHelper(*param, argLoadInfo);
			args.push_back(std::move(p));
			argLoadInfos.push_back(std::move(argLoadInfo));
		}
		int arrayCategory = ARRAY_UNKNOWN;
		int dataType = Brace::BRACE_DATA_TYPE_UNKNOWN;
		int objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		if (data.IsHighOrder()) {
			auto& lowerFunc = data.GetLowerOrderFunction();
			if (lowerFunc.GetParamNum() == 1 && lowerFunc.GetParamClassUnmasked() == DslData::FunctionData::PARAM_CLASS_ANGLE_BRACKET_COLON) {
				const std::string& id = lowerFunc.GetParamId(0);
				dataType = Brace::GetDataType(id);
				objTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
				if (dataType == Brace::BRACE_DATA_TYPE_OBJECT) {
					objTypeId = GetObjectTypeId(*lowerFunc.GetParam(0));
				}
			}
		}
		else if (!argLoadInfos.empty()) {
			auto& firstInfo = argLoadInfos.front();
			dataType = firstInfo.Type;
			objTypeId = firstInfo.ObjectTypeId;
		}
		switch (dataType) {
		case Brace::BRACE_DATA_TYPE_BOOL:
			arrayCategory = ARRAY_BOOL;
			break;
		case Brace::BRACE_DATA_TYPE_INT8:
		case Brace::BRACE_DATA_TYPE_UINT8:
		case Brace::BRACE_DATA_TYPE_INT16:
		case Brace::BRACE_DATA_TYPE_UINT16:
		case Brace::BRACE_DATA_TYPE_INT32:
		case Brace::BRACE_DATA_TYPE_UINT32:
		case Brace::BRACE_DATA_TYPE_INT64:
		case Brace::BRACE_DATA_TYPE_UINT64:
			arrayCategory = ARRAY_INT;
			break;
		case Brace::BRACE_DATA_TYPE_FLOAT:
		case Brace::BRACE_DATA_TYPE_DOUBLE:
			arrayCategory = ARRAY_FLOAT;
			break;
		case Brace::BRACE_DATA_TYPE_STRING:
			arrayCategory = ARRAY_STRING;
			break;
		case Brace::BRACE_DATA_TYPE_OBJECT:
			arrayCategory = ARRAY_OBJ;
			break;
		}
		switch (arrayCategory) {
		case ARRAY_BOOL: {
			bool good = true;
			for (auto& ai : argLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_BOOL && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_Args, args);
				SetArgInfos(argLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayExp::ExecuteBool);
				return true;
			}
		}break;
		case ARRAY_INT: {
			bool good = true;
			for (auto& ai : argLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_Args, args);
				SetArgInfos(argLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayExp::ExecuteInt);
				return true;
			}
		}break;
		case ARRAY_FLOAT: {
			bool good = true;
			for (auto& ai : argLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_DOUBLE) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_Args, args);
				SetArgInfos(argLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayExp::ExecuteFloat);
				return true;
			}
		}break;
		case ARRAY_STRING: {
			bool good = true;
			for (auto& ai : argLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_Args, args);
				SetArgInfos(argLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &ArrayExp::ExecuteString);
				return true;
			}
		}break;
		case ARRAY_OBJ: {
			bool good = true;
			for (auto& ai : argLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_OBJECT && ai.ObjectTypeId == objTypeId) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::string typeKey = std::string("array<:") + GetObjectTypeName(objTypeId) + ":>";
				m_ObjectTypeId = g_ObjectInfoMgr.GetObjectTypeId(typeKey);
				if (m_ObjectTypeId == Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN) {
					m_ObjectTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(typeKey);
				}
				auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(m_ObjectTypeId);
				if (nullptr == pInfo) {
					pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(m_ObjectTypeId, BRACE_OBJECT_CATEGORY_OBJ_ARRAY, std::move(typeKey));
					pInfo->TypeParams.push_back(dataType);
					pInfo->TypeParams.push_back(objTypeId);
				}
				if (nullptr != pInfo) {
					std::swap(m_Args, args);
					SetArgInfos(argLoadInfos);
					resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
					resultInfo.ObjectTypeId = m_ObjectTypeId;
					resultInfo.Name = GenTempVarName();
					resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
					m_ResultInfo = resultInfo;
					executor.attach(this, &ArrayExp::ExecuteObject);
					return true;
				}
			}
		}break;
		}
		std::stringstream ss;
		ss << "Array syntax error ! array<: bool|int32|float|string|obj :>(v1, v2, ...) line: " << data.GetLine();
		LogError(ss.str());
		return false;
    }
private:
    void SetArgInfos(std::vector<Brace::OperandLoadtimeInfo> argLoadInfos)
    {
        for (auto& info : argLoadInfos) {
            m_ArgInfos.push_back(info);
        }
    }
private:
	int ExecuteBool(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_Args) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using BoolArrayObj = ArrayObjT<bool>;
		auto* p = new BoolArrayObj();
		for (auto& ai : m_ArgInfos) {
			bool v = Brace::VarGetBoolean((ai.IsGlobal ? gvars : lvars), ai.Type, ai.VarIndex);
			p->GetImpl().push_back(v);
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteInt(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_Args) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using IntArrayObj = ArrayObjT<int64_t>;
		auto* p = new IntArrayObj();
		for (auto& ai : m_ArgInfos) {
			int64_t v = Brace::VarGetI64((ai.IsGlobal ? gvars : lvars), ai.Type, ai.VarIndex);
			p->GetImpl().push_back(v);
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteFloat(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_Args) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using FloatArrayObj = ArrayObjT<double>;
		auto* p = new FloatArrayObj();
		for (auto& ai : m_ArgInfos) {
			double v = Brace::VarGetF64((ai.IsGlobal ? gvars : lvars), ai.Type, ai.VarIndex);
			p->GetImpl().push_back(v);
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteString(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_Args) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using StrArrayObj = ArrayObjT<std::string>;
		auto* p = new StrArrayObj();
		for (auto& ai : m_ArgInfos) {
			const std::string& v = Brace::VarGetString((ai.IsGlobal ? gvars : lvars), ai.VarIndex);
			p->GetImpl().push_back(v);
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteObject(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_Args) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		auto* p = new ObjectArray();
		for (auto& ai : m_ArgInfos) {
			auto& v = Brace::VarGetObject((ai.IsGlobal ? gvars : lvars), ai.VarIndex);
			p->GetImpl().push_back(v);
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	int m_ObjectTypeId;
	std::vector<Brace::BraceApiExecutor> m_Args;
	std::vector<Brace::OperandRuntimeInfo> m_ArgInfos;
	Brace::OperandRuntimeInfo m_ResultInfo;
};
class HashtableExp final : public Brace::AbstractBraceApi
{
	enum HashtableCategory
	{
		HASHTABLE_UNKNOWN = -1,
		HASHTABLE_STR_STR = 0,
		HASHTABLE_STR_INT,
		HASHTABLE_STR_FLOAT,
		HASHTABLE_STR_BOOL,
		HASHTABLE_STR_OBJ,
		HASHTABLE_INT_STR,
		HASHTABLE_INT_INT,
		HASHTABLE_INT_FLOAT,
		HASHTABLE_INT_BOOL,
		HASHTABLE_INT_OBJ
	};
public:
	HashtableExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter)
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& data, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		std::vector<Brace::BraceApiExecutor> argKeys;
		std::vector<Brace::BraceApiExecutor> argVals;
		std::vector<Brace::OperandLoadtimeInfo> argKeyLoadInfos;
		std::vector<Brace::OperandLoadtimeInfo> argValLoadInfos;
		int num = data.GetParamNum();
		for (int ix = 0; ix < num; ++ix) {
			auto* param = data.GetParam(ix);
			if (param->GetSyntaxType() != DslData::ISyntaxComponent::TYPE_FUNCTION || (param->GetId() != "=>" && param->GetId() != ":")) {
				std::stringstream ss;
				ss << "Hashtable syntax error ! param must be pairs (k1 => v1, k2 => v2, ...) line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			auto* funcData = static_cast<DslData::FunctionData*>(param);
			if (funcData->GetParamNum() != 2) {
				std::stringstream ss;
				ss << "Hashtable syntax error ! param must be pairs (k1 => v1, k2 => v2, ...) line: " << data.GetLine();
				LogError(ss.str());
				return false;
			}
			Brace::OperandLoadtimeInfo argKeyLoadInfo;
			Brace::OperandLoadtimeInfo argValLoadInfo;
			auto p_key = LoadHelper(*funcData->GetParam(0), argKeyLoadInfo);
			auto p_val = LoadHelper(*funcData->GetParam(1), argValLoadInfo);
			argKeys.push_back(std::move(p_key));
			argKeyLoadInfos.push_back(std::move(argKeyLoadInfo));
			argVals.push_back(std::move(p_val));
			argValLoadInfos.push_back(std::move(argValLoadInfo));
		}
		int hashtableCategory = HASHTABLE_UNKNOWN;
		int keyDataType = Brace::BRACE_DATA_TYPE_UNKNOWN;
		int valDataType = Brace::BRACE_DATA_TYPE_UNKNOWN;
		int keyObjTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		int valObjTypeId = Brace::PREDEFINED_BRACE_OBJECT_TYPE_NOTOBJ;
		if (data.IsHighOrder()) {
			auto& lowerFunc = data.GetLowerOrderFunction();
			if (lowerFunc.GetParamNum() == 2 && lowerFunc.GetParamClassUnmasked() == DslData::FunctionData::PARAM_CLASS_ANGLE_BRACKET_COLON) {
				const std::string& key = lowerFunc.GetParamId(0);
				const std::string& val = lowerFunc.GetParamId(1);
				keyDataType = Brace::GetDataType(key);
				valDataType = Brace::GetDataType(val);
				if (valDataType == Brace::BRACE_DATA_TYPE_OBJECT) {
					valObjTypeId = GetObjectTypeId(*lowerFunc.GetParam(1));
				}
			}
		}
		else if (!argKeyLoadInfos.empty() && !argValLoadInfos.empty()) {
			auto& firstKeyInfo = argKeyLoadInfos.front();
			auto& firstValInfo = argValLoadInfos.front();
			keyDataType = firstKeyInfo.Type;
			keyObjTypeId = firstKeyInfo.ObjectTypeId;
			valDataType = firstValInfo.Type;
			valObjTypeId = firstValInfo.ObjectTypeId;
		}
		switch (keyDataType) {
		case Brace::BRACE_DATA_TYPE_STRING:
			switch (valDataType) {
			case Brace::BRACE_DATA_TYPE_BOOL:
				hashtableCategory = HASHTABLE_STR_BOOL;
				break;
			case Brace::BRACE_DATA_TYPE_INT8:
			case Brace::BRACE_DATA_TYPE_UINT8:
			case Brace::BRACE_DATA_TYPE_INT16:
			case Brace::BRACE_DATA_TYPE_UINT16:
			case Brace::BRACE_DATA_TYPE_INT32:
			case Brace::BRACE_DATA_TYPE_UINT32:
			case Brace::BRACE_DATA_TYPE_INT64:
			case Brace::BRACE_DATA_TYPE_UINT64:
				hashtableCategory = HASHTABLE_STR_INT;
				break;
			case Brace::BRACE_DATA_TYPE_FLOAT:
			case Brace::BRACE_DATA_TYPE_DOUBLE:
				hashtableCategory = HASHTABLE_STR_FLOAT;
				break;
			case Brace::BRACE_DATA_TYPE_STRING:
				hashtableCategory = HASHTABLE_STR_STR;
				break;
			case Brace::BRACE_DATA_TYPE_OBJECT:
				hashtableCategory = HASHTABLE_STR_OBJ;
				break;
			}
			break;
		case Brace::BRACE_DATA_TYPE_INT8:
		case Brace::BRACE_DATA_TYPE_UINT8:
		case Brace::BRACE_DATA_TYPE_INT16:
		case Brace::BRACE_DATA_TYPE_UINT16:
		case Brace::BRACE_DATA_TYPE_INT32:
		case Brace::BRACE_DATA_TYPE_UINT32:
		case Brace::BRACE_DATA_TYPE_INT64:
		case Brace::BRACE_DATA_TYPE_UINT64:
			switch (valDataType) {
			case Brace::BRACE_DATA_TYPE_BOOL:
				hashtableCategory = HASHTABLE_INT_BOOL;
				break;
			case Brace::BRACE_DATA_TYPE_INT8:
			case Brace::BRACE_DATA_TYPE_UINT8:
			case Brace::BRACE_DATA_TYPE_INT16:
			case Brace::BRACE_DATA_TYPE_UINT16:
			case Brace::BRACE_DATA_TYPE_INT32:
			case Brace::BRACE_DATA_TYPE_UINT32:
			case Brace::BRACE_DATA_TYPE_INT64:
			case Brace::BRACE_DATA_TYPE_UINT64:
				hashtableCategory = HASHTABLE_INT_INT;
				break;
			case Brace::BRACE_DATA_TYPE_FLOAT:
			case Brace::BRACE_DATA_TYPE_DOUBLE:
				hashtableCategory = HASHTABLE_INT_FLOAT;
				break;
			case Brace::BRACE_DATA_TYPE_STRING:
				hashtableCategory = HASHTABLE_INT_STR;
				break;
			case Brace::BRACE_DATA_TYPE_OBJECT:
				hashtableCategory = HASHTABLE_INT_OBJ;
				break;
			}
			break;
		}
		switch (hashtableCategory) {
		case HASHTABLE_INT_BOOL: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_BOOL && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteIntBool);
				return true;
			}
		}break;
		case HASHTABLE_INT_INT: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteIntInt);
				return true;
			}
		}break;
		case HASHTABLE_INT_FLOAT: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_DOUBLE) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteIntFloat);
				return true;
			}
		}break;
		case HASHTABLE_INT_STR: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteIntStr);
				return true;
			}
		}break;
		case HASHTABLE_INT_OBJ: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_OBJECT && ai.ObjectTypeId == valObjTypeId) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::string typeKey = std::string("array<:") + GetObjectTypeName(valObjTypeId) + ":>";
				int objectTypeId = g_ObjectInfoMgr.GetObjectTypeId(typeKey);
				if (objectTypeId == Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN) {
					objectTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(typeKey);
				}
				auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objectTypeId);
				if (nullptr == pInfo) {
					pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(objectTypeId, BRACE_OBJECT_CATEGORY_INT_OBJ_HASHTABLE, std::move(typeKey));
					pInfo->TypeParams.push_back(keyDataType);
					pInfo->TypeParams.push_back(keyObjTypeId);
					pInfo->TypeParams.push_back(valDataType);
					pInfo->TypeParams.push_back(valObjTypeId);
				}
				if (nullptr != pInfo) {
					std::swap(m_ArgKeys, argKeys);
					SetArgKeyInfos(argKeyLoadInfos);
					std::swap(m_ArgVals, argVals);
					SetArgValInfos(argValLoadInfos);
					resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
					resultInfo.ObjectTypeId = objectTypeId;
					resultInfo.Name = GenTempVarName();
					resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
					m_ResultInfo = resultInfo;
					executor.attach(this, &HashtableExp::ExecuteIntObj);
					return true;
				}
			}
		}break;
		case HASHTABLE_STR_BOOL: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_BOOL && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteStrBool);
				return true;
			}
		}break;
		case HASHTABLE_STR_INT: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_UINT64) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteStrInt);
				return true;
			}
		}break;
		case HASHTABLE_STR_FLOAT: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type >= Brace::BRACE_DATA_TYPE_INT8 && ai.Type <= Brace::BRACE_DATA_TYPE_DOUBLE) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteStrFloat);
				return true;
			}
		}break;
		case HASHTABLE_STR_STR: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::swap(m_ArgKeys, argKeys);
				SetArgKeyInfos(argKeyLoadInfos);
				std::swap(m_ArgVals, argVals);
				SetArgValInfos(argValLoadInfos);
				resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
				resultInfo.ObjectTypeId = CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE;
				resultInfo.Name = GenTempVarName();
				resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
				m_ResultInfo = resultInfo;
				executor.attach(this, &HashtableExp::ExecuteStrStr);
				return true;
			}
		}break;
		case HASHTABLE_STR_OBJ: {
			bool good = true;
			for (auto& ai : argKeyLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_STRING) {
				}
				else {
					good = false;
					break;
				}
			}
			for (auto& ai : argValLoadInfos) {
				if (ai.Type == Brace::BRACE_DATA_TYPE_OBJECT && ai.ObjectTypeId == valObjTypeId) {
				}
				else {
					good = false;
					break;
				}
			}
			if (good) {
				std::string typeKey = std::string("array<:") + GetObjectTypeName(valObjTypeId) + ":>";
				int objectTypeId = g_ObjectInfoMgr.GetObjectTypeId(typeKey);
				if (objectTypeId == Brace::PREDEFINED_BRACE_OBJECT_TYPE_UNKNOWN) {
					objectTypeId = g_ObjectInfoMgr.AddNewObjectTypeId(typeKey);
				}
				auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objectTypeId);
				if (nullptr == pInfo) {
					pInfo = g_ObjectInfoMgr.AddBraceObjectInfo(objectTypeId, BRACE_OBJECT_CATEGORY_STR_OBJ_HASHTABLE, std::move(typeKey));
					pInfo->TypeParams.push_back(keyDataType);
					pInfo->TypeParams.push_back(keyObjTypeId);
					pInfo->TypeParams.push_back(valDataType);
					pInfo->TypeParams.push_back(valObjTypeId);
				}
				if (nullptr != pInfo) {
					std::swap(m_ArgKeys, argKeys);
					SetArgKeyInfos(argKeyLoadInfos);
					std::swap(m_ArgVals, argVals);
					SetArgValInfos(argValLoadInfos);
					resultInfo.Type = Brace::BRACE_DATA_TYPE_OBJECT;
					resultInfo.ObjectTypeId = objectTypeId;
					resultInfo.Name = GenTempVarName();
					resultInfo.VarIndex = AllocVariable(resultInfo.Name, resultInfo.Type, resultInfo.ObjectTypeId);
					m_ResultInfo = resultInfo;
					executor.attach(this, &HashtableExp::ExecuteStrObj);
					return true;
				}
			}
		}break;
		}
		std::stringstream ss;
		ss << "Hashtable syntax error ! hashtable<: int32|string, bool|int32|float|string|obj :>(k1 => v1, k2 => v2, ...) line: " << data.GetLine();
		LogError(ss.str());
		return false;
	}
private:
	void SetArgKeyInfos(std::vector<Brace::OperandLoadtimeInfo> argKeyLoadInfos)
	{
		for (auto& info : argKeyLoadInfos) {
			m_ArgKeyInfos.push_back(info);
		}
	}
	void SetArgValInfos(std::vector<Brace::OperandLoadtimeInfo> argValLoadInfos)
	{
		for (auto& info : argValLoadInfos) {
			m_ArgValInfos.push_back(info);
		}
	}
private:
	int ExecuteIntStr(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<int64_t, std::string>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			int64_t k = Brace::VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			std::string v = Brace::VarGetStr((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(k, std::move(v)));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntInt(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<int64_t, int64_t>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			int64_t k = Brace::VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			int64_t v = Brace::VarGetI64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(k, v));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntFloat(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<int64_t, double>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			int64_t k = Brace::VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			double v = Brace::VarGetF64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(k, v));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntBool(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<int64_t, bool>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			int64_t k = Brace::VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			bool v = Brace::VarGetBoolean((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(k, v));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteIntObj(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		auto* p = new IntObjHashtable();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			int64_t k = Brace::VarGetI64((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			auto v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
			p->GetImpl().insert(std::make_pair(k, std::move(v)));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrStr(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<std::string, std::string>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			std::string k = Brace::VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			std::string v = Brace::VarGetStr((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(std::move(k), std::move(v)));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrInt(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<std::string, int64_t>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			std::string k = Brace::VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			int64_t v = Brace::VarGetI64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(std::move(k), v));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrFloat(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<std::string, double>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			std::string k = Brace::VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			double v = Brace::VarGetF64((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(std::move(k), v));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrBool(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		using HashtableObj = HashtableObjT<std::string, bool>;
		auto* p = new HashtableObj();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			std::string k = Brace::VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			bool v = Brace::VarGetBoolean((val.IsGlobal ? gvars : lvars), val.Type, val.VarIndex);
			p->GetImpl().insert(std::make_pair(std::move(k), v));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
	int ExecuteStrObj(Brace::VariableInfo& gvars, Brace::VariableInfo& lvars)const
	{
		for (auto& arg : m_ArgKeys) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		for (auto& arg : m_ArgVals) {
			if (!arg.isNull())
				arg(gvars, lvars);
		}
		auto* p = new StrObjHashtable();
		for (int ix = 0; ix < static_cast<int>(m_ArgKeyInfos.size()) && ix < static_cast<int>(m_ArgValInfos.size()); ++ix) {
			auto& key = m_ArgKeyInfos[ix];
			auto& val = m_ArgValInfos[ix];
			std::string k = Brace::VarGetStr((key.IsGlobal ? gvars : lvars), key.Type, key.VarIndex);
			auto v = Brace::VarGetObject((val.IsGlobal ? gvars : lvars), val.VarIndex);
			p->GetImpl().insert(std::make_pair(std::move(k), std::move(v)));
		}
		Brace::VarSetObject((m_ResultInfo.IsGlobal ? gvars : lvars), m_ResultInfo.VarIndex, std::shared_ptr<Brace::IBraceObject>(p));
		return Brace::BRACE_FLOW_CONTROL_NORMAL;
	}
private:
	std::vector<Brace::BraceApiExecutor> m_ArgKeys;
	std::vector<Brace::OperandRuntimeInfo> m_ArgKeyInfos;
	std::vector<Brace::BraceApiExecutor> m_ArgVals;
	std::vector<Brace::OperandRuntimeInfo> m_ArgValInfos;
	Brace::OperandRuntimeInfo m_ResultInfo;
};
class LoopListExp final : public Brace::AbstractBraceApi
{
public:
	LoopListExp(Brace::BraceScript& interpreter) :Brace::AbstractBraceApi(interpreter), m_ApiProvider()
	{
	}
protected:
	virtual bool LoadFunction(const Brace::FuncInfo& func, const DslData::FunctionData& funcData, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		if (funcData.IsHighOrder()) {
			bool ret = false;
			auto* p = funcData.GetLowerOrderFunction().GetParam(0);
			Brace::OperandLoadtimeInfo loadInfo;
			auto list = LoadHelper(*p, loadInfo);
			auto& listInfo = loadInfo;
            PushBlock();
			BraceObjectInfo* pInfo = nullptr;
            AbstractLoopListApiProvider* pProvider = nullptr;
			if (listInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
				pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(listInfo.ObjectTypeId);
				if (nullptr != pInfo) {
					switch (pInfo->ObjectCategory) {
					case BRACE_OBJECT_CATEGORY_UOBJECT:
					case BRACE_OBJECT_CATEGORY_ACTOR:
					default:
						pProvider = new ArrayHashtableLoopListProvider(GetInterpreter());
						break;
					}
				}
			}
			else if (listInfo.Type == Brace::BRACE_DATA_TYPE_STRING) {
				pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING);
				if (nullptr != pInfo) {
					pProvider = new StringLoopListProvider(GetInterpreter());
				}
			}
			if (pProvider) {
				ret = true;
				m_ApiProvider.reset(pProvider);
				if (!pProvider->TypeInference(func, funcData, *pInfo, listInfo, executor)) {
					std::stringstream ss;
					ss << "BraceScript error, " << funcData.GetId() << " line " << funcData.GetLine();
					LogError(ss.str());
					ret = false;
				}
				else {
					std::vector<Brace::BraceApiExecutor> statements{};
					for (int ix = 0; ix < funcData.GetParamNum(); ++ix) {
						Brace::OperandLoadtimeInfo argLoadInfo;
						auto statement = LoadHelper(*funcData.GetParam(ix), argLoadInfo);
						if (!statement.isNull())
							statements.push_back(std::move(statement));
					}
					auto& objVars = CurBlockObjVars();
					pProvider->StoreRuntimeInfo(std::move(listInfo), std::move(list), std::move(statements), objVars);
				}
			}
			PopBlock();
			return ret;
		}
		else {
			//error
			std::stringstream ss;
			ss << "BraceScript error, " << funcData.GetId() << " line " << funcData.GetLine();
			LogError(ss.str());
		}
		return false;
	}
	virtual bool LoadStatement(const Brace::FuncInfo& func, const DslData::StatementData& statementData, Brace::OperandLoadtimeInfo& resultInfo, Brace::BraceApiExecutor& executor) override
	{
		//looplist(exp) func(args);
		if (statementData.GetFunctionNum() == 2) {
			auto* first = statementData.GetFirst()->AsFunction();
			auto* second = statementData.GetSecond()->AsFunction();
			const std::string& firstId = first->GetId();
			const std::string& secondId = second->GetId();
			if (!first->HaveStatement() && !first->HaveExternScript() &&
				!secondId.empty() && !second->HaveStatement() && !second->HaveExternScript()) {
				if (first->GetParamNum() > 0) {
					bool ret = false;
					auto* exp = first->GetParam(0);
					Brace::OperandLoadtimeInfo loadInfo;
					auto list = LoadHelper(*exp, loadInfo);
                    auto& listInfo = loadInfo;
					if (listInfo.Type == Brace::BRACE_DATA_TYPE_OBJECT) {
						auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(listInfo.ObjectTypeId);
						if (nullptr != pInfo) {
							AbstractLoopListApiProvider* pProvider = nullptr;
							switch (pInfo->ObjectCategory) {
							case BRACE_OBJECT_CATEGORY_UOBJECT:
							case BRACE_OBJECT_CATEGORY_ACTOR:
							default:
								pProvider = new ArrayHashtableLoopListProvider(GetInterpreter());
								break;
							}
							if (pProvider) {
								ret = true;
								m_ApiProvider.reset(pProvider);
								if (!pProvider->TypeInference(func, statementData, *pInfo, listInfo, executor)) {
									std::stringstream ss;
									ss << "BraceScript error, " << statementData.GetId() << " line " << statementData.GetLine();
									LogError(ss.str());
									ret = false;
								}
								else {
									Brace::OperandLoadtimeInfo argLoadInfo;
									std::vector<Brace::BraceApiExecutor> statements{};
									auto statement = LoadHelper(*second, argLoadInfo);
									if (!statement.isNull())
										statements.push_back(std::move(statement));
									pProvider->StoreRuntimeInfo(std::move(listInfo), std::move(list), std::move(statements), std::vector<int>());
								}
							}
						}
					}
					return ret;
				}
				else {
					//error
					std::stringstream ss;
					ss << "BraceScript error, " << first->GetId() << " line " << first->GetLine();
					LogError(ss.str());
					return false;
				}
				return true;
			}
		}
		return false;
	}
private:
	std::unique_ptr<AbstractLoopListApiProvider> m_ApiProvider;
};


/*
*   ========== in BraceScript init code, some callbacks must be implemented. ==========
* 
	m_pBraceScript = new Brace::BraceScript();
	m_pBraceScript->OnInfo = [](auto& str) { printf("[brace info]:%s", str.c_str()); };
	m_pBraceScript->OnWarn = [](auto& str) { printf("[brace warn]:%s", str.c_str()); };
	m_pBraceScript->OnError = [](auto& str) { printf("[brace error]:%s", str.c_str()); };

	m_pBraceScript->OnGetObjectTypeId = [](const DslData::ISyntaxComponent& syntax) {
		std::string key = g_ObjectInfoMgr.CalcObjTypeKey(syntax);
		return g_ObjectInfoMgr.GetObjectTypeId(key);
	};
	m_pBraceScript->OnGetObjectTypeName = [](int objTypeId) {
		auto* pInfo = g_ObjectInfoMgr.GetBraceObjectInfo(objTypeId);
		if (nullptr != pInfo)
			return pInfo->TypeName.c_str();
		return "unknown";
	};
	m_pBraceScript->OnObjectAssignCheck = [](int destObjTypeId, int srcObjTypeId) {
		if (destObjTypeId == srcObjTypeId)
			return true;
		return false;
	};

	/// missing language features
	m_pBraceScript->RegisterApi("membercall", new Brace::BraceApiFactory<MemberCallExp>());
	m_pBraceScript->RegisterApi("memberset", new Brace::BraceApiFactory<MemberSetExp>());
	m_pBraceScript->RegisterApi("memberget", new Brace::BraceApiFactory<MemberGetExp>());
	m_pBraceScript->RegisterApi("collectioncall", new Brace::BraceApiFactory<CollectionCallExp>());
	m_pBraceScript->RegisterApi("collectionset", new Brace::BraceApiFactory<CollectionSetExp>());
	m_pBraceScript->RegisterApi("collectionget", new Brace::BraceApiFactory<CollectionGetExp>());
	m_pBraceScript->RegisterApi("linq", new Brace::BraceApiFactory<LinqExp>());
    m_pBraceScript->RegisterApi("select", new Brace::BraceApiFactory<SelectExp>());
	m_pBraceScript->RegisterApi("lambda", new Brace::BraceApiFactory<LambdaExp>());
	m_pBraceScript->RegisterApi("array", new Brace::BraceApiFactory<ArrayExp>());
	m_pBraceScript->RegisterApi("hashtable", new Brace::BraceApiFactory<HashtableExp>());
	m_pBraceScript->RegisterApi("looplist", new Brace::BraceApiFactory<LoopListExp>());

	//add fixed map, obj table id <-> obj category
    g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STRING, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "string");  //fake obj info for string 
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_BOOL_ARRAY, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "array<:bool:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_ARRAY, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "array<:int64:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_FLOAT_ARRAY, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "array<:double:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_ARRAY, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "array<:string:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_BOOL_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:int64,bool:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_INT_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:int64,int64:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_FLOAT_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:int64,double:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_INT_STR_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:int64,string:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_BOOL_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:string,bool:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_INT_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:string,int64:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_FLOAT_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:string,double:>");
	g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_STR_STR_HASHTABLE, BRACE_OBJECT_CATEGORY_INTERNAL_FIXED_OBJECT, "hashtable<:string,string:>");
    g_ObjectInfoMgr.AddBraceObjectInfo(CUSTOM_BRACE_OBJECT_TYPE_CPP_UOBJECT, BRACE_OBJECT_CATEGORY_UOBJECT, "uobject");
*/