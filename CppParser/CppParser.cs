using Dsl.Common;
// CppParser.cs - generated by the SLK parser generator 

namespace Dsl.CppParser
{

    static class CppParser
    {

private static short[] Production = {0

,2,24,25 ,3,25,26,40 ,2,26,27 ,3,27,28,55 ,3,28,56,29 
,2,29,41 ,6,29,57,58,31,59,42 ,4,30,38,60,43 ,2,31,32 
,6,32,61,1,25,2,44 ,6,32,63,3,25,4,45 ,4,32,5,33,46 
,4,32,6,34,47 ,4,32,7,35,48 ,4,32,8,36,49 ,4,32,9,37,50 
,6,32,64,10,25,11,51 ,6,32,65,12,25,13,52 ,6,32,66,14,25,15,53 
,6,32,67,16,25,17,54 ,7,33,68,56,58,38,69,55 ,7,34,70,56,58,38,69,55 
,7,35,71,56,58,38,69,55 ,7,36,72,56,58,38,69,55 
,7,37,73,56,58,38,69,55 ,3,38,18,74 ,3,38,19,75 
,3,38,20,76 ,2,39,21 ,2,39,22 ,4,40,39,26,40 ,1,40 
,6,41,57,58,30,59,41 ,1,41 ,6,42,57,58,30,59,42 
,1,42 ,2,43,32 ,1,43 ,3,44,62,32 ,1,44 ,3,45,62,32 
,1,45 ,3,46,62,32 ,1,46 ,3,47,62,32 ,1,47 ,3,48,62,32 
,1,48 ,3,49,62,32 ,1,49 ,3,50,62,32 ,1,50 ,3,51,62,32 
,1,51 ,3,52,62,32 ,1,52 ,3,53,62,32 ,1,53 ,3,54,62,32 
,1,54 
,0};

private static int[] Production_row = {0

,1,4,8,11,15,19,22,29,34,37,44,51,56,61,66,71
,76,83,90,97,104,112,120,128,136,144,148,152,156,159,162,167
,169,176,178,185,187,190,192,196,198,202,204,208,210,214,216,220
,222,226,228,232,234,238,240,244,246,250,252,256
,0};

private static short[] Parse = {

0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2
,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3
,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4
,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5
,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,7,6,7,6,7
,7,7,7,7,7,6,7,6,7,6,7,6,6,6,6,6,6,6,37,38
,37,38,37,37,37,37,37,37,38,37,38,37,38,37,38,38,38,38,38,38
,38,39,40,39,40,39,39,39,39,39,39,40,39,40,39,40,39,40,40,40
,40,40,40,40,41,42,41,42,41,41,41,41,41,41,42,41,42,41,42,41
,42,42,42,42,42,42,42,43,44,43,44,43,43,43,43,43,43,44,43,44
,43,44,43,44,44,44,44,44,44,44,45,46,45,46,45,45,45,45,45,45
,46,45,46,45,46,45,46,46,46,46,46,46,46,47,48,47,48,47,47,47
,47,47,47,48,47,48,47,48,47,48,48,48,48,48,48,48,49,50,49,50
,49,49,49,49,49,49,50,49,50,49,50,49,50,50,50,50,50,50,50,51
,52,51,52,51,51,51,51,51,51,52,51,52,51,52,51,52,52,52,52,52
,52,52,53,54,53,54,53,53,53,53,53,53,54,53,54,53,54,53,54,54
,54,54,54,54,54,55,56,55,56,55,55,55,55,55,55,56,55,56,55,56
,55,56,56,56,56,56,56,56,57,58,57,58,57,57,57,57,57,57,58,57
,58,57,58,57,58,58,58,58,58,58,58,59,60,59,60,59,59,59,59,59
,59,60,59,60,59,60,59,60,60,60,60,60,60,60,1,0,1,0,1,1
,1,1,1,1,0,1,0,1,34,1,34,1,1,1,1,1,1,34,0,34
,0,34,0,34,33,33,33,34,34,34,36,0,36,8,8,8,21,21,21,36
,0,36,0,36,0,36,35,35,35,36,36,36,9,0,9,0,9,9,9,9
,9,9,0,9,10,9,11,9,12,13,14,15,16,17,32,18,32,19,0,20
,22,22,22,32,0,32,0,32,0,32,23,23,23,31,31,32,24,24,24,25
,25,25,26,27,28,29,30,0
};

private static int[] Parse_row = {0

,392,1,24,47,70,93,414,450,462,417,461,471,477,480,483,483
,471,405,427,116,139,162,185,208,231,254,277,300,323,346,369
,0};

private static short[] Conflict = {

0
};

private static int[] Conflict_row = {0


,0};

private static short get_conditional_production ( short symbol ) { return (short) 0; }

private const short   END_OF_SLK_INPUT_ = 23;
private const short   START_SYMBOL = 24;
private const short   START_STATE = 0;
private const short   START_CONFLICT = 61;
private const short   END_CONFLICT = 61;
private const short   START_ACTION = 55;
private const short   END_ACTION = 77;
private const short   TOTAL_CONFLICTS = 0;

public const int   NOT_A_SYMBOL = 0;
public const int   NONTERMINAL_SYMBOL = 1;
public const int   TERMINAL_SYMBOL = 2;
public const int   ACTION_SYMBOL = 3;

public static short[]
GetProductionArray ( short  production_number )
{
   short   index = (short)  Production_row [ production_number ],
           array_length = (short)  Production [ index ],
           new_index = 0;
   short[] productionArray = new short[16];        

   while ( array_length-- >= 0 ) {
       productionArray [ new_index++ ] = Production [ index++ ];
   }
   return  productionArray;
}

public static int GetSymbolType ( short   symbol )
{
   int   symbol_type = NOT_A_SYMBOL;

   if ( symbol >= START_ACTION  &&  symbol < END_ACTION ) {
       symbol_type = ACTION_SYMBOL;
   } else if ( symbol >= START_SYMBOL ) {
       symbol_type = NONTERMINAL_SYMBOL;
   } else if ( symbol > 0 ) {
       symbol_type = TERMINAL_SYMBOL;
   }
   return  symbol_type;
}

public static bool    IsNonterminal ( short   symbol )
{
   return ( symbol >= START_SYMBOL  &&  symbol < START_ACTION );
}

public static bool    IsTerminal ( short   symbol )
{
   return ( symbol > 0  &&  symbol < START_SYMBOL );
}

public static bool    IsAction ( short   symbol )
{
   return ( symbol >= START_ACTION  &&  symbol < END_ACTION );
}

public static short GetTerminalIndex ( short   token ){
 return ( token );
}

public static short
get_production ( short     conflict_number,
                 CppToken  tokens )
{
    short   entry = 0;
    int     index, level;

    if ( conflict_number <= TOTAL_CONFLICTS ) {
        entry = (short) ( conflict_number + (START_CONFLICT - 1) );
        level = 1;
        while ( entry >= START_CONFLICT ) {
            index = Conflict_row [entry - (START_CONFLICT -1)];
            index += tokens.peek ( level );
            entry = Conflict [ index ];
            ++level;
        }
    }

    return  entry;
}

private static short
get_predicted_entry ( CppToken   tokens,
                      short      production_number,
                      short      token,
                      int        scan_level,
                      int        depth )
{
 return  0;
}

        internal unsafe static void
        parse(ref DslAction action,
                ref CppToken tokens,
                ref CppError error,
                short start_symbol)
        {
            short rhs, lhs;
            short production_number, entry, symbol, token, new_token;
            int production_length, top, index, level;
            
            short* stack = stackalloc short[65535];

            top = 65534;
            stack[top] = 0;
            if (start_symbol == 0) {
                start_symbol = START_SYMBOL;
            }
            if (top > 0) {
                stack[--top] = start_symbol;
            } else { error.message("CppParse: stack overflow\n", ref tokens); return; }
            token = tokens.get();
            new_token = token;

            for (symbol = (stack[top] != 0 ? stack[top++] : (short)0); symbol != 0; ) {

                if (symbol >= START_ACTION) {
                    action.execute(symbol - (START_ACTION - 1));

                } else if (symbol >= START_SYMBOL) {
                    entry = 0;
                    level = 1;
                    production_number = get_conditional_production(symbol);
                    if (production_number != 0) {
                        entry = get_predicted_entry(tokens,
                                                      production_number, token,
                                                      level, 1);
                    }
                    if (entry == 0) {
                        index = Parse_row[symbol - (START_SYMBOL - 1)];
                        index += token;
                        entry = Parse[index];
                    }
                    while (entry >= START_CONFLICT) {
                        index = Conflict_row[entry - (START_CONFLICT - 1)];
                        index += tokens.peek(level);
                        entry = Conflict[index];
                        ++level;
                    }
                    if (entry != 0) {
                        index = Production_row[entry];
                        production_length = Production[index] - 1;
                        lhs = Production[++index];
                        if (lhs == symbol) {
                            action.predict(entry);
                            index += production_length;
                            for (; production_length-- > 0; --index) {
                                if (top > 0) {
                                    stack[--top] = Production[index];
                                } else { error.message("CppParse: stack overflow\n", ref tokens); return; }
                            }
                        } else {
                            new_token = error.no_entry(symbol, token, level - 1, ref tokens);
                        }
                    } else {                                       // no table entry
                        new_token = error.no_entry(symbol, token, level - 1, ref tokens);
                    }
                } else if (symbol > 0) {
                    if (symbol == token) {
                        token = tokens.get();
                        new_token = token;
                    } else {
                        new_token = error.mismatch(symbol, token, ref tokens);
                    }
                } else {
                    error.message("\n parser error: symbol value 0\n", ref tokens);
                }
                if (token != new_token) {
                    if (new_token != 0) {
                        token = new_token;
                    }
                    if (token != END_OF_SLK_INPUT_) {
                        continue;
                    }
                }
                symbol = (stack[top] != 0 ? stack[top++] : (short)0);
            }
            if (token != END_OF_SLK_INPUT_) {
                error.input_left(ref tokens);
            }
        }
    };
}
