/*
The Parser Generator (c) 2001-2022 by DMR, all rights reserved
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef unsigned int l3;
typedef unsigned long l4;
typedef unsigned char l5;
typedef unsigned short l6;
typedef struct l7
{
    struct
        l7* l8;
    int l9;
    int l10;
    char* l11;
    char* l12;
    struct
        l13* l14,
        * l15,
        * l16,
        * l17,
        * l18;
    struct
        l19* l20;
    int l21;
    struct
        l22* l23;
    l3 l24;
    l3 l25;
    l3 l26 : 1,
        l27 : 1,
        l28 : 1,
        l29 : 1,
        l30 : 1,
        l31 : 1,
        l32 : 1,
        l33 : 1,
        l34 : 1,
        l35 : 1,
        l36 : 1,
        l37 : 1,
        l38 : 1,
        l39 : 1,
        l40 : 1,
        l41 : 1,
        l42 : 1,
        l43 : 1,
        l44 : 1,
        l45 : 1;
} l46;
extern l46* l47;
extern int l48,
l49,
l50,
l51,
l52,
l53,
l54,
l55;
extern char* l56;
extern l3 l57,
l58;
void l59(int l60,
    char* l61);
void l62(void);
void l63(void);
char*
l64(char* l65);
l46* l66(register char* l11);
l46* l67(int l9,
    int l10,
    char* l11);
void l68(void);
l3 l69(void);
char*
l70(void);
l3 l71(void);
char*
l72(char* l11);
l3 l73(char* l11);
int (*l74(char* l75,
    l3 l76))(void);
void l77(int (*l78)(void),
    int l79);
char*
l80(l3 l81);
void l82(char* l83,
    char* l84,
    l3 l85,
    l3 l76);
void l86(char* l83,
    char* l84,
    int l87,
    l3 l85,
    FILE* l88,
    int l89);
void l90(char* l83,
    char* l84,
    int l87,
    l3 l85,
    FILE* l88,
    int l89);
void l91(char* l83,
    char* l84,
    int l87,
    l3 l85,
    FILE* l88,
    int l89);
void l92(char* l83,
    char* l84,
    l3 l85);
l3 l93(l3 l94,
    l3 l95,
    l3 l96,
    l3* l97);
l3 l98(l46* l99,
    l46* l100,
    l3 l79);
void l101(char* l102);
void l103(char* l102);
void l104(char* l102,
    l3 l105,
    l3 l106);
void l107(char* l102);
l3 l108(void);
l3 l109(void);
void l110(void);
l3 l111(char* l102);
l3 l112(char* l102);
l3 l113(char* l102);
void l114(void);
void l115(void);
int l116(char* l117,
    char* l118);
int l119(char* l117,
    char* l118);
char*
l120(char* l121,
    size_t* l122);
char*
l123(char* l124,
    char* l125,
    l46** l126,
    int l127);
int l128(int l129);
void l130(l3 l131,
    l3 l132);
void l133(FILE* l88,
    l3 l85);
void l134(char* l83,
    char* l84,
    l3 l85,
    FILE* l88);
void l135(int l136);
void l137(int l138);
void l139(void);
void l140(void);
typedef struct l19
{
    struct l19* l8;
    l3 l131,
        l141;
} l142;
extern l46** l143,
** l144,
** l145,
*** l146;
extern l3 l147,
l148,
l149,
l150,
l151,
l152,
l153,
l154,
l155,
l156;
void l157(void);
l3 l158(void);
l3 l159(void);
l46**
l160(register l46** l141);
l46***
l161(l46** l162,
    l46*** l23);
void l163(register l46*** l141);
void l164(l46** l141);
void l165(register l46** l141);
l3 l166(register l46** l167,
    register l46** l168);
int l169(register l46* l170);
void l171(l46* l126);
void l172(register l46* l126);
void l173(register l142* l20,
    register int l131,
    int l132);
void l174(register l142* l20,
    int l132,
    int l175);
l3 l176(register l46** l177);
void l178(l46* l179);
void l180(void);
void l181(void);
void l182(void);
void l183(void);
void l184(int l185);
void l186(void);
void l187(void);
void l188(char* l189,
    l46** l141);
void l190(int l138);
void l191(l46* l179);
typedef struct l22
{
    struct l22* l8;
    struct l7** l170,
        ** l177;
    struct l22* l192;
    l3 l193;
} l194;
enum l195
{
    l196 = 1,
    l197 = 2,
    l198 = 3
};
l194*
l199(l46** l170,
    l46** l177,
    l194* l192,
    l3 l193);
l3 l200(l194** l201,
    register l194* l202);
l3 l203(l194** l201,
    l46** l170,
    l46** l177,
    l194* l192,
    l194** l204,
    l3 l193);
l3 l205(l194** l206,
    register l194* l207,
    l194* l192);
l194*
l208(register l194* l206,
    register l194* l207);
l3 l209(register l194* l206,
    register l194* l207);
void l210(register l194* l211);
void l212(register l194** l201);
l194*
l213(register l194* l201);
void l214(l194** l201);
void l215(void);
int l216(l194* l201);
void l217(l46** l170,
    l46** l177);
void l218(l194** l201);
extern l3 l219,
l220,
l221;
enum l222
{
    l223 = 0x00010000,
    l224 = 0x00020000,
    l225 = 0x00040000,
    l226 = 0x00100000,
    l227 = 0x01000000,
    l228 = 0x02000000,
    l229 = 0x04000000,
    l230 = (l226 |
    l227),
    l231 = (l224 |
        l225),
    l232 = (l224 |
        l223 |
        l225),
    l233 = 0x7FFF0000,
    l234 = 0x0000FFFF
};
typedef struct l235
{
    struct
        l235* l8;
    int l138;
    l3 l236;
    l46* l237;
    l194* l238;
} l239;
typedef struct l240
{
    struct
        l240* l8;
    l239* l23;
    void* l241;
    l3 l242;
    l3 l138;
    l3 l243;
    l46** l244;
    l3 l245;
    l46* l246;
} l247;
l239*
l248(int l138,
    l3 l236,
    l194* l238);
l239*
l249(register l239* l250);
l3 l251(void);
l3 l252(l46* l244,
    l239* l253,
    l239* l162,
    l3 l245);
l3 l254(void* l240,
    l46* l244,
    int l253,
    l239* l162);
void l255(l3 l132);
void l256(void);
l247*
l257(void);
l247*
l258(l3 l132);
l3 l259(register l239* l141);
l3 l260(void* l240,
    l46* l244,
    int l261);
l3 l262(l3 l94,
    l3* l97,
    l3 l263);
void l264(l46* l244,
    int l253,
    int l162);
void l265(l3 l94);
void l266(l3 l94);
typedef struct l267
{
    struct l267* l8;
    int l131,
        l141;
} l268;
typedef struct l269
{
    struct l269* l8;
    l268* l270;
    l46* l179;
} l271;
typedef struct l272
{
    struct l272* l8;
    l271* l273;
} l274;
l271*
l275(l274* l276,
    l46* l179);
l3 l277(l271* l278,
    register struct
    l13* l14,
    void* l279,
    struct
    l235* l162);
l274*
l280(void);
l274*
l281(void);
void l282(l271* l278,
    int l131,
    int l132);
void l283(int l132);
void l284(void);
void l285(void);
typedef struct l13
{
    struct l13* l8;
    struct l7* l126;
} l286;
l3 l287(l3 l288,
    l3 l289);
l3 l290(int l79,
    l46* l179);
l3 l291(int l79);
l3 l292(int l79);
l3 l293(void);
l3 l294(void);
void l295(char* l296,
    int l297);
l3 l298(l286** l201,
    l46* l126);
l3 l299(l286** l206,
    register l286* l207);
l3 l300(l286** l201,
    l46* l126);
l3 l301(l286** l206,
    register l286* l207);
l3 l302(register l286* l201,
    l46* l126);
l46* l303(register l286* l304,
    register l286* l305);
int l306(register l286* l304,
    register l286* l305);
int l307(register l286* l304,
    register l286* l305);
l46* l308(register l286* l304,
    register l286* l305);
void l309(l286* l201);
l3 l310(void);
void l311(void);
void l312(void);
int l48 = 0,
l49 = 0,
l50 = 0,
l51 = 1,
l52 = 0,
l53 = 1,
l54 = 0,
l55 = 512;
char* l56 = "$$";
static int l313 = 0,
l314 = 0,
l315 = 0;
static char l316[] =
"pg  V5.13  (c) 2001-2022 by DMR\n";
static char*
l317 =
"LL(k) parser generator and generalized conflict resolver using k lookahead\n"
"Usage: pg  input_filename [-options] \n"
"  -a   append parser name to header file token defines (see -n below) \n"
"  -b   enable aggresive heuristic ambiguity checking \n"
"  -c   disable table compacting \n"
"  -cc  generate instance model C code (C with Classes) \n"
"  -cs  generate C#  code \n"
"  -C++ generate C++ code \n"
"  -Cr  -Gc with conflicts specified as __dot_ configs in the grammar \n"
"  -d   display parse derivation of the input grammar for debugging \n"
"  -dot use ^G for dot in configs instead of $$, prints as dot but beeps in console \n"
"  -Da  display all -D values \n"
"  -Dc  display all conflict traces for debugging only \n"
"  -Dd[=<symbol name>] display nonterminals that can left derive <symbol name> \n"
"  -De  display nonterminals that can derive the empty string, epsilon \n"
"  -Df  display first and follow sets \n"
"  -Dl  display lookahead strings for resolved conflicts \n"
"  -Dp  display productions \n"
"  -Dr  display LR states \n"
"  -Ds  display symbol table \n"
"  -Dt  display parse tables \n"
"  -E<n> convert EBNF grammar to SLK format, n=1 is IEEE, n=2 is ISO \n"
"  -e    disable EBNF grammar support \n"
"  -f=<filename>   name of the file for the output grammar \n"
"  -Fa  force _action_ naming so __ can be for user tokens \n"
"  -g   generate the parser even if the grammar is ambiguous \n"
"  -Ga  do not generate anything \n"
"  -Gc  generate conflict resolver only, no parser \n"
"  -Gd  generate parse derivation code in get_predicted_entry for debugging \n"
"  -Gn  do not generate nonterminal strings used for displaying \n"
"  -Gp  do not generate the production strings used for displaying \n"
"  -Gs  do not generate action strings used for displaying \n"
"  -Gt  do not generate terminal strings used for displaying \n"
"  -Gu  do not generate unique names for duplicate EBNF nonterminals \n"
"  -i   ignore non-fatal warnings \n"
"  -j   generate java code \n"
"  -js  generate javascript code \n"
"  -k=<maximum k value to test for in the grammar>  default k=7 \n"
"  -l=<nonterminal name>  indirect left factor nonterminal the old way \n"
"  -Ld[=<nonterminal name>]  direct left factor nonterminal or the grammar \n"
"  -Li[=<nonterminal name>]  indirect left factor nonterminal or the grammar \n"
"  -[LA]LR  LALR or LR grammar, (LRS for SLR grammar) \n"
"  -m   conserve memory by reusing internal structures \n"
"  -n=<name of the parser>  default is Slk, must be length 3 \n"
"  -ns=<namespace or package name>  default is no namespace \n"
"  -O[=<n>]  only analyze conflict number n ( -1 = don't show conflict numbers )\n"
"  -o[=<n>]  only analyze the nth conflict at each level above level 1\n"
"  -Ps=<parse stack size>   size in the generated parse routine, default=512 \n"
"  -q   quiet mode operation \n"
"  -Rd  remove duplicate productions \n"
"  -Rr[=<nonterminal name>]  remove left recursion \n"
"  -Ru[=<nonterminal name>]  remove unused nonterminals \n"
"  -Sn[=<nonterminal name>]  substitute nonterminals for equivalent ones \n"
"  -St[=<nonterminal name>]  substitute terminals for equivalent nonterminals \n"
"  -Tl=<filename>   load token strings from a file \n"
"  -Tw=<filename>   write token strings to a file \n"
"  -t[=<n>]  set grammar transformations trace level to n for debugging only \n"
"            ( no =<n> sets t=1, ( 2, 3, 4 ) ) \n"
"  -v[=<n>]  set verbose output level to n ( no =<n> sets v=1, ( 2, 3 ) ) \n"
"  -Xo  eXpand opt/_opt symbols in an LR grammar to reduce conflicts \n"
"  -y[s]  yacc style scanner is used, s=strip out all actions \n";
static char*
l318 =
"  -t=-1 -Df to display nonterminal follows for LL debugging \n"
"  -t=-1 to display LR states during build for debugging \n"
"  -t=-2,-3,-4 to display resolve config sets for debugging \n";
static int
l319(char* l75)
{
    register FILE* l320;
    char l321[1024];
    int l322 = 0,
        l10,
        l323 = 0,
        l324 = 0;
    char l325;
    l46* l126;
    register char* l326,
        * l327;
    l320 = fopen(l75, "r");
    if (!l320) {
        perror(l75);
        l323 = 1;
        return l323;
    }
    l326 = l327 = l321;
    *l326 = '\0';
    for (;;) {
        switch (*l326) {
        case '\0':
        case '\n':
        case '\r':
            l324 = NULL == fgets(l321, 1024, l320);
            ++l322;
            if (l324) {
                break;
            }
            l326 = l327 = l321;
            break;
        case ' ':
        case '\t':
            l326 = ++l327;
            break;
        case '/':
            if (*(l326 + 1) == '/') {
                *l326 = '\0';
                break;
            }
        default:
            while (*l327 && !(*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f')) {
                ++l327;
            }
            l325 = *l327;
            *l327 = '\0';
            l126 = l66(l326);
            if (l126) {
                printf("%s: %u: %s: cannot redefine name \n", l75,
                    l322, l326);
                *l327 = l325;
                l323 = 1;
                break;
            }
            else {
                l126 = l67(2, 0, l326);
                *l327 = l325;
                while (*l327 && (*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f')) {
                    ++l327;
                }
                l10 = atoi(l327);
                if (l10) {
                    l126->l10 = l10;
                }
                else {
                    l323 = 1;
                    break;
                }
                l171(l126);
                *l326 = '\0';
            }
        }
        if (l323 || l324) {
            break;
        }
    }
    if (l323) {
        printf("%s: %u: syntax error \n", l75, l322);
    }
    fclose(l320);
    return l323;
}
static FILE*
l328(char* l75)
{
    register l46** l244 = l144;
    FILE* l320;
    l320 = fopen(l75, "w");
    if (l320) {
        fprintf(l320, "\n// %s - token strings file "
            "generated by the SLK parser generator \n\n",
            l75);
        while (*++l244) {
            fprintf(l320, "%32s  %8u\n", (*l244)->l11, (*l244)->l10);
        }
    }
    else {
        perror(l75);
    }
    if (l320) {
        fclose(l320);
    }
    return l320;
}
static char*
l329(char* l330)
{
    register char* l331;
    char* l332;
    int l333 = 4;
    int l334 = 0;
    int l335;
    FILE* l336, * l88;
    static int l337 = 0;
    static char l296[128];
    static char l321[1024];
    l336 = fopen(l330, "r");
    if (!l336) {
        perror(l330);
        return NULL;
    }
    sprintf(l296, "%s.%u", l330, ++l337);
    l88 = fopen(l296, "w");
    if (!l88) {
        perror(l296);
        return NULL;
    }
    while (fgets(l321, 1024, l336)) {
        l331 = strstr(l321, "_opt");
        l333 = 4;
        if (!l331) {
            l331 = strstr(l321, "opt");
            l333 = 3;
        }
        if (!l331 || l331 == l321) {
            fputs(l321, l88);
            continue;
        }
        l332 = l331 + l333;
        if (*l332) {
            if (!(*l332 == ' ' || *l332 == '\n' || *l332 == '\r' || *l332 == '\t' || *l332 == '\v' || *l332 == '\f')) {
                fputs(l321, l88);
                continue;
            }
        }
        if ((*(l331 - 1) == ' ' || *(l331 - 1) == '\n' || *(l331 - 1) == '\r' || *(l331 - 1) == '\t' || *(l331 - 1) == '\v' || *(l331 - 1) == '\f')) {
            fputs(l321, l88);
            continue;
        }
        l334 = 1;
        strcpy(l331, l332);
        fputs(l321, l88);
        l332 = l331;
        for (--l331; l331 > l321; --l331) {
            if ((*l331 == ' ' || *l331 == '\n' || *l331 == '\r' || *l331 == '\t' || *l331 == '\v' || *l331 == '\f')) {
                break;
            }
        }
        strcpy(l331, l332);
        l335 = 1;
        for (l331 = l321; *l331; ++l331) {
            if (!(*l331 == ' ' || *l331 == '\n' || *l331 == '\r' || *l331 == '\t' || *l331 == '\v' || *l331 == '\f')) {
                l335 = 0;
            }
        }
        if (l335) {
            strcpy(l321, "    _epsilon_\n");
        }
        fputs(l321, l88);
    }
    fclose(l336);
    fclose(l88);
    if (l334 && l337 < 19) {
        return l296;
    }
    else {
        return NULL;
    }
}
int cmain(int l338,
    char* l339[])
{
    register char* l340;
    register int l76 = (0x00004000);
    char* l341,
        * l330 = NULL,
        * l296 = NULL;
    size_t l122;
    l3 l85 = (0x00000100 | 0x00000001 | 0x00000010 | 0x00000004 | 0x00000020 | 0x00000040 | 0x00000080),
        l342,
        l105 = 0,
        l106 = 0,
        l94 = 1,
        l288 = 0,
        l95 = 0,
        l96 = 0,
        l343 = 1,
        l185 = 0,
        l129 = 0x00020000,
        l344 = 0,
        l345 = 0,
        l346 = 0;
    int (*l347)(void) = NULL;
    char* l348 = NULL,
        * l349 = NULL,
        * l350 = NULL,
        * l351 = NULL,
        * l352 = NULL,
        * l353 = NULL,
        * l354 = NULL,
        * l84 = NULL,
        l355 = '\0',
        * l356 = NULL,
        * l357 = NULL;
    static char l83[16] = "Slk";
    puts(l316);
    while (--l338 > 0) {
        l340 = *++l339;
        switch (*l340) {
        case '-':
            if (*++l340) {
                switch (*l340) {
                case 'a':
                    if (l85) {
                        l85 |= 0x00000002;
                    }
                    break;
                case 'b':
                    l50 = 1;
                    break;
                case 'c':
                    if (l85) {
                        if (*++l340 == 'c') {
                            l85 &= ~(0x00000100 | 0x00001000 | 0x00000200 | 0x00000400 | 0x00000800 | 0x00002000);
                            l85 |= 0x00001000;
                        }
                        else if (*l340 == 's') {
                            l85 &= ~(0x00000100 | 0x00001000 | 0x00000200 | 0x00000400 | 0x00000800 | 0x00002000);
                            l85 |= 0x00000800;
                        }
                        else {
                            l85 &= ~0x00000001;
                        }
                    }
                    break;
                case 'C':
                    if (*++l340 == 'r') {
                        l343 = 0;
                        l85 &= ~0x00000004;
                        l85 &= ~0x00000001;
                    }
                    else if (*l340 == '+' && *++l340 == '+') {
                        if (l85) {
                            l85 &= ~(0x00000100 | 0x00001000 | 0x00000200 | 0x00000400 | 0x00000800 | 0x00002000);
                            l85 |= 0x00000200;
                        }
                    }
                    break;
                case 'd':
                    if (*++l340 == 'o' && *++l340 == 't') {
                        l56 = "";
                    }
                    else {
                        l76 |= 0x00000004;
                    }
                    break;
                case 'D':
                    if (*++l340) {
                        switch (*l340) {
                        case 'a':
                            l346 |= -1;
                            break;
                        case 'c':
                            l346 |= 0x00000100;
                            break;
                        case 'd':
                            l346 |= 0x00000080;
                            if (*++l340 && *++l340) {
                                l348 = l340;
                            }
                            break;
                        case 'e':
                            l346 |= 0x00000001;
                            break;
                        case 'f':
                            l346 |= 0x00000020;
                            l346 |= 0x00000040;
                            break;
                        case 'l':
                            l346 |= 0x00000200;
                            break;
                        case 'p':
                            l346 |= 0x00000010;
                            l346 |= 0x00000002;
                            break;
                        case 'r':
                            l346 |= 0x00000400;
                            break;
                        case 's':
                            l346 |= 0x00000004;
                            break;
                        case 't':
                            l346 |= 0x00000008;
                            break;
                        default:
                            l76 |= 0x00000001;
                            printf("invalid option, %s\n", *l339);
                        }
                    }
                    break;
                case 'E':
                    l355 = *++l340;
                    switch (*l340) {
                    case '1':
                    case '2':
                        l355 = *l340;
                        break;
                    default:
                        l76 |= 0x00000001;
                        printf("invalid option, %s\n", *l339);
                    }
                    break;
                case 'e':
                    l76 &= ~0x00004000;
                    break;
                case 'f':
                    l296 = "";
                    if (*++l340 && *++l340) {
                        l296 = l340;
                    }
                    break;
                case 'F':
                    if (*++l340) {
                        switch (*l340) {
                        case 'a':
                            l76 |= 0x00008000;
                            break;
                        default:
                            l76 |= 0x00000001;
                            printf("invalid option, %s\n", *l339);
                        }
                    }
                    break;
                case 'g':
                    l344 = 1;
                    break;
                case 'G':
                    while (*++l340) {
                        switch (*l340) {
                        case 'a':
                            l85 = 0;
                            break;
                        case 'c':
                            l85 &= ~0x00000004;
                            l85 &= ~0x00000001;
                            break;
                        case 'd':
                            if (l85) {
                                l85 |= 0x00100000;
                            }
                            break;
                        case 'n':
                            l85 &= ~0x00000010;
                            break;
                        case 'p':
                            l85 &= ~0x00000080;
                            break;
                        case 's':
                            l85 &= ~0x00000040;
                            break;
                        case 't':
                            l85 &= ~0x00000020;
                            break;
                        case 'u':
                            l53 = 0;
                            break;
                        default:
                            l76 |= 0x00000001;
                            printf("invalid option, %s\n", *l339);
                        }
                    }
                    break;
                case 'i':
                    l288 = 1;
                    break;
                case 'j':
                    if (l85) {
                        l85 &= ~(0x00000100 | 0x00001000 | 0x00000200 | 0x00000400 | 0x00000800 | 0x00002000);
                        if (*++l340 == 's') {
                            l85 |= 0x00002000;
                        }
                        else {
                            l85 |= 0x00000400;
                        }
                    }
                    break;
                case 'k':
                    if (*++l340 && *++l340) {
                        l219 = atoi(l340);
                    }
                    break;
                case 'l':
                    l76 |= 0x00000400;
                    if (*++l340 && *++l340) {
                        l352 = l340;
                    }
                    break;
                case 'L':
                    if (*++l340) {
                        switch (*l340) {
                        case 'd':
                            l76 |= 0x00000200;
                            if (*++l340 && *++l340) {
                                l350 = l340;
                            }
                            break;
                        case 'i':
                            l76 |= 0x00000100;
                            if (*++l340 && *++l340) {
                                l351 = l340;
                            }
                            break;
                        case 'A':
                            l185 = 1;
                            l343 = 0;
                            l53 = 0;
                            if (l85) {
                                l85 &= ~0x00000004;
                                l85 |= 0x00000008;
                            }
                            if (*++l340 && *++l340) {
                                l129 = 0x00020000;
                            }
                            else {
                                l76 |= 0x00000001;
                                printf("invalid option, %s\n", *l339);
                            }
                            break;
                        case 'R':
                            l129 = 0x00040000;
                            l185 = 1;
                            l343 = 0;
                            l53 = 0;
                            if (l85) {
                                l85 &= ~0x00000004;
                                l85 |= 0x00000008;
                            }
                            if (*++l340 == 'S') {
                                l129 = 0x00010000;
                            }
                            break;
                        default:
                            l76 |= 0x00000001;
                            printf("invalid option, %s\n", *l339);
                        }
                    }
                    break;
                case 'm':
                    l54 = 1;
                    break;
                case 'n':
                    if (*++l340) {
                        if (*l340 == 's') {
                            if (*++l340 && *++l340) {
                                l84 = l340;
                            }
                        }
                        else {
                            if (*l340 && *++l340) {
                                l342 = strlen(l340);
                                if (l342 != 3) {
                                    l76 |= 0x00000001;
                                    puts("-n option length not = 3");
                                    break;
                                }
                                strcpy(l83, l340);
                            }
                        }
                    }
                    break;
                case 'O':
                    l95 = 1;
                    if (*++l340 && *++l340) {
                        l95 = atoi(l340);
                        if (l95 == -1) {
                            l95 = 0;
                            l94 = 0;
                        }
                    }
                    break;
                case 'o':
                    l96 = 1;
                    if (*++l340 && *++l340) {
                        l96 = atoi(l340);
                    }
                    break;
                case 'P':
                    if (*++l340) {
                        switch (*l340) {
                        case 's':
                            if (*++l340 && *++l340) {
                                l55 = atoi(l340);
                            }
                            break;
                        default:
                            l76 |= 0x00000001;
                            printf("invalid option, %s\n", *l339);
                        }
                    }
                    break;
                case 'q':
                    l52 = 1;
                    break;
                case 'R':
                    if (*++l340) {
                        switch (*l340) {
                        case 'd':
                            l76 |= 0x00000800;
                            break;
                        case 'r':
                            l76 |= 0x00000020;
                            if (*++l340 && *++l340) {
                                l349 = l340;
                            }
                            break;
                        case 'u':
                            l76 |= 0x00000080;
                            if (*++l340 && *++l340) {
                                l353 = l340;
                            }
                            break;
                        default:
                            l76 |= 0x00000001;
                            printf("invalid option, %s\n", *l339);
                        }
                    }
                    break;
                case 'S':
                    if (*++l340) {
                        switch (*l340) {
                        case 'n':
                            l76 |= 0x00000040;
                            l105 = 1;
                            if (*++l340 && *++l340) {
                                l354 = l340;
                            }
                            break;
                        case 't':
                            l76 |= 0x00000040;
                            l106 = 1;
                            if (*++l340 && *++l340) {
                                l354 = l340;
                            }
                            break;
                        default:
                            l76 |= 0x00000001;
                            printf("invalid option, %s\n", *l339);
                        }
                    }
                    break;
                case 'T':
                    if (*++l340) {
                        switch (*l340) {
                        case 'l':
                            if (*++l340 && *++l340) {
                                l76 |= 0x00002000;
                                l357 = l340;
                            }
                            else {
                                printf("no load tokens filename given\n");
                            }
                            break;
                        case 'w':
                            if (*++l340 && *++l340) {
                                l76 |= 0x00001000;
                                l356 = l340;
                            }
                            else {
                                printf("no write tokens filename given\n");
                            }
                            break;
                        default:
                            l76 |= 0x00000001;
                            printf("invalid option, %s\n", *l339);
                        }
                    }
                    break;
                case 't':
                    l48 = 1;
                    if (*++l340 && *++l340) {
                        l48 = atoi(l340);
                    }
                    break;
                case 'u':
                    break;
                case 'v':
                    l49 = 1;
                    if (*++l340 && *++l340) {
                        l49 = atoi(l340);
                    }
                    break;
                case 'X':
                    if (*++l340) {
                        switch (*l340) {
                        case 'o':
                            l345 = 1;
                            break;
                        default:
                            l76 |= 0x00000001;
                            printf("invalid option, %s\n", *l339);
                        }
                    }
                    break;
                case 'y':
                    l76 |= 0x00000010;
                    l76 &= ~0x00004000;
                    if (*++l340 == 's') {
                        l76 |= 0x00000008;
                    }
                    break;
                default:
                    l76 |= 0x00000001;
                    printf("invalid option, %s\n", *l339);
                }
            }
            break;
        default:
            l330 = l340;
        }
    }
    if (!l343) {
        l76 &= ~(0x00000020 | 0x00000400 | 0x00000100 | 0x00000200);
        l51 = 0;
    }
    if ((l76 & 0x00000001) || !l330) {
        fputs(l317, stdout);
        ;
        ;
        exit(1);
    }
    if (l345) {
        char* l75 = l330;
        char* l358 = l330;
        char l359[128];
        while (l75 = l329(l75)) {
            l358 = l75;
        }
        if (l296 && *l296) {
            sprintf(l359, "copy %s %s\n", l358, l296);
            system(l359);
        }
        return 0;
    }
    if (l355) {
        if (!l296) {
            puts("output filename was not specified, use -f=filename");
            exit(1);
        }
        switch (l355) {
        case '1':
            l315 = l119(l330, l296);
            break;
        case '2':
            l315 = l116(l330, l296);
            break;
        }
        return l315;
    }
    l341 = l120(l330, &l122);
    if (!l341) {
        perror(l330);
        exit(1);
    }
    l347 = l74(l341, l76);
    if (!l347) {
        return -1;
    }
    if (l76 & 0x00002000) {
        if (l319(l357)) {
            return -2;
        }
    };
    ;
    l313 = 1;
    l77(l347, (l76 & 0x00000004));
    l313 = 0;
    if (!l315) {
        ;
        ;
        l315 |= l287(l288, l343);
    }
    if (l76 & 0x00000800) {
        l110();
    }
    if (l76 & 0x00000020) {
        l107(l349);
    }
    if (!l315) {
        l315 |= l158();
    }
    if (!l315) {
        if (l185) {
            l315 |= l128(l129);
        }
        else if (l343) {
            l315 |= l159();
        }
        else {
            l315 |= l251();
        }
    }
    if (l76 & 0x00000400) {
        l76 &= ~(0x00000200 | 0x00000100);
        if (!(l76 & 0x00000020)) {
            if (!l314) {
                l315 |= l113(l352);
            }
            else {
                printf("cannot left factor a left recursive grammar \n");
            }
        }
        else {
            printf("cannot left factor and remove left recursion "
                "at the same time \n");
        }
    }
    if (l76 & 0x00000200) {
        if (!(l76 & 0x00000020)) {
            if (!l314) {
                l315 |= l112(l350);
            }
            else {
                printf("cannot left factor a left recursive grammar \n");
            }
        }
        else {
            printf("cannot left factor and remove left recursion "
                "at the same time \n");
        }
    }
    if (l76 & 0x00000100) {
        if (!(l76 & 0x00000020)) {
            if (!l314) {
                l315 |= l111(l351);
            }
            else {
                printf("cannot left factor a left recursive grammar \n");
            }
        }
        else {
            printf("cannot left factor and remove left recursion "
                "at the same time \n");
        }
    }
    if (l76 & 0x00000040) {
        if (l105 || l106) {
            l104(l354,
                l105,
                l106);
        }
    }
    if (l76 & 0x00000080) {
        l103(l353);
    }
    if (l76 & (0x00000020 | 0x00000040 | 0x00000080 | 0x00000800 | 0x00000400 | 0x00000100 | 0x00000200)) {
        if (!l296) {
            puts("output filename was not specified, use -f=filename");
        }
        l315 = 1;
    }
    if (!l315) {
        l3 l263;
        l3* l97;
        l3 l360;
        if (!l52) {
            l266(l94);
        }
        l97 = calloc(l220 + 4, sizeof(l3));
        if (!l97) {
            l59(1702, "out of memory");
        }
        l97[l220 + 1] = -1;
        l263 = l93(l94, l95,
            l96, l97);
        l360 = l262(l94, l97,
            l263);
        l315 |= l360;
    }
    if (!l315 || l344) {
        printf("\n\t total nonterminals   = %d\n", l147);
        if (l152) {
            printf("\t       conditionals   = %d\n",
                l152);
        }
        printf("\t total terminals      = %d\n", l148);
        printf("\t total productions    = %d\n", l150);
        if (l185) {
            printf("\t total states         = %d\n", l58);
            printf("\t parse table size     = %d\n",
                l58 * (l147 + l148));
        }
        else {
            printf("\t parse table size     = %d\n",
                l147 * l148);
        }
        if (l151) {
            printf("\t ignored conflicts    = %d\n", l151);
        }
        if (l220) {
            printf("\t total base conflicts = %d\n", l220);
            printf("\t total conflicts      = %d\n", l221);
            printf("\t conflict table size  = %d\n",
                l221 * l148);
        }
        putchar('\n');
    }
    if (l346 & 0x00000200) {
        l265(l94);
    }
    if (l346 & 0x00000010) {
        l186();
    }
    if (l346 & 0x00000400) {
        l135(l129 == 0x00010000);
    }
    if (l346 & 0x00000008) {
        l184(l185);
        l284();
    }
    if (l346 & 0x00000020) {
        l311();
        l180();
    }
    if (l346 & 0x00000040) {
        if (l48 == -1) {
            l312();
        }
        l181();
    }
    if (l346 & 0x00000001) {
        l183();
    }
    if (l346 & 0x00000002) {
        l187();
    }
    if (l346 & 0x00000100) {
        l285();
    }
    if (l346 & 0x00000080) {
        l101(l348);
    }
    if (l346 & 0x00000004) {
        l68();
    }
    if (l76 & 0x00001000) {
        l328(l356);
    }
    if (l296) {
        l85 = 0;
        if (l76 & 0x00004000) {
            l115();
        }
        printf("rewriting the grammar\n");
        l295(l296, (l76 & 0x00004000));
    }
    if (l85) {
        if (!l315) {
            printf("generating the parser\n");
            l82(l83, l84, l85,
                l76);
        }
        else if (l344) {
            printf("warning: error detected, generating the parser anyway\n");
            l82(l83, l84, l85,
                l76);
            l315 = 0;
        }
    }
    return l315;
}
void l59(int l60,
    char* l61)
{
    if (l313) {
        fprintf(stdout, "%u: ", l69());
    }
    fprintf(stdout, "error %u: %s\n", l60, l61);
    exit(1);
}
void l62(void)
{
    l314 = 1;
}
void l63(void)
{
    ++l315;
}
static l286* l361 = NULL;
static l3 l362 = 0;
static l286*
l363(void)
{
    register l286* l364 = l361;
    if (l364) {
        l361 = l364->l8;
        memset(l364, 0, sizeof(l286));
        ++l362;
    }
    return l364;
}
static l286*
l365(void)
{
    register l286* l364;
    static int l366 = 0;
    static l286* l367;
    if (--l366 > 0) {
        ++l367;
        l364 = l367;
    }
    else {
        l366 = 0;
        l364 = l363();
        if (!l364) {
            l366 = 1024;
            l367 = (l286*)calloc(l366, sizeof(l286));
            l364 = l367;
            if (!l364) {
                l366 = 0;
                l59(2101, "out of memory");
            }
        }
    }
    return l364;
}
static l3
l368(void)
{
    register l46*** l367,
        ** l179 = l143;
    l3 l369 = 0,
        l370;
    while (*++l179) {
        l367 = l146;
        (*l179)->l28 = 0;
        l370 = 1;
        while (*++l367) {
            if (**l367 == *l179) {
                l370 = 0;
                break;
            }
        }
        if (l370) {
            l369 = 1;
            (*l179)->l28 = 1;
        }
    }
    return l369;
}
static l3
l371(void)
{
    register l46*** l367,
        ** l177;
    l46* l170,
        * l372,
        ** l179 = l143;
    l3 l373 = 0,
        l24,
        l43;
    l143[1]->l41 = 1;
    while (*++l179) {
        l367 = l146;
        (*l179)->l43 = 0;
        l43 = 0;
        l24 = 0;
        while (*++l367) {
            l170 = **l367;
            if (l170 != *l179) {
                continue;
            }
            if (++l24 > 1) {
                break;
            }
            l177 = *l367;
            if (*++l177) {
                if ((*l177)->l9 != 3) {
                    if (!*++l177) {
                        if ((*l179)->l41) {
                            l372 = *(l177 - 1);
                        }
                        l43 = 1;
                    }
                }
            }
        }
        if (l43 && l24 == 1) {
            if ((*l179)->l41) {
                l372->l41 = 1;
            }
            else {
                l373 = 1;
                (*l179)->l43 = 1;
            }
        }
    }
    return l373;
}
static void
l374(void)
{
    register l46*** l367,
        ** l177;
    l46* l170,
        ** l179 = l143;
    l3 l43;
    while (*++l179) {
        l367 = l146;
        (*l179)->l42 = 0;
        l43 = 0;
        while (*++l367) {
            l170 = **l367;
            if (l170 != *l179) {
                continue;
            }
            l177 = *l367;
            if (*++l177) {
                if ((*l177)->l9 == 2) {
                    if (!*++l177) {
                        l43 = 1;
                    }
                    else if ((*l177)->l9 == 3) {
                        if (!*++l177) {
                            l43 = 1;
                        }
                    }
                }
            }
        }
        if (l43) {
            (*l179)->l42 = 1;
        }
    }
}
static struct
{
    l46** l375,
        * l376[127 + 1];
} l377 = { l377.l376 + 127 };
static l3
l378(register l46* l179)
{
    register l46** l379 = l377.l375;
    while (*l379) {
        if (*l379++ == l179) {
            return 0;
        }
    }
    return 1;
}
static l3
l34(l46* l99,
    l46* l100,
    l3 l79)
{
    register l46** l126,
        *** l367;
    l46* l170;
    l3 l380 = 0;
    for (l367 = l146; *++l367;) {
        l126 = *l367;
        l170 = *l126;
        if (l170 == l100) {
            while (*++l126) {
                if ((*l126)->l9 == 1) {
                    if (*l126 == l99) {
                        l380 = 1;
                        break;
                    }
                    if ((*l126)->l34) {
                        l380 = 1;
                        break;
                    }
                    if (l378(*l126)) {
                        if (l377.l375 > l377.l376)
                            *--l377.l375 = *l126;
                        else
                            l59(2102, "stack overflow");
                        l380 = l34(
                            l99,
                            *l126, l79);
                        if (*l377.l375)
                            l377.l375++;
                        ;
                    }
                    else {
                        l380 = 1;
                    }
                    if (l380) {
                        break;
                    }
                }
            }
        }
        if (l380) {
            if (l79 && l49 < -2) {
                l188("   ", *l367);
            }
            break;
        }
    }
    return l380;
}
static void
l381(l3 l79)
{
    register l46** l179;
    l3 l380,
        l382;
    for (l382 = 1; l382;) {
        l382 = 0;
        for (l179 = l143; *++l179;) {
            if ((*l179)->l34) {
                continue;
            }
            l380 = l34(*l179, *l179,
                l79);
            if (l380 && !(*l179)->l34) {
                (*l179)->l34 = 1;
                l382 = 1;
                if (l79 && l49 < -1) {
                    printf("  %s:  has infinite derivations \n",
                        (*l179)->l11);
                    if (l49 < -2) {
                        putchar('\n');
                    }
                }
            }
        }
    }
    if (l79 && l49 < -1) {
        putchar('\n');
    }
}
static l3
l383(int l79,
    l46* l179)
{
    register l46*** l384 = l146,
        *** l385;
    l46** l386,
        ** l387,
        * l388 = NULL,
        * l170;
    l3 l389,
        l32 = 0;
    while (*++l384) {
        l170 = **l384;
        if (l179 && l179 != l170) {
            continue;
        }
        l385 = l384;
        while (*++l385) {
            if (**l385 != l170) {
                break;
            }
            if ((*l385)[1] == l170) {
                continue;
            }
            l386 = *l384;
            l387 = *l385;
            ++l386;
            ++l387;
            l389 = 0;
            for (; *l386 && *l386 == *l387; ++l386, ++l387) {
                if ((*l386)->l9 == 3) {
                    continue;
                }
                if ((*l386)->l9 == 2) {
                    continue;
                }
                l389 = 1;
            }
            if (l389) {
                l389 = 0;
                l386 = *l385;
                ++l386;
                for (; l386 < l387; ++l386) {
                    if (*l386 && (*l386)->l34) {
                        l170->l32 = 1;
                        l32 = 1;
                        if (l79) {
                            if (l388 != l170) {
                                l388 = l170;
                                printf("  %s:  needs direct left factoring \n",
                                    l170->l11);
                            }
                            if (l49 > 0) {
                                l188("   ", *l384);
                                l188("   ", *l385);
                                putchar('\n');
                            }
                        }
                        break;
                    }
                }
            }
        }
    }
    return l32;
}
static l3
l390(int l79)
{
    register l46*** l384 = l146,
        *** l385;
    l46** l386,
        ** l387,
        * l388 = NULL,
        * l126,
        * l170;
    l3 l389 = 0;
    while (*++l384) {
        l170 = **l384;
        if ((*l384)[1] == l170) {
            continue;
        }
        l385 = l384;
        while (*++l385) {
            if (**l385 != l170) {
                break;
            }
            if (l170->l45) {
                continue;
            }
            if (l170->l35) {
                continue;
            }
            if (l170->l32) {
                continue;
            }
            if ((*l385)[1] == l170) {
                continue;
            }
            l386 = *l384;
            l387 = *l385;
            for (++l386, ++l387; *l386 && *l387;) {
                if (*l386 && (*l386)->l9 == 3) {
                    ++l386;
                    continue;
                }
                if (*l387 && (*l387)->l9 == 3) {
                    ++l387;
                    continue;
                }
                if (*l386 == *l387) {
                    ++l386;
                    ++l387;
                    continue;
                }
                l126 = l308((*l386)->l17,
                    (*l387)->l17);
                if (l126) {
                    l389 = 1;
                    l170->l33 = 1;
                    if (l79) {
                        if (l388 != l170) {
                            l388 = l170;
                            printf("  %s:  needs indirect left factoring \n",
                                l170->l11);
                        }
                        if (l49 > 0) {
                            printf("  '%s' "
                                "in '%s' and '%s' \n",
                                l126->l11, (*l386)->l11, (*l387)->l11);
                        }
                        if (l49 > 1) {
                            l98(l126, *l386, 1);
                        }
                        if (l49 > 0) {
                            l188("   ", *l384);
                        }
                        if (l49 > 1) {
                            putchar('\n');
                            l98(l126, *l387, 1);
                        }
                        if (l49 > 0) {
                            l188("   ", *l385);
                            putchar('\n');
                        }
                    }
                    break;
                }
                if ((*l386)->l26) {
                    ++l386;
                    continue;
                }
                if ((*l387)->l26) {
                    ++l387;
                    continue;
                }
                break;
            }
        }
    }
    return l389;
}
static l3
l391(void)
{
    l3 l389,
        l33;
    l389 = l383(1, NULL);
    if (l389) {
        putchar('\n');
    }
    l33 = l390(1);
    l389 |= l33;
    if (l33) {
        putchar('\n');
    }
    return l389;
}
static l3
l392(void)
{
    register l46** l179 = l143;
    l3 l369 = 0;
    l368();
    while (*++l179) {
        if ((*l179)->l28) {
            l369 = 1;
            printf("  %s: undefined \n", (*l179)->l11);
        }
    }
    if (l369) {
        putchar('\n');
    }
    return l369;
}
static l3
l393(void)
{
    register l46*** l367 = l146,
        ** l177;
    l46* l170;
    l3 l373 = 0;
    char* l394;
    l371();
    while (*++l367) {
        l177 = *l367;
        l170 = *l177;
        if (l170->l43) {
            if (*++l177) {
                l394 = (*l177)->l11;
            }
            else {
                l394 = "";
            }
            l373 = 1;
            if (l49 > 2) {
                printf("  %s: equivalent to %s \n", l170->l11, l394);
            }
        }
    }
    if (l373) {
        if (l49 > 0) {
            putchar('\n');
        }
    }
    return l373;
}
static l3
l395(void)
{
    register l46** l179 = l143 + 1;
    l3 l396 = 0;
    l294();
    while (*++l179) {
        if ((*l179)->l29) {
            l396 = 1;
            printf("  %s: unused \n", (*l179)->l11);
        }
    }
    if (l396) {
        putchar('\n');
    }
    return l396;
}
static l3
l397(void)
{
    register l46** l179;
    l3 l398 = 0;
    for (l179 = l143; *++l179;) {
        if ((*l179)->l30) {
            continue;
        }
        if ((*l179)->l31) {
            continue;
        }
        if (l98(*l179, *l179, 0)) {
            if (l49 > 0) {
                printf("  %s: indirect left recursive: was missed\n",
                    (*l179)->l11);
                l98(*l179, *l179, 1);
                putchar('\n');
            }
            (*l179)->l31 = 1;
            l62();
            l398 = 1;
        }
    }
    return l398;
}
static l3
l399(void)
{
    register l46** l179;
    l3 l398 = 0;
    l397();
    for (l179 = l143; *++l179;) {
        if ((*l179)->l30) {
            printf("  %s:  direct left recursion\n", (*l179)->l11);
            l398 = 1;
        }
    }
    if (l398) {
        putchar('\n');
    }
    for (l179 = l143; *++l179;) {
        if ((*l179)->l31) {
            printf("  %s:  indirect left recursion\n", (*l179)->l11);
            l398 = 1;
        }
    }
    if (l398) {
        putchar('\n');
    }
    return l398;
}
static l3
l400(register l46** l177)
{
    for (; *l177; ++l177) {
        if ((*l177)->l9 == 3) {
            continue;
        }
        if (!(*l177)->l26) {
            break;
        }
    }
    return (*l177 == NULL);
}
static l3
l401(void)
{
    register l46*** l367 = l146,
        ** l177;
    l46* l170;
    l46** l402 = NULL,
        ** l403 = NULL;
    l3 l404 = 0;
    while (*++l367) {
        l177 = *l367;
        l170 = *l177;
        if (l170->l26) {
            if (l400(l177 + 1)) {
                l402 = l177;
                while (*++l367) {
                    l177 = *l367;
                    if (*l177 != l170) {
                        --l367;
                        break;
                    }
                    if (l400(l177 + 1)) {
                        l403 = l177;
                        l404 = 1;
                        if (l402) {
                            printf("  %s: multiple nullable productions \n",
                                (*l402)->l11);
                            l188("   ", l402);
                            l402 = NULL;
                        }
                        l188("   ", l403);
                    }
                }
                if (!*l367) {
                    break;
                }
            }
        }
    }
    if (l404) {
        putchar('\n');
    }
    return l404;
}
static void
l405(void)
{
    register l46** l126,
        * l170;
    l46*** l367;
    int l382;
    for (l126 = l143; *++l126;) {
        l300(&(*l126)->l17, *l126);
    }
    for (l382 = 1; l382;) {
        l382 = 0;
        l367 = l146;
        while (*++l367) {
            l126 = *l367;
            l170 = *l126;
            while (*++l126) {
                if ((*l126)->l9 == 3) {
                    continue;
                }
                if ((*l126)->l9 == 1) {
                    l382 |= l301(&l170->l17,
                        (*l126)->l17);
                }
                if (!(*l126)->l26) {
                    break;
                }
            }
        }
    }
}
l3 l287(l3 l288,
    l3 l343)
{
    l3 l369,
        l398 = 0,
        l389 = 0,
        l406,
        l404 = 0,
        l407 = 0,
        l396;
    l369 = l392();
    l396 = l395();
    l393();
    l374();
    l406 = l109();
    if (l343) {
        l405();
        l381(1);
        l389 = l391();
        l398 = l399();
        if (!(l398 || l389)) {
            l404 = l401();
            l407 = l108();
        }
    }
    if (l288) {
        l389 = 0;
        l396 = 0;
        l407 = 0;
        l404 = 0;
    }
    return (l407 || l406 || l369 || l396 ||
        l389 || l398 || l404);
}
l3 l290(int l79,
    l46* l179)
{
    l3 l389;
    l179->l32 = 0;
    l389 = l383(l79,
        l179);
    return l389;
}
l3 l291(int l79)
{
    register l46** l179;
    l3 l389;
    for (l179 = l143; *++l179;) {
        (*l179)->l32 = 0;
    }
    l389 = l383(l79, NULL);
    return l389;
}
l3 l292(int l79)
{
    register l46** l179;
    l3 l389;
    for (l179 = l143; *++l179;) {
        (*l179)->l33 = 0;
    }
    l389 = l390(l79);
    return l389;
}
l3 l293(void)
{
    register l46** l179;
    l3 l389;
    for (l179 = l143; *++l179;) {
        (*l179)->l32 = 0;
        (*l179)->l33 = 0;
    }
    l389 = l383(0, NULL);
    l389 |= l390(0);
    return l389;
}
l3 l294(void)
{
    register l46*** l367,
        ** l177,
        ** l179 = l143 + 1;
    l3 l396 = 0,
        l408;
    while (*++l179) {
        l367 = l146;
        (*l179)->l29 = 0;
        l408 = 1;
        while (*++l367) {
            l177 = *l367;
            while (*++l177) {
                if (*l177 == *l179) {
                    if (**l367 != *l177) {
                        l408 = 0;
                        break;
                    }
                }
            }
            if (l408 == 0) {
                break;
            }
        }
        if (l408) {
            l396 = 1;
            (*l179)->l29 = 1;
        }
    }
    return l396;
}
static char*
l409(char* l125,
    char* l410)
{
    register char* l124 = NULL,
        * l327;
    l3 l411,
        l412,
        l413 = 0;
    static char l414[128];
    l411 = strlen(l125);
    l412 = strlen(l410);
    if (l412 > l411) {
        if (l412 < sizeof(l414) - 2) {
            strcpy(l414, l410);
            l327 = l410;
            while (*l327) {
                ++l327;
            }
            l327 -= l411;
            for (; *l327 && *l125; ++l327, ++l125) {
                l413 = 1;
                if ((((*l327 >= 'a' && *l327 <= 'z')) ? (*l327 - ('a' - 'A')) : *l327) != (((*l125 >= 'a' && *l125 <= 'z')) ? (*l125 - ('a' - 'A')) : *l125)) {
                    l413 = 0;
                    break;
                }
            }
            if (l413) {
                l327 = l414 + l412 - l411;
                *l327 = '\0';
                if (*--l327 == '_') {
                    *l327 = '\0';
                }
                l124 = l414;
            }
        }
    }
    return l124;
}
static char*
l415(char* l125,
    char* l410)
{
    register char* l416 = NULL,
        * l327;
    l3 l411,
        l412,
        l413 = 0;
    static char l414[128];
    l411 = strlen(l125);
    l412 = strlen(l410);
    if (l412 > l411) {
        if (l412 < sizeof(l414) - 2) {
            strcpy(l414, l410);
            l327 = l410;
            while (*l327) {
                ++l327;
            }
            l327 -= l411;
            for (; *l327 && *l125; ++l327, ++l125) {
                l413 = 1;
                if (*l327 != *l125) {
                    l413 = 0;
                    break;
                }
            }
            if (l413) {
                l327 = l414 + l412 - l411;
                *l327 = '\0';
                l416 = l414;
            }
        }
    }
    return l416;
}
static void
l417(FILE* l320)
{
    register l46** l244;
    l46* l126;
    char* l416;
    l3 l418 = 0;
    char l419[128];
    for (l244 = l144; *++l244;) {
        l416 = l415("_+", (*l244)->l11);
        if (l416) {
            if (!l418) {
                l418 = 1;
                fprintf(l320, "\n//\n// Automatically generated regexp"
                    " productions. Some may be wrong.\n//\n\n");
            }
            strncpy(l419, l416, sizeof(l419) - 4);
            strcat(l419, "_*");
            l126 = l66(l419);
            if (!l126) {
                fprintf(l320, "%s :\n", l419);
                fprintf(l320, "    %s %s\n", l416, l419);
                fprintf(l320, "    %s\n\n", "_epsilon_");
            }
            fprintf(l320, "%s :\n", (*l244)->l11);
            fprintf(l320, "    %s %s\n\n", l416, l419);
            printf("warning: generating a production for %s\n",
                (*l244)->l11);
        }
    }
    for (l244 = l144; *++l244;) {
        l416 = l415("_*", (*l244)->l11);
        if (l416) {
            if (!l418) {
                l418 = 1;
                fprintf(l320, "\n//\n// Automatically generated regexp"
                    " productions. Some may be wrong.\n//\n\n");
            }
            fprintf(l320, "%s :\n", (*l244)->l11);
            fprintf(l320, "    %s %s\n", l416, (*l244)->l11);
            fprintf(l320, "    %s\n\n", "_epsilon_");
            printf("  generating a production for %s\n", (*l244)->l11);
        }
    }
    if (l418) {
        fprintf(l320, "\n//\n// End of Automatically generated regexp"
            " productions.\n//\n\n");
    }
}
static void
l420(FILE* l320)
{
    register l46** l244;
    char* l416;
    l3 l418 = 0;
    for (l244 = l144; *++l244;) {
        l416 = l409("opt", (*l244)->l11);
        if (l416) {
            if (!l418) {
                l418 = 1;
                fprintf(l320, "\n//\n// Automatically generated opt productions."
                    " Some may be wrong.\n//\n\n");
            }
            fprintf(l320, "%s :\n", (*l244)->l11);
            fprintf(l320, "    %s\n", l416);
            fprintf(l320, "    %s\n\n", "_epsilon_");
            printf("  generating a production for %s\n", (*l244)->l11);
        }
    }
    if (l418) {
        fprintf(l320, "\n//\n// End of Automatically generated opt productions."
            "\n//\n\n");
    }
}
static void
l421(FILE* l320)
{
    register l46** l244;
    char* l422;
    char* l423;
    char* l177;
    l3 l418 = 0;
    char l414[2048 + 4];
    for (l244 = l144; *++l244;) {
        l422 = strchr((*l244)->l11, '|');
        if (l422) {
            printf("  generating productions for %s\n", (*l244)->l11);
            if (!l418) {
                l418 = 1;
                fprintf(l320, "\n//\n// Automatically generated OR productions."
                    " Some may be wrong.\n//\n\n");
            }
            fprintf(l320, "%s :\n", (*l244)->l11);
            strncpy(l414, (*l244)->l11, sizeof(l414));
            l414[2048] = '\0';
            l422 = strchr(l414, '|');
            l177 = l414;
            while (l422) {
                *l422 = '\0';
                if (*l177 == '~') {
                    ++l177;
                }
                if (!*l177) {
                    break;
                }
                for (l423 = l177; *l423; ++l423) {
                    if (*l423 == '~') {
                        *l423 = ' ';
                    }
                }
                fprintf(l320, "    %s\n", l177);
                l177 = l422 + 1;
                l422 = strchr(l177, '|');
            }
            if (*l177 == '~') {
                ++l177;
            }
            if (!*l177) {
                l177 = "_epsilon_";
            }
            for (l423 = l177; *l423; ++l423) {
                if (*l423 == '~') {
                    *l423 = ' ';
                }
            }
            fprintf(l320, "    %s\n\n", l177);
        }
    }
    if (l418) {
        fprintf(l320, "\n//\n// End of Automatically generated OR productions."
            "\n//\n\n");
    }
}
static void
l424(FILE* l320)
{
    register l46** l244;
    char* l422;
    char* l201;
    char* l425;
    l3 l418 = 0;
    char l11[2048 + 4];
    for (l244 = l144; *++l244;) {
        l422 = strchr((*l244)->l11, '|');
        if (l422) {
            continue;
        }
        l425 = strrchr((*l244)->l11, '-');
        if (!l425) {
            l425 = strrchr((*l244)->l11, '_');
        }
        if (!l425) {
            continue;
        }
        l201 = l425 + 1;
        if (strcmp(l201, "list")) {
            continue;
        }
        printf("  generating productions for %s\n", (*l244)->l11);
        if (!l418) {
            l418 = 1;
            fprintf(l320, "\n//\n// Automatically generated \"list\" productions."
                " Some may be wrong.\n//\n\n");
        }
        fprintf(l320, "%s :\n", (*l244)->l11);
        strncpy(l11, (*l244)->l11, sizeof(l11));
        l11[2048] = '\0';
        l425 = strrchr(l11, '-');
        if (!l425) {
            l425 = strrchr(l11, '_');
        }
        if (!l425) {
            continue;
        }
        *l425 = '\0';
        fprintf(l320, "    %s { , %s }\n\n", l11, l11);
    }
    if (l418) {
        fprintf(l320, "\n//\n// End of Automatically generated \"list\" productions."
            "\n//\n\n");
    }
}
static l3
l426(register l46** l177)
{
    for (++l177; *l177; ++l177) {
        if ((*l177)->l9 != 3) {
            break;
        }
    }
    return (*l177 == NULL);
}
void l295(char* l296,
    int l297)
{
    register l46** l126;
    register l46*** l367 = l146;
    l46* l170 = NULL;
    FILE* l427,
        * l320 = stdout;
    char* l11;
    if (l296 && *l296) {
        l427 = fopen(l296, "w");
        if (l427) {
            l320 = l427;
        }
        else {
            perror(l296);
        }
    }
    while (*++l367) {
        l126 = *l367;
        if (l297) {
            if ((*l126)->l37) {
                continue;
            }
        }
        if (*l126 != l170) {
            if ((*l126)->l45) {
                fprintf(l320, "\n%s :?\n", (*l126)->l11);
            }
            else if ((*l126)->l35) {
                fprintf(l320, "\n%s :!\n", (*l126)->l11);
            }
            else {
                fprintf(l320, "\n%s :\n", (*l126)->l11);
            }
        }
        fprintf(l320, "   ");
        if (l426(l126)) {
            fprintf(l320, " %s", "_epsilon_");
        }
        while (*(l126 + 1) && (*(l126 + 1))->l9 == 3) {
            ++l126;
            if (l73((*l126)->l11)) {
                fprintf(l320, " %s", (*l126)->l11);
            }
            else {
                fprintf(l320, " _action_%s", (*l126)->l11);
            }
        }
        while (*++l126) {
            l11 = (*l126)->l11;
            if ((*l126)->l9 == 3) {
                if (l73(l11)) {
                    fprintf(l320, " %s", l11);
                }
                else {
                    fprintf(l320, " _action_%s", l11);
                }
            }
            else if ((*l126)->l36) {
                fprintf(l320, " %s", l11 + 1);
            }
            else if ((*l126)->l39) {
                fprintf(l320, " \\%s", l11);
            }
            else {
                fprintf(l320, " %s", l11);
            }
        }
        fprintf(l320, "\n");
        l170 = **l367;
    }
    if (!l297) {
        l417(l320);
        l420(l320);
    }
    l421(l320);
    if (l297) {
        l424(l320);
    }
    if (l296) {
        if (l427) {
            fclose(l427);
        }
    }
}
l3 l298(l286** l201,
    l46* l126)
{
    register l286* l250,
        * l428;
    if (!(l126 && l201)) {
        return 0;
    }
    for (l250 = *l201; l250; l250 = l250->l8) {
        if (l250->l126 == l126) {
            return 0;
        }
    }
    l428 = l365();
    l428->l126 = l126;
    l428->l8 = *l201;
    *l201 = l428;
    return 1;
}
l3 l299(l286** l206,
    register l286* l207)
{
    l3 l429 = 0;
    for (; l207; l207 = l207->l8) {
        l429 |= l298(l206, l207->l126);
    }
    return l429;
}
l3 l300(l286** l201,
    l46* l126)
{
    register l286* l250,
        * l430 = NULL;
    l286* l428;
    if (!*l201) {
        l428 = l365();
        l428->l126 = l126;
        *l201 = l428;
        return 1;
    }
    for (l250 = *l201; l250; l250 = l250->l8) {
        l430 = l250;
        if (l250->l126 == l126) {
            return 0;
        }
    }
    l428 = l365();
    l428->l126 = l126;
    l430->l8 = l428;
    return 1;
}
l3 l301(l286** l206,
    register l286* l207)
{
    l3 l429 = 0;
    for (; l207; l207 = l207->l8) {
        l429 |= l300(l206, l207->l126);
    }
    return l429;
}
l3 l302(register l286* l201,
    l46* l126)
{
    l3 l431 = 0;
    for (; l201; l201 = l201->l8) {
        if (l201->l126 == l126) {
            l431 = 1;
            break;
        }
    }
    return l431;
}
l46* l303(register l286* l304,
    register l286* l305)
{
    l286* l432 = l305;
    l46* l433 = NULL;
    for (; l304; l304 = l304->l8) {
        for (; l305; l305 = l305->l8) {
            if (l304->l126 == l305->l126) {
                l433 = l304->l126;
                break;
            }
        }
        if (l433) {
            break;
        }
        l305 = l432;
    }
    return l433;
}
int l306(register l286* l304,
    register l286* l305)
{
    l286* l434 = l304,
        * l432 = l305;
    int l435 = 0,
        l436 = 1;
    for (; l304 && l305; l304 = l304->l8, l305 = l305->l8) {
    }
    if (l304 || l305) {
        l436 = 0;
    }
    else {
        l304 = l434;
        l305 = l432;
        for (; l304; l304 = l304->l8) {
            for (l435 = 0; l305; l305 = l305->l8) {
                if (l304->l126 == l305->l126) {
                    l435 = 1;
                    break;
                }
            }
            if (!l435) {
                l436 = 0;
                break;
            }
            l305 = l432;
        }
    }
    return l436;
}
int l307(register l286* l304,
    register l286* l305)
{
    for (; l304 && l305; l304 = l304->l8, l305 = l305->l8) {
        if (l304->l126 != l305->l126) {
            break;
        }
    }
    return (!(l304 || l305));
}
l46* l308(register l286* l304,
    register l286* l305)
{
    l286* l432 = l305;
    l46* l433 = NULL;
    for (; l304; l304 = l304->l8) {
        for (; l305; l305 = l305->l8) {
            if (l304->l126 == l305->l126) {
                if (l304->l126->l34) {
                    l433 = l304->l126;
                    break;
                }
            }
        }
        if (l433) {
            break;
        }
        l305 = l432;
    }
    return l433;
}
void l309(l286* l201)
{
    register l286* l211,
        * l430;
    if (!(l54 && l201)) {
        return;
    }
    if (!l361) {
        l361 = l201;
        return;
    }
    for (l211 = l201; l211; l211 = l211->l8) {
        l430 = l211;
    }
    l430->l8 = l361;
    l361 = l201;
}
l3 l310(void)
{
    return l362;
}
void l311(void)
{
    register l46** l367;
    register l286* l437;
    l3 l438;
    printf("\n\n\t\t\t FIRSTS SETS OF NONTERMINALS ONLY\n\n");
    for (l367 = l143; *++l367;) {
        printf("%s: ", (*l367)->l11);
        l437 = (*l367)->l17;
        l438 = 0;
        for (; l437; l437 = l437->l8) {
            printf("  %s", l437->l126->l11);
            if (++l438 > 30) {
                printf("\n    ");
                l438 = 0;
            }
        }
        putchar('\n');
    }
}
void l312(void)
{
    register l46** l367;
    register l286* l437;
    l3 l438;
    printf("\n\n\t\t\t FOLLOWS SETS OF NONTERMINALS ONLY\n\n");
    for (l367 = l143; *++l367;) {
        printf("%s: ", (*l367)->l11);
        l437 = (*l367)->l18;
        l438 = 0;
        for (; l437; l437 = l437->l8) {
            printf("  %s", l437->l126->l11);
            if (++l438 > 30) {
                printf("\n    ");
                l438 = 0;
            }
        }
        putchar('\n');
    }
}
static l194* l439,
* l440;
static l194*
l441(void)
{
    register l194* l211 = l439;
    if (l211) {
        l439 = l211->l8;
        memset(l211, 0, sizeof(l194));
    }
    return l211;
}
static l194*
l442(void)
{
    register l194* l202;
    static int l366 = 0;
    static l194* l367;
    if (--l366 > 0) {
        ++l367;
        l202 = l367;
    }
    else {
        l366 = 0;
        l202 = l441();
        if (!l202) {
            l366 = 1024;
            l367 = (l194*)calloc(l366, sizeof(l194));
            l202 = l367;
            if (!l202) {
                l59(1301, "out of memory");
            }
        }
    }
    return l202;
}
l194*
l199(l46** l170,
    l46** l177,
    l194* l192,
    l3 l193)
{
    register l194* l428;
    l428 = l442();
    l428->l170 = l170;
    l428->l177 = l177;
    l428->l192 = l192;
    l428->l193 = l193;
    return l428;
}
l3 l200(l194** l201,
    register l194* l202)
{
    register l194* l250;
    l194* l428 = NULL,
        * l430 = NULL;
    if (!*l201) {
        l428 = l442();
        l428->l170 = l202->l170;
        l428->l177 = l202->l177;
        l428->l192 = l202->l192;
        l428->l193 = l202->l193;
        *l201 = l428;
        return 1;
    }
    for (l250 = *l201; l250; l250 = l250->l8) {
        l430 = l250;
        if (l250->l177 == l202->l177) {
            if (l51) {
                if (l250->l192 == l202->l192) {
                    return 0;
                }
            }
            else {
                return 0;
            }
        }
    }
    l428 = l442();
    l428->l170 = l202->l170;
    l428->l177 = l202->l177;
    l428->l192 = l202->l192;
    l428->l193 = l202->l193;
    l430->l8 = l428;
    return 1;
}
l3 l203(l194** l201,
    l46** l170,
    l46** l177,
    l194* l192,
    l194** l204,
    l3 l193)
{
    register l194* l430 = NULL,
        * l428 = NULL;
    l194* l250;
    int l382 = 1;
    if (*l201) {
        for (l250 = *l201; l250; l250 = l250->l8) {
            l430 = l250;
            if (l250->l177 == l177) {
                if (l51) {
                    if (l250->l192 == l192) {
                        l382 = 0;
                    }
                }
                else {
                    l382 = 0;
                }
                if (!l382) {
                    if (l204) {
                        *l204 = l250;
                    }
                    break;
                }
            }
        }
    }
    if (l382) {
        l428 = l442();
        l428->l170 = l170;
        l428->l177 = l177;
        l428->l192 = l192;
        l428->l193 = l193;
        if (l204) {
            *l204 = l428;
        }
        if (*l201) {
            l430->l8 = l428;
        }
        else {
            *l201 = l428;
        }
    }
    if (l49 > 8) {
        if (l382) {
        }
        else {
            if (l250->l192 != l192) {
                ;
                ;
                l217(l170, l177);
                if (l250->l192) {
                    ;
                    ;
                    l217(l250->l192->l170, l250->l192->l177);
                }
                if (l192) {
                    ;
                    ;
                    l217(l192->l170, l192->l177);
                }
            }
        }
    }
    return l382;
}
l3 l205(l194** l206,
    register l194* l207,
    l194* l192)
{
    l3 l429 = 0;
    for (; l207; l207 = l207->l8) {
        l429 |= l203(l206, l207->l170, l207->l177,
            l192, NULL, l207->l193);
    }
    return l429;
}
l194*
l208(register l194* l206,
    register l194* l207)
{
    l194* l443 = l207,
        * l444 = NULL;
    l46* l177;
    for (; l206; l206 = l206->l8) {
        for (; l207; l207 = l207->l8) {
            if (l206->l177 == l207->l177) {
                l177 = *l206->l177;
                if (l177) {
                    if (l177->l9 == 1) {
                        if (!l177->l26) {
                            l444 = l206;
                            break;
                        }
                    }
                }
            }
        }
        if (l444) {
            break;
        }
        l207 = l443;
    }
    return l444;
}
l3 l209(register l194* l206,
    register l194* l207)
{
    for (; l206 && l207; l206 = l206->l8, l207 = l207->l8) {
        if (l206->l177 != l207->l177) {
            break;
        }
    }
    return (!(l206 || l207));
}
void l210(register l194* l211)
{
    if (!l54) {
        return;
    }
    l211->l8 = l439;
    l439 = l211;
}
void l212(l194** l201)
{
    register l194* l211 = l439,
        * l430;
    if (!l54) {
        return;
    }
    if (!*l201) {
        return;
    }
    if (!l211) {
        l439 = *l201;
        *l201 = NULL;
        return;
    }
    for (; l211; l211 = l211->l8) {
        l430 = l211;
    }
    l430->l8 = *l201;
    *l201 = NULL;
}
l194*
l213(register l194* l201)
{
    register l194* l211,
        * l445;
    l194* l446 = NULL;
    if (l201) {
        l445 = l442();
        *l445 = *l201;
        l211 = l445;
        l446 = l445;
        l201 = l201->l8;
    }
    for (; l201; l201 = l201->l8, l211 = l211->l8) {
        l445 = l442();
        *l445 = *l201;
        l211->l8 = l445;
        l445->l8 = NULL;
    }
    return l446;
}
void l214(l194** l201)
{
    register l194* l211 = l440,
        * l430;
    if (!l54) {
        return;
    }
    if (!*l201) {
        return;
    }
    if (!l211) {
        l440 = *l201;
        *l201 = NULL;
        return;
    }
    for (; l211; l211 = l211->l8) {
        l430 = l211;
    }
    l430->l8 = *l201;
    *l201 = NULL;
}
void l215(void)
{
    if (!l54) {
        return;
    }
    l212(&l440);
}
int l216(l194* l201)
{
    register l46** l126;
    int l447 = 0;
    for (; l201; l201 = l201->l8) {
        for (l126 = l201->l170; *++l126;) {
            if ((*l126)->l9 == 1) {
                l447 = 1;
                break;
            }
        }
        if (l447) {
            break;
        }
    }
    return l447;
}
void l217(l46** l170,
    l46** l177)
{
    register l46** l126 = l170;
    ;
    ;
    while (*++l126) {
        if (l126 != l177) {
            ;
            ;
        }
        else {
            ;
            ;
        }
    }
    if (!*l177) {
        ;
        ;
    };
    ;
}
void l218(l194** l201)
{
    register l194* l211;
    register l194* l192;
    if (!*l201) {
        return;
    }
    for (l211 = *l201; l211; l211 = l211->l8) {
        l217(l211->l170, l211->l177);
        if (l48 < -3) {
            l192 = l211->l192;
            for (; l192; l192 = l192->l192) {
                ;
                ;
                l217(l192->l170, l192->l177);
            };
            ;
        }
    };
    ;
}
l3 l147 = 0,
l148 = 0,
l149 = 0,
l150 = 0;
static l3 l448 = 0,
l449 = 0,
l450 = 0,
l451 = 0;
l3 l152 = 0,
l151 = 0,
l153 = 0,
l154 = 0,
l155 = 0,
l156 = 0;
l46
** l143 = NULL,
** l144 = NULL,
** l145 = NULL,
*** l146 = NULL;
static struct l452
{
    l46** l375,
        * l376[255 + 1];
} l453 = { l453.l376 + 255 };
static l142*
l454(void)
{
    static int l366 = 0;
    static l142* l20;
    if (--l366 > 0) {
        return (++l20);
    }
    else {
        l366 = 1024;
        l20 = (l142*)calloc(l366, sizeof(l142));
        if (!l20) {
            l366 = 0;
            l59(1502, "out of memory");
        }
    }
    return l20;
}
static l3
l455(register l46* l179)
{
    register l46** l367 = l453.l375;
    while (*l367) {
        if (*l367++ == l179) {
            return 0;
        }
    }
    return 1;
}
static void
l456(void)
{
    register l46** l367 = l453.l375;
    while (*l367) {
        printf("    %s\n", (*l367)->l11);
        ++l367;
    }
}
static l3
l457(l46* l179)
{
    register l46** l126;
    register l46*** l367 = l146;
    l46* l170;
    int l458;
    int l26 = 0;
    while (*++l367) {
        l126 = *l367;
        l170 = *l126;
        if (l170 == l179) {
            l458 = 1;
            while (*++l126) {
                if ((*l126)->l9 == 2) {
                    l458 = 0;
                    break;
                }
                else if ((*l126)->l9 == 1) {
                    if (*l126 == l170) {
                        continue;
                    }
                    if (l455(*l126)) {
                        if (l453.l375 > l453.l376)
                            *--l453.l375 = *l126;
                        else
                            l59(1501, "stack overflow");
                        l458 = l457(*l126);
                        if (*l453.l375)
                            l453.l375++;
                        ;
                        if (!l458) {
                            break;
                        }
                    }
                    else {
                        if (l49 > 2) {
                            if (!l179->l31) {
                                printf("  %s: indirect left recursive \n",
                                    l179->l11);
                                l456();
                            }
                        }
                        l62();
                        l179->l31 = 1;
                    }
                }
            }
            if (l458) {
                l26 = 1;
            }
        }
    }
    return (l26);
}
static void
l459(void)
{
    register l46** l126,
        * l170;
    l46*** l367 = l146;
    int l26,
        l460;
    while (*++l367) {
        l126 = *l367;
        l170 = *l126;
        if (!l170->l26) {
            l170->l26 = 1;
            l170->l27 = 1;
            while (*++l126) {
                if ((*l126)->l9 != 3) {
                    l170->l26 = 0;
                    l170->l27 = 0;
                    break;
                }
            }
        }
    }
    do {
        l460 = 0;
        l126 = l143;
        while (*++l126) {
            if ((*l126)->l26) {
                continue;
            }
            l26 = l457(*l126);
            if (l26) {
                (*l126)->l26 = 1;
                l460 = 1;
            }
        }
    }
    while (l460);
}
static void
l461(void)
{
    register l46* l170,
        *** l367 = &l146[1];
    l3 l438;
    for (l170 = **l367, l438 = 0; *l367; ++l367, ++l438) {
        if (l170 != **l367) {
            l170->l24 = l438;
            l438 = 0;
            l170 = **l367;
        }
    }
}
static void
l462(void)
{
    register l46** l177,
        *** l367 = l146;
    l46* l170;
    while (*++l367) {
        l177 = *l367;
        l170 = *l177;
        for (++l177; *l177 && ((*l177)->l9 == 3); ++l177)
            ;
        l203(&l170->l23, *l367, l177, NULL, NULL, 0);
    }
}
static l3
l463(void)
{
    register l46** l126,
        * l170;
    l46*** l367;
    int l382;
    l3 l323 = 0;
    l126 = l144;
    while (*++l126) {
        l298(&(*l126)->l14, *l126);
    }
    for (l382 = 1; l382;) {
        l382 = 0;
        l367 = l146;
        while (*++l367) {
            l126 = *l367;
            l170 = *l126;
            while (*++l126) {
                if ((*l126)->l9 == 3) {
                    continue;
                }
                l382 |= l299(&l170->l14, (*l126)->l14);
                if (!(*l126)->l26) {
                    break;
                }
            }
            if (!*l126) {
                if (!l170->l26) {
                    printf("error: %s: is_nullable not set \n", l170->l11);
                    l170->l26 = 1;
                    ++l323;
                }
            }
        }
    }
    return l323;
}
static l3
l464(void)
{
    register l46** l126,
        ** l465;
    l46*** l367,
        * l376 = *l146[1],
        * l466;
    int l382, l467;
    l3 l323 = 0;
    l466 = l66("END_OF_SLK_INPUT");
    l298(&l376->l15, l466);
    for (l382 = 1; l382;) {
        l382 = 0;
        l367 = l146;
        while (*++l367) {
            l126 = *l367;
            while (*++l126) {
                if ((*l126)->l9 != 1) {
                    continue;
                }
                l465 = l126;
                for (;;) {
                    if (!*++l465) {
                        break;
                    }
                    if ((*l465)->l9 == 3) {
                        continue;
                    }
                    l382 |= l299(&(*l126)->l15,
                        (*l465)->l14);
                    if ((*l465)->l9 == 1) {
                        l382 |= l300(&(*l126)->l18,
                            *l465);
                    }
                    if (!(*l465)->l26) {
                        break;
                    }
                }
                if (!*l465 && (*l126) != (**l367)) {
                    l382 |= l299(&(*l126)->l15,
                        (**l367)->l15);
                    l467 = l299(&(*l126)->l18,
                        (**l367)->l18);
                    l382 |= l467;
                    if (l48 == -1 && l467 && (*l126)->l26) {
                        ;
                        ;
                    }
                }
            }
        }
    }
    return l323;
}
static void
l468(l46* l179,
    int l469,
    char* l470)
{
    register l46** l177,
        *** l367 = l146;
    l46** l435,
        * l170;
    int l471;
    static char l472[] = "                                                      ";
    for (l471 = 1; *++l367; ++l471) {
        l177 = *l367;
        l170 = *l177;
        l435 = NULL;
        for (++l177; *l177; ++l177) {
            if (*l177 == l179) {
                if (l170 == l179) {
                    continue;
                }
                if (l470[l471]) {
                    continue;
                }
                l435 = l177;
                for (++l177; *l177; ++l177) {
                    if ((*l177)->l9 == 3) {
                        continue;
                    }
                    if (!(*l177)->l26) {
                        break;
                    }
                }
            }
            if (l435 && !*l177) {
                l472[l469 + 1] = '\0';
                l188(l472, *l367);
                l472[l469 + 1] = ' ';
                l470[l471] = 1;
                l468(l170, l469 + 1, l470);
            }
        }
    }
}
static l3
l473(void)
{
    register l46** l179 = l143 + 1;
    l3 l431,
        l474 = 0;
    while (*++l179) {
        if ((*l179)->l26) {
            l431 = l302((*l179)->l18,
                *l179);
            if (l431) {
                l474 = 1;
                (*l179)->l44 = 1;
                printf(" %s: ambiguous: nullable can follow itself \n",
                    (*l179)->l11);
                if (l48 == -1) {
                    char* l470 = calloc(l150 + 4, 1);
                    l468(*l179, 0, l470);
                }
            }
        }
    }
    return l474;
}
static void
l475(l142** l20,
    int l131,
    int l141)
{
    register l142* l428,
        * l367 = *l20;
    l428 = l454();
    l428->l131 = l131;
    l428->l141 = l141;
    if (!l367) {
        *l20 = l428;
        return;
    }
    if (l367->l131 > l131) {
        l428->l8 = l367;
        *l20 = l428;
        return;
    }
    for (; l367; l367 = l367->l8) {
        if (!l367->l8) {
            l367->l8 = l428;
            break;
        }
        else if (l367->l8->l131 > l131) {
            l428->l8 = l367->l8;
            l367->l8 = l428;
            break;
        }
    }
}
static int
l476(register l142* l20,
    register int l131)
{
    for (; l20; l20 = l20->l8) {
        if (l20->l131 == l131) {
            return (l20->l141);
        }
    }
    return 0;
}
static l239*
l477(int l138)
{
    l46** l170,
        ** l177;
    l194* l478;
    l239* l428;
    l170 = l146[l138];
    l177 = l170 + 1;
    for (; *l177 && ((*l177)->l9 == 3); ++l177)
        ;
    l478 = l199(l170, l177, NULL, l196);
    l428 = l248(l138, l138, l478);
    return (l428);
}
static l3
l479(void)
{
    register l286* l480,
        * l481;
    l46* l170,
        ** l177,
        *** l367 = l146;
    int l131,
        l162 = 0,
        l253;
    l239* l250,
        * l428;
    l3 l323 = 0;
    while (*++l367) {
        l177 = *l367;
        l170 = *l177;
        ++l162;
        if (l176(++l177)) {
            for (l481 = l170->l15; l481; l481 = l481->l8) {
                l131 = l481->l126->l10;
                l253 = l476(l170->l20, l131);
                if (l253) {
                    if (l253 != l162) {
                        l250 = l477(l253);
                        l428 = l477(l162);
                        l252(l481->l126, l250, l428, 0);
                    }
                }
                else {
                    ++l170->l21;
                    l475(&l170->l20, l131, l162);
                }
            }
        }
        for (; *l177; ++l177) {
            if ((*l177)->l9 == 3) {
                continue;
            }
            for (l480 = (*l177)->l14; l480; l480 = l480->l8) {
                l131 = l480->l126->l10;
                l253 = l476(l170->l20, l131);
                if (l253) {
                    if (l253 != l162) {
                        l250 = l477(l253);
                        l428 = l477(l162);
                        l252(l480->l126, l250, l428, 0);
                    }
                }
                else {
                    ++l170->l21;
                    l475(&l170->l20, l131, l162);
                }
            }
            if (!(*l177)->l26) {
                break;
            }
        }
    }
    return l323;
}
static void
l482(void)
{
    register l46** l367,
        ** l483,
        * l126;
    l46** l484 = &l143[l147 + 1],
        ** l327 = &l143[l147 + 1 -
        l152];
    int l485 = l152,
        l81;
    if (l147 && l143[1]->l10) {
        return;
    }
    if (l485) {
        for (l367 = l143; ++l367 < l327;) {
            if ((*l367)->l45) {
                *l484 = *l367;
                for (l483 = l367; *l483; ++l483) {
                    *l483 = *(l483 + 1);
                }
                --l367;
            }
        }
    }
    for (l81 = 1, l367 = l144; *++l367;) {
        (*l367)->l10 = l81++;
    }
    l156 = l81;
    for (l367 = l143; *++l367;) {
        (*l367)->l10 = l81++;
    }
    l155 = l81;
    l367 = l145;
    if (*++l367) {
        l126 = *l367;
        if (l126->l10) {
            for (; *l367; ++l367) {
                l126 = *l367;
                if (!l126->l10) {
                    l59(1512, "Cannot mix numbered and unnumbered actions");
                }
                l126->l10 += l155 - 1;
            }
        }
        else {
            for (; *l367; ++l367) {
                l126 = *l367;
                if (l126->l10) {
                    l59(1513, "Cannot mix numbered and unnumbered actions");
                }
                l126->l10 = l81++;
            }
        }
    }
    l154 = l150 + 1;
}
void l157(void)
{
    if (!l150) {
        l63();
        return;
    }
    if (l71()) {
        l114();
    }
    l482();
    l459();
    l461();
    l462();
}
l3 l158(void)
{
    l3 l323 = 0;
    ;
    ;
    l323 |= l463();
    ;
    ;
    l323 |= l464();
    l473();
    return l323;
}
l3 l159(void)
{
    l3 l323 = 0;
    ;
    ;
    l323 |= l479();
    return l323;
}
l46**
l160(register l46** l141)
{
    register l46** l428;
    l3 l342;
    static size_t l122 = 1024 * sizeof(l46**);
    static l46** l486 = NULL,
        ** l327 = NULL;
    l428 = l141;
    while (*l428++) {
    }
    l342 = l428 - l141;
    if (l342 > l153) {
        l153 = l342;
    }
    if (l486 + l342 > l327) {
        l486 = (l46**)malloc(l122);
        if (!l486) {
            l59(1504, "out of memory");
        }
        l327 = l486 + (l122 / sizeof(l46**)) - 1;
    }
    l428 = l486;
    while (*l428++ = *l141++) {
    }
    l486 += l342;
    return (l486 - l342);
}
static l46**
l487(l46** l141)
{
    register l46*** l367 = l146;
    while (*++l367) {
        if (**l367 == *l141) {
            if (l166(*l367, l141)) {
                break;
            }
        }
    }
    return *l367;
}
l46***
l161(l46** l162,
    l46*** l23)
{
    register l46*** l367 = NULL;
    char* l488;
    if (l487(l162)) {
        if (l48 > 3) {
            l188("already exists: \n", l162);
        }
        return l367;
    }
    if (++l150 > l451) {
        l451 += (64 * 1024);
        l146 = (l46***)realloc(l146,
            (l451 + 4) * sizeof(void*));
        if (!l146) {
            l59(1511, "out of memory");
        }
        l488 = (char*)&l146[l451 + 4 - (64 * 1024)];
        memset(l488, 0, (64 * 1024) * sizeof(void*));
    }
    l367 = &l146[l150];
    for (; l367 != l23; --l367) {
        *l367 = *(l367 - 1);
    }
    *l367 = l162;
    return l367;
}
void l163(register l46*** l141)
{
    for (; *l141; ++l141) {
        *l141 = *(l141 + 1);
    }
    --l150;
}
void l164(register l46** l141)
{
    register l46*** l367;
    l46*** l489 = NULL;
    char* l488;
    if (++l150 > l451) {
        l451 += (64 * 1024);
        l146 = (l46***)realloc(l146,
            (l451 + 4) * sizeof(void*));
        if (!l146) {
            l59(1505, "out of memory");
        }
        l488 = (char*)&l146[l451 + 4 - (64 * 1024)];
        memset(l488, 0, (64 * 1024) * sizeof(void*));
    }
    for (l367 = l146; *++l367;) {
        if (**l367 == *l141) {
            for (; *l367; ++l367) {
                if (**l367 == *l141) {
                    if (l166(*l367, l141)) {
                        if (l49 > 2) {
                            printf("  Tried to add duplicate production:\n");
                            l188("    ", l141);
                        }
                        return;
                    }
                }
                else {
                    l489 = l367;
                    break;
                }
            }
            break;
        }
    }
    if (!*l367) {
        *l367 = l160(l141);
    }
    else {
        l367 = &l146[l150];
        for (; l367 != l489; --l367) {
            *l367 = *(l367 - 1);
        }
        *l367 = l160(l141);
    }
}
void l165(register l46** l141)
{
    register l46*** l367;
    l46*** l489 = NULL;
    char* l488;
    if (++l150 > l451) {
        l451 += (64 * 1024);
        l146 = (l46***)realloc(l146,
            (l451 + 4) * sizeof(void*));
        if (!l146) {
            l59(1505, "out of memory");
        }
        l488 = (char*)&l146[l451 + 4 - (64 * 1024)];
        memset(l488, 0, (64 * 1024) * sizeof(void*));
    }
    for (l367 = l146; *++l367;) {
        if (**l367 == *l141) {
            for (; *l367; ++l367) {
                if (**l367 == *l141) {
                    if (l166(*l367, l141)) {
                        if (l49 > 2) {
                            printf("  Tried to add duplicate production:\n");
                            l188("    ", l141);
                        }
                        return;
                    }
                }
                else {
                    l489 = l367;
                    break;
                }
            }
            break;
        }
    }
    if (!*l367) {
        *l367 = l141;
    }
    else {
        l367 = &l146[l150];
        for (; l367 != l489; --l367) {
            *l367 = *(l367 - 1);
        }
        *l367 = l141;
    }
}
l3 l166(register l46** l167,
    register l46** l168)
{
    for (; *l167 == *l168; ++l167, ++l168) {
        if (!*l167) {
            break;
        }
    }
    return (*l167 == *l168);
}
int l169(register l46* l170)
{
    register l46*** l367 = l146;
    int l261 = 1;
    for (; *++l367; ++l261) {
        if (l170 == **l367) {
            break;
        }
    }
    return l261;
}
void l171(l46* l126)
{
    int l490;
    char* l488;
    if (!l143) {
        l143 = (l46**)calloc((64 * 1024), sizeof(void*));
        l144 = (l46**)calloc((64 * 1024), sizeof(void*));
        l145 = (l46**)calloc((64 * 1024), sizeof(void*));
        l146 = (l46***)calloc((64 * 1024), sizeof(void*));
        l448 = (64 * 1024) - 4;
        l449 = (64 * 1024) - 4;
        l450 = (64 * 1024) - 4;
        l451 = (64 * 1024) - 4;
        if (!(l143 && l144 && l145 && l146)) {
            l59(1511, "out of memory");
        }
    }
    switch (l126->l9) {
    case 1:
        l143[++l147] = l126;
        if (l147 > l448) {
            l448 += (64 * 1024);
            l143 = (l46**)realloc(l143,
                (l448 + 4) * sizeof(void*));
            if (!l143) {
                l59(1506, "out of memory");
            }
            l488 = (char*)&l143[l448 + 4 - (64 * 1024)];
            memset(l488, 0, (64 * 1024) * sizeof(void*));
        }
        break;
    case 2:
        l144[++l148] = l126;
        if (l148 > l449) {
            l449 += (64 * 1024);
            l144 = (l46**)realloc(l144,
                (l449 + 4) * sizeof(void*));
            if (!l144) {
                l59(1507, "out of memory");
            }
            l488 = (char*)&l144[l449 + 4 - (64 * 1024)];
            memset(l488, 0, (64 * 1024) * sizeof(void*));
        }
        break;
    case 3:
        ++l149;
        l490 = l126->l10;
        if (l490) {
            break;
        }
        l145[l149] = l126;
        if (l149 > l450) {
            l450 += (64 * 1024);
            l145 = (l46**)realloc(l145,
                (l450 + 4) * sizeof(void*));
            if (!l145) {
                l59(1508, "out of memory");
            }
            l488 = (char*)&l145[l450 + 4 - (64 * 1024)];
            memset(l488, 0, (64 * 1024) * sizeof(void*));
        }
        break;
    }
}
void l172(register l46* l126)
{
    register l46** l367;
    char* l488;
    for (l367 = l144; *++l367;) {
        if (*l367 == l126) {
            for (; *l367; ++l367) {
                *l367 = *(l367 + 1);
            }
            --l148;
            break;
        }
    }
    l126->l9 = 1;
    l143[++l147] = l126;
    if (l147 > l448) {
        l448 += (64 * 1024);
        l143 = (l46**)realloc(l143,
            (l448 + 4) * sizeof(void*));
        if (!l143) {
            l59(1509, "out of memory");
        }
        l488 = (char*)&l143[l448 + 4 - (64 * 1024)];
        memset(l488, 0, (64 * 1024) * sizeof(void*));
    }
}
void l173(register l142* l20,
    register int l131,
    int l132)
{
    for (; l20; l20 = l20->l8) {
        if (l20->l131 == l131) {
            l20->l141 = (l132 + (l154 - 1));
            break;
        }
    }
    if (!l20) {
        ;
        ;
        l59(1510, "");
    }
}
void l174(register l142* l20,
    int l132,
    int l175)
{
    int l491 = (l132 + (l154 - 1));
    for (; l20; l20 = l20->l8) {
        if (l20->l141 == l491) {
            l283(l132);
            l20->l141 = l175;
        }
    }
}
l3 l176(register l46** l177)
{
    for (; *l177; ++l177) {
        if ((*l177)->l9 != 3 && !(*l177)->l26) {
            return 0;
        }
    }
    return 1;
}
void l178(l46* l179)
{
    register l46** l126,
        * l170;
    l46*** l367 = l146;
    while (*++l367) {
        l126 = *l367;
        l170 = *l126;
        if (l170 == l179) {
            if (!l170->l26) {
                l170->l26 = 1;
                l170->l27 = 1;
                while (*++l126) {
                    if ((*l126)->l9 != 3) {
                        l170->l26 = 0;
                        l170->l27 = 0;
                        break;
                    }
                }
            }
        }
    }
    if (!l179->l26) {
        l179->l26 = l457(*l126);
    }
}
static char*
l492(char* l250)
{
    static l3 l138 = 0;
    static char l428[128];
    l3 l342;
    l342 = strlen(l250);
    if (l342 >= sizeof(l428) - 12) {
        if (l48 > 0) {
            l186();
        }
        printf("old string too long:\n  %s\n", l250);
        l59(1902, "");
    }
    sprintf(l428, "%s_%02u", l250, ++l138);
    return l428;
}
void l493(void)
{
    register l46*** l367 = l146,
        ** l126;
    l46** l170;
    int l471 = 0;
    while (*++l367) {
        l170 = *l367;
        l126 = *l367;
        printf("%2d: %s -->", ++l471, (*l126)->l11);
        while (*++l126) {
            if ((*l126)->l9 == 1 && *l126 != *l170) {
                if (!(*l126)->l42) {
                    ++(*l126)->l25;
                }
            }
            if ((*l126)->l9 == 1 && *l126 != *l170) {
                if ((*l126)->l25 > 1) {
                    printf(" %s (%d)", (*l126)->l11, (*l126)->l25);
                }
                else {
                    printf(" %s ", (*l126)->l11);
                }
            }
            else {
                printf(" %s ", (*l126)->l11);
            }
        }
        putchar('\n');
    }
}
void l494(void)
{
    register l46*** l367 = l146,
        ** l126;
    int l471 = 0;
    l493();
    while (*++l367) {
        l126 = *l367;
        printf("%2d: %s -->", ++l471, (*l126)->l11);
        while (*++l126) {
            printf(" %s", (*l126)->l11);
        }
        putchar('\n');
    }
}
void l180(void)
{
    register l46** l367;
    register l286* l437;
    printf("\n\n\t\t\t NONTERMINAL FIRSTS SETS \n\n");
    for (l367 = l143; *++l367;) {
        printf("%s: ", (*l367)->l11);
        if ((*l367)->l26) {
            printf("  _epsilon_");
        }
        for (l437 = (*l367)->l14; l437; l437 = l437->l8) {
            printf("  %s", l437->l126->l11);
        }
        putchar('\n');
    }
}
void l181(void)
{
    register l46** l367;
    register l286* l437;
    printf("\n\n\t\t\t NONTERMINAL FOLLOWS SETS \n\n");
    for (l367 = l143; *++l367;) {
        printf("%s: ", (*l367)->l11);
        for (l437 = (*l367)->l15; l437; l437 = l437->l8) {
            printf("  %s", l437->l126->l11);
        }
        putchar('\n');
    }
}
void l183(void)
{
    register l46** l179 = l143;
    fputs("\n\n\t\t NONTERMINALS GOING TO EMPTY STRING \n\n", stdout);
    while (*++l179)
        if ((*l179)->l26)
            printf("\t%s\n", (*l179)->l11);
}
void l184(int l185)
{
    register l46** l179 = l143;
    register l142* l20;
    fputs("\n\n\t\t\t PARSE TABLE \n\n", stdout);
    if (l185) {
        l139();
        return;
    }
    while (*++l179) {
        fputs((*l179)->l11, stdout);
        putchar(':');
        for (l20 = (*l179)->l20; l20; l20 = l20->l8) {
            printf("   %s %d", l144[l20->l131]->l11,
                l20->l141);
        }
        putchar('\n');
    }
}
void l186(void)
{
    register l46*** l367 = l146,
        ** l126;
    int l471 = 0;
    printf("\n\n\t\t\t PRODUCTION STRINGS \n\n");
    while (*++l367) {
        l126 = *l367;
        printf("%2d: %s -->", ++l471, (*l126)->l11);
        while (*++l126) {
            printf(" %s", (*l126)->l11);
        }
        putchar('\n');
    }
}
void l187(void)
{
    register l46*** l141 = l146;
    register l46** l367;
    int l471 = 0;
    fputs("\n\n\t\t\t PRODUCTION INTEGERS \n\n", stdout);
    while (*++l141) {
        l367 = *l141;
        printf("%2d: %d -->", ++l471, (*l367)->l10);
        while (*++l367)
            printf("%6d", (*l367)->l10);
        putchar('\n');
    }
}
void l188(char* l189,
    l46** l141)
{
    register l46** l126 = l141;
    if (l189) {
        printf("%s ", l189);
    }
    printf("%s -->", (*l126)->l11);
    while (*++l126) {
        printf("  %s", (*l126)->l11);
    }
    putchar('\n');
}
void l190(int l138)
{
    register l46** l126;
    if (!l138) {
        return;
    }
    l126 = l146[l138];
    printf("%d:  %s -->", l138, (*l126)->l11);
    while (*++l126) {
        printf(" %s", (*l126)->l11);
    }
    putchar('\n');
}
void l191(l46* l179)
{
    register l46*** l367 = l146;
    while (*++l367) {
        if (**l367 == l179) {
            l188(NULL, *l367);
        }
    }
}
static l46* l495[10007];
static l46*
l496(void)
{
    static int l366 = 0;
    static l46* l11;
    if (--l366 > 0) {
        return (++l11);
    }
    else {
        l366 = 256;
        l11 = (l46*)calloc(l366, sizeof(l46));
        if (!l11) {
            l366 = 0;
            l59(1601, "out of memory");
        }
    }
    return l11;
}
static l3
l497(char* l65)
{
    register char* l340 = l65 - 1;
    register l3 l498 = 0;
    register l3 l499;
    while (*++l340) {
        l498 = (l498 << 4) + *l340;
        if (l499 = l498 & 0xf0000000) {
            l498 ^= (l499 >> 24);
            l498 ^= l499;
        }
    }
    return (l498 % 10007);
}
char*
l64(char* l65)
{
    l3 l342;
    static size_t l122 = 1024 * 16;
    static char* l486 = NULL,
        * l327 = NULL;
    l342 = strlen(l65) + 1;
    if (l486 + l342 > l327) {
        l486 = malloc(l122);
        if (!l486) {
            l59(1602, "out of memory");
        }
        l327 = l486 + l122 - 1;
    }
    strcpy(l486, l65);
    l486 += l342;
    return (l486 - l342);
}
l46* l66(register char* l11)
{
    register l46* l367;
    l367 = l495[l497(l11)];
    if (l367) {
        while ((l367 = l367->l8)) {
            if (!(strcmp(l11, l367->l11))) {
                return l367;
            }
        }
    }
    return NULL;
}
l46* l67(int l9,
    int l10,
    char* l11)
{
    register l46* l428,
        * l500;
    int l501;
    l501 = l497(l11);
    l500 = l495[l501];
    if (!l500) {
        l500 = l496();
        l495[l501] = l500;
    }
    l428 = l496();
    l428->l9 = l9;
    l428->l10 = l10;
    l428->l11 = l64(l11);
    l428->l8 = l500->l8;
    l500->l8 = l428;
    return l428;
}
void l68(void)
{
    register l46** l500 = l495,
        * l126;
    int l501;
    fputs("\n HASHVAL  TYPE  TOKEN  NAME ", stdout);
    fputs("\n -------  ----  -----  ---------------------\n", stdout);
    for (l501 = 0; l501 < 10007; ++l501) {
        l126 = *l500++;
        if (l126) {
            while ((l126 = l126->l8)) {
                printf("%6d    %4d  %5d  %s \n",
                    l501, l126->l9, l126->l10, l126->l11);
            }
        }
    }
}
char* l502 = "}";
static l3
l503(l3 l504,
    l3 l505)
{
    l3 l503 = l504;
    if (l505 > l503) {
        l503 = l505;
    }
    return (l503);
}
static l3
l506(l3 l504,
    l3 l505,
    l3 l507)
{
    l3 l506 = l504;
    if (l505 > l506) {
        l506 = l505;
    }
    if (l507 > l506) {
        l506 = l507;
    }
    return (l506);
}
static int
l508(int l89)
{
    register l46** l126;
    int l87 = 1;
    l5* l509,
        * l510;
    for (l126 = l145; *++l126;) {
        l509 = (*l126)->l11;
        l510 = l509;
        if (!l89) {
            l510 += l73(l510);
        }
        if (((*l510 >= '0' && *l510 <= '9'))) {
            l87 = 0;
        }
    }
    return l87;
}
static void
l511(FILE* l88,
    int* l512,
    l3 l85)
{
    register int* l367;
    register l142* l20;
    int l513,
        l21 = l148,
        l131;
    l46** l179;
    int l438;
    if (l85 & 0x00002000) {
        fputs("var Parse = [0,0\n\n", l88);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fputs("static slk_size_t Parse[] = {0,0\n\n", l88);
    }
    else {
        fputs("private static short[] Parse = {0,0\n\n", l88);
    }
    l179 = l143;
    l513 = 1;
    l367 = l512;
    while (*++l179) {
        l131 = 0;
        *++l367 = l513;
        for (l20 = (*l179)->l20; l20; l20 = l20->l8) {
            while (++l131 < l20->l131) {
                fputs(",0", l88);
            }
            fprintf(l88, ",%u", l20->l141);
        }
        while (++l131 <= l148) {
            fputs(",0", l88);
        }
        l513 += l21;
        fputs("\n", l88);
    }
    *++l367 = 0;
    fprintf(l88, "%s;\n\n", l502);
    if (l85 & 0x00002000) {
        fputs("var Parse_row = [0\n\n", l88);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fputs("static int Parse_row[] = {0\n\n", l88);
    }
    else {
        fputs("private static int[] Parse_row = {0\n\n", l88);
    }
    l367 = l512;
    for (l438 = 1; *++l367; ++l438) {
        fprintf(l88, ",%u", *l367);
        if (l438 >= 16) {
            l438 = 0;
            fputs("\n", l88);
        }
    }
    fprintf(l88, "\n,0%s;\n\n", l502);
}
static void
l514(FILE* l88,
    int* l512,
    l3 l85)
{
    register int* l515;
    register l268* l367;
    int l513,
        l21 = l148,
        l141,
        l131;
    l271* l278;
    l3 l516 = 0,
        l517;
    l3 l518;
    l274* l276;
    int l438;
    l276 = l281();
    if (l85 & 0x00002000) {
        fprintf(l88, "var Conflict = [0,0\n\n");
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fprintf(l88, "static slk_size_t Conflict[] = {0,0\n\n");
    }
    else {
        fprintf(l88, "private static short[] Conflict = {0,0\n\n");
    }
    l513 = 1;
    l515 = l512;
    for (; l276; l276 = l276->l8) {
        l518 = 1;
        l517 = 0;
        for (l278 = l276->l273; l278; l278 = l278->l8) {
            ++l517;
        }
        l516 += l517;
        for (l278 = l276->l273; l278; l278 = l278->l8) {
            l131 = 0;
            *++l515 = l513;
            for (l367 = l278->l270; l367; l367 = l367->l8) {
                while (++l131 < l367->l131) {
                    fputs(",0", l88);
                }
                l141 = l367->l141;
                if ((l141 >= l154)) {
                    l141 += l516;
                    l518 = 0;
                }
                fprintf(l88, ",%u", l141);
            }
            while (++l131 <= l148) {
                fputs(",0", l88);
            }
            l513 += l21;
            fputs("\n", l88);
        }
        fputs("\n", l88);
        if (l518) {
            break;
        }
    }
    *++l515 = 0;
    fprintf(l88, "%s;\n\n", l502);
    if (l85 & 0x00002000) {
        fprintf(l88, "var Conflict_row = [0\n\n");
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fprintf(l88, "static int Conflict_row[] = {0\n\n");
    }
    else {
        fprintf(l88, "private static int[] Conflict_row = {0\n\n");
    }
    l515 = l512;
    for (l438 = 1; *++l515; ++l438) {
        fprintf(l88, ",%u", *l515);
        if (l438 >= 16) {
            l438 = 0;
            fputs("\n", l88);
        }
    }
    fprintf(l88, "\n,0%s;\n\n", l502);
}
static int
l519(void)
{
    register l46** l179;
    static int l520 = 0;
    static l3 l521 = 1;
    static int l278 = 0;
    if (l521) {
        l521 = 0;
        l179 = l143;
        while (*++l179) {
            if ((*l179)->l21 > l520)
                l520 = (*l179)->l21;
        }
    }
    do {
        while (++l278 <= l147)
            if (l143[l278]->l21 == l520)
                return (l278);
        l278 = 0;
    }
    while (--l520 > 0);
    return (0);
}
static int*
l522(l3 l523,
    int* l524,
    l3 l525,
    int* l512)
{
    register int* l526;
    register l142* l367;
    int* l527 = l524 +
        l525 - l148,
        * l528 = NULL,
        * l529,
        * l513,
        l278;
    l142* l530;
    l3 l531;
    printf("compacting parse table from %u ", l523);
    while (l278 = l519()) {
        l530 = l143[l278]->l20;
        l526 = l524;
        for (;;) {
            while (*++l526) {
                if (l526 > l527) {
                    l59(1102, "\n compact failed");
                }
            }
            l367 = l530;
            if (!l367) {
                printf("\n no table entries for %s\n", l143[l278]->l11);
                l59(1103, "");
            }
            if (l526 - l367->l131 <= l524) {
                continue;
            }
            l529 = l526;
            l526 -= l367->l131;
            l531 = 1;
            for (l367 = l530; l367; l367 = l367->l8) {
                if (*(l526 + l367->l131)) {
                    l531 = 0;
                    break;
                }
            }
            if (l531) {
                l512[l278] = l526 - l524;
                for (l367 = l530; l367; l367 = l367->l8) {
                    l513 = l526 + l367->l131;
                    *l513 = l367->l141;
                    if (l526 + l148 > l528) {
                        l528 = l526 + l148;
                    }
                }
                break;
            }
            l526 = l529;
        }
    }
    l512[l147 + 1] = 0;
    printf("to %lu\n", (l4)(++l528 - l524 - 1));
    return l528;
}
static void
l532(FILE* l88,
    int* l327,
    int* l524,
    int* l512,
    l3 l85)
{
    register int* l367;
    l3 l438 = 1,
        l270 = 1;
    l367 = l524;
    if (l85 & 0x00002000) {
        fprintf(l88, "var Parse = [\n\n%u", *l367);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fprintf(l88, "static slk_size_t Parse[] = {\n\n%u", *l367);
    }
    else {
        fprintf(l88, "private static short[] Parse = {\n\n%u", *l367);
    }
    while (++l367 < l327) {
        ++l270;
        if (++l438 > 19) {
            l438 = 0;
            fputs("\n", l88);
        }
        fprintf(l88, ",%u", *l367);
    }
    fprintf(l88, "\n%s;\n\n", l502);
    if (l85 & 0x00002000) {
        fputs("var Parse_row = [0\n\n", l88);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        if (l270 < (1024 * 64 - 32)) {
            fputs("static slk_size_t Parse_row[] = {0\n\n", l88);
        }
        else {
            fputs("static int Parse_row[] = {0\n\n", l88);
        }
    }
    else {
        fputs("private static int[] Parse_row = {0\n\n", l88);
    }
    l367 = l512;
    for (l438 = 1; *++l367; ++l438) {
        fprintf(l88, ",%u", *l367);
        if (l438 >= 16) {
            l438 = 0;
            fputs("\n", l88);
        }
    }
    fprintf(l88, "\n,0%s;\n\n", l502);
}
static l3
l533(register l268* l534,
    register l268* l535)
{
    l3 l413 = 1;
    for (; l534 && l535; l534 = l534->l8, l535 = l535->l8) {
        if (l534->l131 != l535->l131 ||
            l534->l141 != l535->l141) {
            l413 = 0;
            break;
        }
    }
    if (l534 || l535) {
        l413 = 0;
    }
    return l413;
}
static int
l536(int* l537,
    int* l512)
{
    register l142* l367;
    register l46** l179;
    int l513,
        l131,
        l323 = 0,
        l278,
        l538,
        l141;
    l142* l530;
    for (l278 = 1, l179 = l143; *++l179; ++l278) {
        l530 = (*l179)->l20;
        for (l367 = l530; l367; l367 = l367->l8) {
            if (!l367) {
                printf("\n no table entries for %s\n", (*l179)->l11);
                l59(1143, "");
            }
            l141 = l367->l141;
            l131 = l367->l131;
            l513 = l512[l278];
            l513 += l131;
            l538 = l537[l513];
            if (l141 != l538) {
                l323 = 1;
                printf("\n%3d: ", l278);
                printf("%s: ", (*l179)->l11);
                printf("%s: %u != %u at offset %u\n",
                    l144[l131]->l11,
                    l141, l538, l513);
                l190(l141);
                l190(l538);
            }
        }
    }
    return l323;
}
static int
l539(int* l537,
    int* l512)
{
    register l268* l367;
    register l271* l278;
    int l132,
        l538,
        l323 = 0,
        l141;
    l3 l516 = 0,
        l131,
        l513,
        l517;
    l3 l518;
    l274* l276;
    l276 = l281();
    l132 = 1;
    for (; l276; l276 = l276->l8) {
        l518 = 1;
        l517 = 0;
        for (l278 = l276->l273; l278; l278 = l278->l8) {
            ++l517;
        }
        l516 += l517;
        for (l278 = l276->l273; l278; l278 = l278->l8) {
            for (l367 = l278->l270; l367; l367 = l367->l8) {
                l141 = l367->l141;
                if ((l141 >= l154)) {
                    l141 += l516;
                    l518 = 0;
                }
                l131 = l367->l131;
                l513 = l512[l132];
                l513 += l131;
                l538 = l537[l513];
                if (l141 != l538) {
                    l323 = 1;
                    printf("\n%3d: ", l132);
                    printf("%s: ", l278->l179->l11);
                    printf("%s: %u != %u at offset %u\n",
                        l144[l131]->l11,
                        l141, l538, l513);
                    l190(l141);
                    l190(l538);
                }
            }
            ++l132;
        }
        if (l518) {
            break;
        }
    }
    return l323;
}
static int*
l540(l3 l541,
    int* l537,
    l3 l542,
    int* l512)
{
    register l268* l367;
    register l271* l278;
    l271* l543;
    int l141;
    l3 l516 = 0,
        l132 = 0,
        l517;
    int* l526,
        * l527 = l537 +
        l542 - l148,
        * l528 = l537,
        * l513,
        * l529;
    l3 l531,
        l518;
    l274* l276;
    printf("compacting conflict table from %u ", l541);
    l276 = l281();
    for (; l276; l276 = l276->l8) {
        l518 = 1;
        l517 = 0;
        for (l278 = l276->l273; l278; l278 = l278->l8) {
            ++l517;
        }
        l516 += l517;
        l543 = NULL;
        for (l278 = l276->l273; l278; l278 = l278->l8) {
            ++l132;
            l526 = NULL;
            if (l543) {
                if (l533(l543->l270, l278->l270)) {
                    *(l512 + 1) = *l512;
                    ++l512;
                    l543 = l278;
                    continue;
                }
                if (l543->l179 == l278->l179) {
                    l526 = l537 + *l512 + l148;
                }
            }
            if (!l526) {
                l526 = l537;
            }
            for (;;) {
                while (*++l526) {
                    if (l526 > l527) {
                        l59(1104, "\n compact failed");
                    }
                }
                l367 = l278->l270;
                if (!l367) {
                    if (l49 > 2) {
                        printf("\n  no table entries for conflict %u   ",
                            l132);
                    }
                    *++l512 = l526 - l537;
                    break;
                }
                if (l526 - l367->l131 <= l537) {
                    continue;
                }
                l529 = l526;
                l526 -= l367->l131;
                l531 = 1;
                for (l367 = l278->l270; l367; l367 = l367->l8) {
                    if (*(l526 + l367->l131)) {
                        l531 = 0;
                        break;
                    }
                }
                if (l531) {
                    *++l512 = l526 - l537;
                    for (l367 = l278->l270; l367; l367 = l367->l8) {
                        l513 = l526 + l367->l131;
                        l141 = l367->l141;
                        if ((l141 >= l154)) {
                            l141 += l516;
                            l518 = 0;
                        }
                        if (*l513) {
                            printf("error 1140: nonzero entry = %u\n", *l513);
                        }
                        *l513 = l141;
                        if (l513 > l528) {
                            l528 = l513;
                        }
                    }
                    break;
                }
                l526 = l529;
            }
            l543 = l278;
        }
        if (l518) {
            break;
        }
    }
    *++l512 = 0;
    printf("to %lu\n", (l4)(++l528 - l537 - 1));
    return l528;
}
static void
l544(FILE* l88,
    int* l327,
    int* l524,
    int* l512,
    l3 l85)
{
    register int* l367;
    l3 l438 = 1,
        l270 = 1;
    l367 = l524;
    if (l85 & 0x00002000) {
        fprintf(l88, "var Conflict = [\n\n%u", *l367);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fprintf(l88, "static slk_size_t Conflict[] = {\n\n%u", *l367);
    }
    else {
        fprintf(l88, "private static short[] Conflict = {\n\n%u", *l367);
    }
    while (++l367 < l327) {
        ++l270;
        if (++l438 > 19) {
            l438 = 0;
            fputs("\n", l88);
        }
        fprintf(l88, ",%u", *l367);
    }
    fprintf(l88, "\n%s;\n\n", l502);
    if (l85 & 0x00002000) {
        fputs("var Conflict_row = [0\n\n", l88);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        if (l270 < (1024 * 64 - 32)) {
            fputs("static slk_size_t Conflict_row[] = {0\n\n", l88);
        }
        else {
            fputs("static int Conflict_row[] = {0\n\n", l88);
        }
    }
    else {
        fputs("private static int[] Conflict_row = {0\n\n", l88);
    }
    l367 = l512;
    for (l438 = 1; *++l367; ++l438) {
        fprintf(l88, ",%u", *l367);
        if (l438 >= 16) {
            l438 = 0;
            fputs("\n", l88);
        }
    }
    fprintf(l88, "\n,0%s;\n\n", l502);
}
static void
l545(l3 l85,
    FILE* l88)
{
    int* l537,
        * l512,
        * l327;
    l3 l523,
        l542 = 0;
    l512 = calloc(l147 + 2, sizeof(int*));
    if (!l512) {
        l59(1115, "out of memory");
    }
    if (l85 & 0x00000001) {
        l523 = l147 * l148;
        l542 = l503(1024 * 10, l523 / 3);
        l537 = calloc(l542, sizeof(int));
        if (!l537) {
            l59(1116, "out of memory");
        }
        l327 = l522(l523, l537,
            l542, l512);
        l532(l88, l327, l537, l512,
            l85);
        if (l536(l537, l512)) {
            printf("error 1133: table compacting failed\n");
        }
    }
    else {
        l511(l88, l512, l85);
    }
}
static void
l546(l3 l85,
    FILE* l88)
{
    int* l537,
        * l512,
        * l327;
    l3 l541,
        l542 = 0;
    l512 = calloc(l221 + 2, sizeof(int*));
    if (!l512) {
        l59(1117, "out of memory");
    }
    if (l85 & 0x00000001) {
        l541 = l221 * l148;
        l542 = l503(1024 * 10, l541);
        l537 = calloc(l542, sizeof(int));
        if (!l537) {
            l59(1116, "out of memory");
        }
        l327 = l540(l541, l537,
            l542, l512);
        l544(l88, l327, l537, l512,
            l85);
        if (l539(l537, l512)) {
            printf("error 1134: table compacting failed\n");
        }
    }
    else {
        l514(l88, l512, l85);
    }
}
void l82(char* l83,
    char* l84,
    l3 l85,
    l3 l76)
{
    int l87,
        l547 = 0x00000100;
    FILE* l88;
    char l75[32];
    if (l85 & (0x00000200)) {
        l547 = 0x00000200;
    }
    else if (l85 & (0x00001000)) {
        l547 = 0x00001000;
    }
    else if (l85 & (0x00000800)) {
        l547 = 0x00000800;
    }
    else if (l85 & (0x00000400)) {
        l547 = 0x00000400;
    }
    else if (l85 & (0x00002000)) {
        l547 = 0x00002000;
        l502 = "]";
    }
    l83[3] = '\0';
    l87 = l508(l76 & 0x00000010);
    strcpy(l75, l83);
    switch (l547) {
    case 0x00000200:
        strcat(l75, "Parse.cpp");
        break;
    case 0x00000100:
    case 0x00001000:
        strcat(l75, "Parse.c");
        break;
    case 0x00000800:
        strcat(l75, "Parser.cs");
        break;
    case 0x00000400:
        strcat(l75, "Parser.java");
        break;
    case 0x00002000:
        strcat(l75, "Parser.js");
        break;
    }
    l88 = fopen(l75, "w");
    if (!l88) {
        perror(l75);
        return;
    }
    fprintf(l88, "\n// %s - generated by the SLK parser generator \n\n",
        l75);
    switch (l547) {
    case 0x00000200:
    case 0x00000100:
    case 0x00001000:
        fprintf(l88, "#include \"%sParse.h\"\n\n", l83);
        break;
    }
    if (l84) {
        switch (l547) {
        case 0x00000200:
        case 0x00000800:
            fprintf(l88, "namespace %s {\n\n", l84);
            break;
        case 0x00000400:
            fprintf(l88, "package %s;\n\n", l84);
            break;
        }
    }
    switch (l547) {
    case 0x00000800:
        fprintf(l88, "class %sParser {\n\n", l83);
        break;
    case 0x00000400:
        fprintf(l88, "public class %sParser {\n\n", l83);
        break;
    }
    l133(l88, l85);
    if (l85 & 0x00000004) {
        l545(l85, l88);
    }
    else if (l85 & 0x00000008) {
        l134(l83, l84, l85, l88);
    }
    l546(l85, l88);
    switch (l547) {
    case 0x00000200:
    case 0x00000100:
    case 0x00001000:
        l91(l83, l84, l87,
            l85, l88, (l76 & 0x00000010));
        break;
    case 0x00000800:
    case 0x00000400:
    case 0x00002000:
        l90(l83, l84, l87,
            l85, l88, (l76 & 0x00000010));
        break;
    }
    if (l84) {
        switch (l547) {
        case 0x00000200:
        case 0x00000800:
            fprintf(l88, "\n\n}\n");
            break;
        }
    }
    fclose(l88);
    l92(l83, l84, l85);
}
static char l548[] =
"char *xxxGetSymbolName ( unsigned int   symbol )";
static char l549[] =
"{ if ( symbol >= START_ACTION  &&  symbol < END_ACTION ) {\n"
"      return ( GET_ACTION_NAME (symbol) );\n"
"  } else if ( symbol >= START_SYMBOL ) {\n"
"      return ( GET_NONTERMINAL_NAME (symbol) );\n"
"  } else if ( symbol > 0 ) {\n"
"      return ( GET_TERMINAL_NAME (symbol) );\n"
"  } else {\n"
"      return ( \"not a symbol\" );\n"
"  }\n"
"}\n";
static char l550[] =
"char *xxxGetProductionName ( unsigned int  production_number )";
static char l551[] =
"{\n"
"  return ( GET_PRODUCTION_NAME (production_number) );\n"
"}\n";
static char* l552 = "static char *",
* l553 = "static char *",
* l554 = "private static string[]",
* l555 = "private static String[]",
* l556 = "var",
* l557 = "not assigned";
static char* l558 = "",
* l559 = "={",
* l560 = "}";
static void
l561(FILE* l88)
{
    register l46** l179 = l143;
    fprintf(l88, "%s Nonterminal_name%s %s\"0\"\n\n", l557, l558, l559);
    while (*++l179)
        fprintf(l88, ",\"%s\"\n", (*l179)->l11);
    fprintf(l88, "%s;\n\n", l560);
}
static void
l562(FILE* l88)
{
    register l46** l244 = l144;
    fprintf(l88, "%s Terminal_name%s %s\"0\"\n\n", l557, l558, l559);
    while (*++l244)
        fprintf(l88, ",\"%s\"\n", (*l244)->l11);
    fprintf(l88, "%s;\n\n", l560);
}
static void
l563(FILE* l88)
{
    register l46** l490 = l145;
    fprintf(l88, "%s Action_name%s %s\"0\"\n\n", l557, l558, l559);
    while (*++l490)
        fprintf(l88, ",\"%s\"\n", (*l490)->l11);
    fprintf(l88, "%s;\n\n", l560);
}
static void
l564(FILE* l88)
{
    register l46*** l367 = l146,
        ** l126;
    fprintf(l88, "%s Production_name%s %s\"0\"\n\n", l557, l558, l559);
    while (*++l367) {
        l126 = *l367;
        fprintf(l88, ",\"%s -->", (*l126)->l11);
        while (*++l126) {
            fprintf(l88, " %s", (*l126)->l11);
        }
        fputs("\"\n", l88);
    }
    fprintf(l88, "%s;\n\n", l560);
}
static void
l565(char* l83,
    char* l84,
    l3 l85)
{
    FILE* l566;
    l5 l75[16];
    sprintf(l75, "%sString.h", l83);
    l566 = fopen(l75, "w");
    if (!l566) {
        perror(l75);
        l59(1101, "");
    }
    fprintf(l566, "\n// %s - generated by the SLK parser generator \n\n",
        l75);
    fprintf(l566, "#ifndef _%sSTRING_H\n#define _%sSTRING_H\n\n",
        l83, l83);
    if (l85 & 0x00000100) {
        fprintf(l566, "#ifdef __cplusplus\n"
            "extern \"C\" {\n"
            "#endif\n\n");
    }
    else if (l85 & 0x00000200) {
        if (l84) {
            fprintf(l566, "namespace %s {\n\n", l84);
        }
    }
    fprintf(l566, "%s;\n", l548);
    fprintf(l566, "%s;\n\n", l550);
    if (l85 & 0x00000100) {
        fprintf(l566, "#ifdef __cplusplus\n"
            "}\n"
            "#endif\n");
    }
    else if (l85 & 0x00000200) {
        if (l84) {
            fprintf(l566, "\n\n}\n");
        }
    }
    fprintf(l566, "\n#endif\n");
    fclose(l566);
}
static void
l567(char* l83,
    char* l84,
    FILE* l88,
    l3 l85)
{
    char* l568;
    for (l568 = l548; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l549; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l550; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    l565(l83, l84, l85);
    if (l85 & 0x00000010) {
        l561(l88);
    }
    if (l85 & 0x00000020) {
        l562(l88);
    }
    if (l85 & 0x00000040) {
        if (l145[1]) {
            l563(l88);
        }
        else {
            l85 &= ~0x00000040;
        }
    }
    if (l85 & 0x00000080) {
        l564(l88);
    }
    fprintf(l88, "#define START_SYMBOL %d\n", l156);
    fprintf(l88, "#define START_ACTION %d\n", l155);
    fprintf(l88, "#define END_ACTION %d\n", l155 + l149);
    if (l85 & 0x00000010) {
        fprintf(l88, "#define GET_NONTERMINAL_NAME(symbol) "
            "(Nonterminal_name [symbol - %d])\n",
            l156 - 1);
    }
    else {
        fprintf(l88, "#define GET_NONTERMINAL_NAME(symbol) \"no table\"\n");
    }
    if (l85 & 0x00000020) {
        fprintf(l88, "#define GET_TERMINAL_NAME(symbol) "
            "(Terminal_name [symbol])\n");
    }
    else {
        fprintf(l88, "#define GET_TERMINAL_NAME(symbol) \"no table\"\n");
    }
    if (l85 & 0x00000040) {
        fprintf(l88, "#define GET_ACTION_NAME(symbol) "
            "(Action_name [symbol-(START_ACTION-1)])\n");
    }
    else {
        fprintf(l88, "#define GET_ACTION_NAME(symbol) \"_action_\"\n");
    }
    if (l85 & 0x00000080) {
        fprintf(l88, "#define GET_PRODUCTION_NAME(number) "
            "(Production_name [number])\n\n");
    }
    else {
        fprintf(l88, "#define GET_PRODUCTION_NAME(number) \"no table\"\n\n");
    }
    fprintf(l88, "%s\n", l548);
    fprintf(l88, "%s\n", l549);
    fprintf(l88, "%s\n", l550);
    fprintf(l88, "%s\n", l551);
}
static void
l569(char* l83,
    char* l84,
    FILE* l88,
    l3 l85)
{
    if (l85 & 0x00000010) {
        l561(l88);
    }
    if (l85 & 0x00000020) {
        l562(l88);
    }
    if (l85 & 0x00000040) {
        if (l145[1]) {
            l563(l88);
        }
        else {
            l85 &= ~0x00000040;
        }
    }
    if (l85 & 0x00000080) {
        l564(l88);
    }
    if (l85 & 0x00000400) {
        fprintf(l88, "private static final short   START_SYMBOL = %d;\n",
            l156);
        fprintf(l88, "private static final short   START_ACTION = %d;\n",
            l155);
        fprintf(l88, "private static final short   END_ACTION = %d;\n\n",
            l155 + l149);
        fprintf(l88, "public static String  GetSymbolName ( short symbol )\n");
    }
    else if (l85 & 0x00000800) {
        fprintf(l88, "private const short   START_SYMBOL = %d;\n",
            l156);
        fprintf(l88, "private const short   START_ACTION = %d;\n",
            l155);
        fprintf(l88, "private const short   END_ACTION = %d;\n\n",
            l155 + l149);
        fprintf(l88, "public static string  GetSymbolName ( short symbol )\n");
    }
    fputs("{\n  if ( symbol >= START_ACTION && symbol < END_ACTION ) {\n", l88);
    if (l85 & 0x00000040) {
        fprintf(l88, "      return ( %s );\n",
            "Action_name [symbol - (START_ACTION-1)]");
    }
    else {
        fprintf(l88, "      return ( %s );\n", "\"_action_\"");
    }
    fputs("  } else if ( symbol >= START_SYMBOL ) {\n", l88);
    if (l85 & 0x00000010) {
        fprintf(l88, "      return ( %s );\n",
            "Nonterminal_name [symbol - (START_SYMBOL-1)]");
    }
    else {
        fprintf(l88, "      return ( %s );\n", "\"no table\"");
    }
    fputs("  } else if ( symbol > 0 ) {\n", l88);
    if (l85 & 0x00000020) {
        fprintf(l88, "      return ( Terminal_name [ symbol ] );\n");
    }
    else {
        fprintf(l88, "      return ( %s );\n", "\"no table\"");
    }
    fputs("  }\n", l88);
    fputs("  return ( \"not a symbol\" );\n", l88);
    fputs("}\n\n", l88);
    if (l85 & 0x00000400) {
        fputs("public static String  GetProductionName ( short production_number )\n", l88);
    }
    else if (l85 & 0x00000800) {
        fputs("public static string  GetProductionName ( short production_number )\n", l88);
    }
    if (l85 & 0x00000080) {
        fprintf(l88, "{\n  return ( %s );\n}\n",
            "Production_name [production_number]");
    }
    else {
        fprintf(l88, "{\n  return ( %s );\n}\n\n", "\"no table\"");
    }
    fprintf(l88, "\n\n};\n");
}
static void
l570(char* l83,
    char* l84,
    FILE* l88,
    l3 l85)
{
    if (l85 & 0x00000010) {
        l561(l88);
    }
    if (l85 & 0x00000020) {
        l562(l88);
    }
    if (l85 & 0x00000040) {
        if (l145[1]) {
            l563(l88);
        }
        else {
            l85 &= ~0x00000040;
        }
    }
    if (l85 & 0x00000080) {
        l564(l88);
    }
    fprintf(l88, "function  GetSymbolName ( symbol )\n");
    fputs("{\n  if ( symbol >= START_ACTION && symbol < END_ACTION ) {\n", l88);
    if (l85 & 0x00000040) {
        fprintf(l88, "      return ( %s );\n",
            "Action_name [symbol - (START_ACTION-1)]");
    }
    else {
        fprintf(l88, "      return ( %s );\n", "\"_action_\"");
    }
    fputs("  } else if ( symbol >= START_SYMBOL ) {\n", l88);
    if (l85 & 0x00000010) {
        fprintf(l88, "      return ( %s );\n",
            "Nonterminal_name [symbol - (START_SYMBOL-1)]");
    }
    else {
        fprintf(l88, "      return ( %s );\n", "\"no table\"");
    }
    fputs("  } else if ( symbol > 0 ) {\n", l88);
    if (l85 & 0x00000020) {
        fprintf(l88, "      return ( Terminal_name [ symbol ] );\n");
    }
    else {
        fprintf(l88, "      return ( %s );\n", "\"no table\"");
    }
    fputs("  }\n", l88);
    fputs("  return ( \"not a symbol\" );\n", l88);
    fputs("}\n\n", l88);
    fputs("function  GetProductionName ( production_number )\n", l88);
    if (l85 & 0x00000080) {
        fprintf(l88, "{\n  return ( %s );\n}\n",
            "Production_name [production_number]");
    }
    else {
        fprintf(l88, "{\n  return ( %s );\n}\n\n", "\"no table\"");
    }
}
void l92(char* l83,
    char* l84,
    l3 l85)
{
    int l547 = 0x00000100;
    FILE* l88;
    char l75[32];
    if (l85 & (0x00000100 | 0x00001000)) {
        l547 = 0x00000100;
        l557 = l552;
        l558 = "[]";
    }
    else if (l85 & (0x00000200)) {
        l547 = 0x00000200;
        l557 = l553;
        l558 = "[]";
    }
    else if (l85 & (0x00000800)) {
        l547 = 0x00000800;
        l557 = l554;
    }
    else if (l85 & (0x00000400)) {
        l547 = 0x00000400;
        l557 = l555;
    }
    else if (l85 & (0x00002000)) {
        l547 = 0x00002000;
        l557 = l556;
        l559 = "=[";
        l560 = "]";
    }
    l83[3] = '\0';
    strcpy(l75, l83);
    switch (l547) {
    case 0x00000200:
        strcat(l75, "String.cpp");
        break;
    case 0x00000100:
        strcat(l75, "String.c");
        break;
    case 0x00000800:
        strcat(l75, "String.cs");
        break;
    case 0x00000400:
        strcat(l75, "String.java");
        break;
    case 0x00002000:
        strcat(l75, "String.js");
        break;
    }
    l88 = fopen(l75, "w");
    if (!l88) {
        perror(l75);
        return;
    }
    fprintf(l88, "\n// %s - generated by the SLK parser generator \n\n",
        l75);
    switch (l547) {
    case 0x00000200:
    case 0x00000100:
        fprintf(l88, "#include \"%sString.h\"\n\n", l83);
        break;
    }
    if (l84) {
        switch (l547) {
        case 0x00000200:
        case 0x00000800:
            fprintf(l88, "namespace %s {\n\n", l84);
            break;
        case 0x00000400:
            fprintf(l88, "package %s;\n\n", l84);
            break;
        }
    }
    switch (l547) {
    case 0x00000800:
        fprintf(l88, "class %sString {\n\n", l83);
        break;
    case 0x00000400:
        fprintf(l88, "public class %sString {\n\n", l83);
        break;
    }
    switch (l547) {
    case 0x00000200:
    case 0x00000100:
        l567(l83, l84, l88,
            l85);
        break;
    case 0x00000800:
    case 0x00000400:
        l569(l83, l84, l88,
            l85);
        break;
    case 0x00002000:
        l570(l83, l84, l88, l85);
        break;
    }
    if (l84) {
        switch (l547) {
        case 0x00000200:
        case 0x00000800:
            fprintf(l88, "\n\n}\n");
            break;
        }
    }
    fclose(l88);
}
static char*
l571[] = {
    "NUL",
    "SOH",
    "STX",
    "ETX",
    "EOT",
    "ENQ",
    "ACK",
    "BEL",
    "BS",
    "HT",
    "LF",
    "VT",
    "FF",
    "CR",
    "SO",
    "SI",
    "DLE",
    "DC1",
    "DC2",
    "DC3",
    "DC4",
    "NAK",
    "SYN",
    "ETB",
    "CAN",
    "EM",
    "SUB",
    "ESC",
    "FS",
    "GS",
    "RS",
    "US",
    "SPACE",
    "NOT_",
    "QUOTE_",
    "POUND_",
    "DOLLAR_",
    "PERCENT_",
    "AND_",
    "SQUOTE_",
    "LPAREN_",
    "RPAREN_",
    "STAR_",
    "PLUS_",
    "COMMA_",
    "_",
    "DOT_",
    "SLASH_",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "COLON_",
    "SEMI_",
    "LESS_",
    "EQUAL_",
    "GREATER_",
    "QMARK_",
    "AT",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "LBRACK_",
    "BSLASH_",
    "RBRACK_",
    "CARET_",
    "_",
    "TICK_",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "LBRACE_",
    "OR_",
    "RBRACE_",
    "TILDE_",
    "HOUSE",
    0 };
static l5
l572(register l5* l65)
{
    if (!*l65) {
        return (*l65);
    }
    while (*l65) {
        ++l65;
    }
    return (*--l65);
}
char*
l123(char* l124,
    char* l125,
    l46** l126,
    int l127)
{
    register l5* l509 = (*l126)->l11;
    register l46* l573;
    int l574 = 0;
    static l5 l12[1024 * 2];
    strcpy(l12, l124);
    if (((*l509 >= '0' && *l509 <= '9'))) {
        if (!*l12) {
            *l12 = '_';
        }
    }
    else {
        while (*l509 == '-') {
            strcat(l12, "MINUS_");
            ++l509;
            l574 = 1;
        }
    }
    if ((*l126)->l38) {
        l509 += 2;
    }
    for (; *l509; ++l509) {
        if (*l509 == '_' && l574) {
            continue;
        }
        strcat(l12, l571[*l509]);
        l574 = (l572(l12) == '_');
    }
    if (l572(l12) != '_') {
        strcat(l12, "_");
    }
    strcat(l12, l125);
    if (l127) {
        l573 = l66(l12);
        if (!l573) {
            l67(11, 0, l12);
        }
        else if (l573->l9 == 11) {
            while (l573) {
                strcat(l12, "2_");
                l573 = l66(l12);
                if (!l573) {
                    l67(11, 0, l12);
                    break;
                }
                else if (l573->l9 != 11) {
                    break;
                }
            }
        }
    }
    return l12;
}
static char* l575[] =
{
    "\n",
    "productions -->  production productions\n",
    "productions -->  {5} \n",
    "production  -->  NONTERMINAL {1} : symbols {4} alternates ;\n",
    "production  -->  TERMINAL {1} : symbols {4} alternates ;\n",
    "alternates  -->  | {2} symbols {4} alternates\n",
    "alternates  -->\n",
    "symbols     -->  NONTERMINAL {3} symbols\n",
    "symbols     -->     TERMINAL {3} symbols\n",
    "symbols     -->     ACTION   {3} symbols\n",
    "symbols     -->\n" };
static int l576[][8] =
{
    {0},
    {0, 1, 1, 0, 0, 0, 0, 2},
    {0, 3, 4},
    {0, 0, 0, 0, 0, 5, 6},
    {0, 7, 8, 9, 0, 10, 10} };
static int l577[] =
{
    0,
    0, (1024 + 1), (1024 + 1) + 1,
    0, -5,
    0, 6, (1024 + 1) + 2, -4, (1024 + 1) + 3, 4, -1, 1,
    0, 6, (1024 + 1) + 2, -4, (1024 + 1) + 3, 4, -1, 2,
    0, (1024 + 1) + 2, -4, (1024 + 1) + 3, -2, 5,
    0,
    0, (1024 + 1) + 3, -3, 1,
    0, (1024 + 1) + 3, -3, 2,
    0, (1024 + 1) + 3, -3, 3,
    0,
    0 };
static int* l578[] =
{
    0, l577 + 1, l577 + 4, l577 + 6, l577 + 14, l577 + 22, l577 + 28, l577 + 29, l577 + 33, l577 + 37, l577 + 41, 0 };
static char* l579[] =
{
    "TYPE_NOT_ASSIGNED",
    "NONTERMINAL",
    "TERMINAL",
    "ACTION",
    "LHS_SEPARATOR",
    "NEW_ALTERNATE",
    "END_PRODUCTION",
    "END_PARSE_INPUT" };
static int l580[][4] =
{
    {0},
    {0, 7},
    {0, 1, 2, 7},
    {0, 6},
    {0, 5, 6} };
static void
l323(int l581,
    int l126,
    int l341)
{
    fprintf(stdout, "%u: %s: ", l69(), l70());
    if (l581) {
        fprintf(stdout, "missing %s\n", l579[l126]);
    }
    else if (!l126) {
        fputs("input remaining\n", stdout);
    }
    else if (l341 == 4) {
        fputs("missing production terminator \n", stdout);
    }
    else {
        fputs("syntax error\n", stdout);
        fprintf(stdout, "  input  = %s\n", l579[l341]);
        fprintf(stdout, "  symbol = %d\n", l126);
    }
    l63();
}
static void
l582(int l138,
    l46* l583)
{
    static l46* l170,
        ** l367;
    static l3 l584;
    static l46* l585[(1024 * 4) + 4];
    switch (l138) {
    case 1:
        l170 = l583;
        if (l170->l9 == 2) {
            l172(l170);
        }
    case 2:
        l584 = 0;
        l367 = l585;
        *l367 = l170;
        break;
    case 3:
        if (++l584 > (1024 * 4)) {
            *l367 = NULL;
            l188(NULL, l585);
            l59(1801, "production too long");
        }
        *++l367 = l583;
        break;
    case 4:
        *++l367 = NULL;
        l367 = l585;
        while (*++l367) {
            if ((*l367)->l9 != 3) {
                if (*l367 == l170) {
                    l62();
                    l170->l30 = 1;
                }
                else {
                    break;
                }
            }
        }
        l164(l585);
        break;
    case 5:
        l157();
        break;
    }
}
static l3
l431(register int l341,
    int* l481)
{
    while (*++l481)
        if (l341 == *l481)
            return (1);
    return (0);
}
void l77(int (*l78)(void),
    int l79)
{
    register int* l375,
        * l586;
    int l126,
        l341,
        l367,
        * l481;
    l46* l430;
    int l587[127 + 1];
    l375 = l587 + 127;
    *l375 = 0;
    if (--l375 > l587)
        *l375 = (1024 + 1);
    else
        l59(1802, "parse stack overflow");
    l341 = l78();
    if (l79) {
        fputs("\n\n\t\tPARSE DERIVATION\n\n", stdout);
    }
    for (l126 = (*l375++); l126; l126 = (*l375++)) {
        if (l126 >= (1024 + 1)) {
            l367 = l576[l126 - ((1024 + 1) - 1)][l341];
            if (l367) {
                if (l79) {
                    fputs(l575[l367], stdout);
                }
                l586 = l578[l367];
                while (*++l586) {
                    if (--l375 > l587)
                        *l375 = *l586;
                    else
                        l59(1802, "parse stack overflow");
                }
            }
            else {
                l323(0, l126, l341);
                l481 = l580[l126 - ((1024 + 1) - 1)];
                if (!l431(l341, l481))
                    while ((l341 = l78()) != 7)
                        if (l431(l341, l481))
                            break;
            }
        }
        else if (l126 > 0) {
            if (l126 == l341) {
                l430 = l47;
                l341 = l78();
            }
            else {
                l323(1, l126, l341);
            }
        }
        else {
            l582(-l126, l430);
        }
    }
    if (l341 != 7)
        l323(0, l126, l341);
}
char*
l80(l3 l81)
{
    return l579[l81];
}
l46* l47;
enum
{
    l588,
    l589,
    l590,
    l591,
    l592,
    l593
};
static l3 l594 = 0,
l595 = 0,
l596 = 1,
l597 = l588;
static int l598 = 1;
static char* l599,
* l600,
l601[32];
static int
l602(char* l11)
{
    int l603 = 0;
    if (l596) {
        l603 = !strncmp(l11, "__", 2);
    }
    if (!l603) {
        l603 = !strncmp(l11, "_action_", 8);
    }
    return l603;
}
static void
l604(char* l65,
    char l605)
{
    printf("%d:  %s %c\n", l598, l65, l605);
    l63();
}
static int
l78(void)
{
    register char* l326 = l600,
        * l327 = l600;
    int l39 = 0,
        l10 = 0,
        l9 = 0;
    char l325,
        * l606 = l600,
        * l607 = l327,
        * l340 = "not_assigned";
    for (;;) {
        l326 = l327;
        while ((*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f')) {
            if (*l327 == '\n') {
                l607 = l327;
                ++l598;
                ++l327;
                while ((*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f')) {
                    if (*l327 == '\n') {
                        ++l598;
                        switch (l597) {
                        case l588:
                        case l591:
                        case l592:
                            break;
                        case l593:;
                            l597 = l590;
                            l327 = l607;
                            l600 = l327;
                            return (l9 = 5);
                        case l589:
                        case l590:;
                            l597 = l588;
                            l600 = ++l327;
                            return (l9 = 6);
                        }
                    }
                    ++l327;
                }
                switch (l597) {
                case l588:
                case l591:
                case l589:
                case l592:
                    break;
                case l590:
                case l593:
                    l597 = l589;
                    break;
                }
            }
            if ((*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f')) {
                ++l327;
            }
            l326 = l327;
            l606 = l327;
        }
        if (*l327 == '/') {
            if (*(l327 + 1) == '/') {
                while (*++l327) {
                    if (*l327 == '\n') {
                        break;
                    }
                }
                continue;
            }
            else if (*(l327 + 1) == '*') {
                l327 += 1;
                while (*++l327) {
                    if (*l327 == '*' && *(l327 + 1) == '/') {
                        l327 += 2;
                        break;
                    }
                    else if (*l327 == '\n') {
                        ++l598;
                    }
                }
                continue;
            }
        }
        while (*l327 && !(*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f')) {
            ++l327;
        }
        switch (*l326) {
        case '\0':
            if (l597 != l588) {
                l9 = 6;
                l597 = l588;
            }
            else {
                l326 = "END_OF_SLK_INPUT";
                l47 = l66("END_OF_SLK_INPUT");
                if (!l47) {
                    l47 = l67(2, 0,
                        "END_OF_SLK_INPUT");
                    l171(l47);
                }
                l9 = 7;
                l597 = l588;
            }
            break;
        case '\\':
            l327 = ++l326;
            switch (*l327) {
            case '\r':
                if (*++l327 == '\n') {
                    ++l327;
                    ++l598;
                }
                continue;
            case '\n':
                if (*++l327 == '\r') {
                    ++l327;
                }
                ++l598;
                continue;
            case 'a':
                l10 = '\a';
                l326 = "\\a";
                break;
            case 'b':
                l10 = '\b';
                l326 = "\\b";
                break;
            case 'f':
                l10 = '\f';
                l326 = "\\f";
                break;
            case 't':
                l10 = '\t';
                l326 = "\\t";
                break;
            case 'v':
                l10 = '\v';
                l326 = "\\v";
                break;
            case 'n':
                l10 = '\n';
                l326 = "\\n";
                break;
            case 'r':
                l10 = '\r';
                l326 = "\\r";
                break;
            case '\\':
                l10 = '\\';
                l326 = "\\\\";
                break;
            case '\?':
                l10 = '\?';
                l326 = "\\\?";
                break;
            case '\'':
                l10 = '\'';
                l326 = "\\\'";
                break;
            case '\"':
                l10 = '\"';
                l326 = "\\\"";
                break;
            case 'x':
                *--l326 = '0';
                l10 = (int)strtol(l326, NULL, 0);
                *l326 = '\\';
                l327 += 2;
                break;
            case '/':
                if (*(l327 + 1) == '/') {
                    ++l327;
                    l10 = 258;
                    l326 = "//";
                    l39 = 1;
                }
                else if (*(l327 + 1) == '*') {
                    ++l327;
                    l10 = 259;
                    l326 = "/*";
                    l39 = 1;
                }
                else {
                    l10 = '/';
                }
                break;
            case '*':
                if (*(l327 + 1) == '/') {
                    ++l327;
                    l10 = 260;
                    l326 = "*/";
                    l39 = 1;
                }
                else {
                    l10 = '*';
                }
                break;
            case '[':
                l10 = '[';
                l326 = "[";
                l39 = 1;
                break;
            case ']':
                l10 = ']';
                l326 = "]";
                l39 = 1;
                break;
            case '{':
                l10 = '{';
                l326 = "{";
                l39 = 1;
                break;
            case '}':
                if (*(l327 + 1) == '+') {
                    ++l327;
                    l10 = 257;
                    l326 = "}+";
                    l39 = 1;
                }
                else {
                    l10 = '}';
                    l326 = "}";
                    l39 = 1;
                }
                break;
            default:
                l10 = *l327;
            }
            l9 = 2;
            ++l327;
            break;
        case ':':
        case '-':
        case '=':
            if (l597 == l591) {
                l9 = 4;
                l597 = l592;
                switch (*(l326 + 1)) {
                case '?':
                    if (!l47->l45) {
                        l47->l45 = 1;
                        ++l152;
                    }
                    break;
                case '!':
                    if (!l47->l35) {
                        l47->l35 = 1;
                        ++l151;
                    }
                    break;
                }
                break;
            }
        default:
            if (l327 <= l326 + 2) {
                switch (*l326) {
                case '[':
                    if (l327 == l326 + 1) {
                        l10 = '[';
                        if (l594) {
                            l10 = -1;
                            l326 = "\\[";
                        }
                    }
                    break;
                case ']':
                    if (l327 == l326 + 1) {
                        l10 = ']';
                        if (l594) {
                            l10 = -2;
                            l326 = "\\]";
                        }
                    }
                    break;
                case '{':
                    if (l327 == l326 + 1) {
                        l10 = '{';
                        if (l594) {
                            l10 = -3;
                            l326 = "\\{";
                        }
                    }
                    break;
                case '}':
                    if (*(l326 + 1) == '+') {
                        l10 = 257;
                        if (l594) {
                            l10 = -5;
                            l326 = "\\}+";
                        }
                    }
                    else {
                        if (l327 == l326 + 1) {
                            l10 = '}';
                            if (l594) {
                                l10 = -4;
                                l326 = "\\}";
                            }
                        }
                    }
                    break;
                default:
                    l10 = 0;
                }
                if (l10) {
                    l9 = 2;
                    l325 = *l327;
                    *l327 = '\0';
                    if (!(l47 = l66(l326))) {
                        l47 = l67(2, l10, l326);
                        if (!l594) {
                            l171(l47);
                        }
                    }
                    *l327 = l325;
                    if (l594) {
                        l47->l36 = 1;
                    }
                    else {
                        l47->l39 = 1;
                    }
                    break;
                }
            }
            if (!strncmp(l326, "_epsilon_", 9)) {
                ;
                if (l597 != l590) {
                    l597 = l593;
                }
                else {
                    l597 = l590;
                }
                continue;
            }
            if (l602(l326)) {
                l9 = 3;
                l10 = atoi(l326 + l73(l326));
                break;
            }
            if (l597 == l588) {
                l597 = l591;
                l9 = 1;
                l340 = (l327 - 1);
                switch (*l340) {
                case '?':
                case '!':
                    --l340;
                    break;
                }
                if (*l340 == ':') {
                    l327 = l340;
                }
            }
            else {
                l9 = 2;
            }
            if (l327 == l326 + 1) {
                if (l9 == 2) {
                    l10 = *l326;
                }
            }
            else if (l327 == l326 + 2) {
                if (!strncmp(l326, "*/", 2)) {
                    l604("extra '*/'", ' ');
                    l326 = l327;
                    l606 = l327;
                    continue;
                }
            }
        }
        l600 = l327;
        l599 = l326;
        switch (l9) {
        case 3:
        case 2:
        case 1:
            l325 = *l327;
            *l327 = '\0';
            l47 = l66(l326);
            if (!l47) {
                l47 = l67(l9, l10, l326);
                l171(l47);
            }
            *l327 = l325;
            if (l39) {
                l47->l39 = 1;
                if (l10 > 255) {
                    l47->l10 = 0;
                }
            }
        case 7:
        case 0:
            switch (l597) {
            case l588:;
                l597 = l591;
                break;
            case l589:
            case l593:;
                l9 = 5;
                l597 = l590;
                l600 = l606;
                break;
            case l592:;
                l597 = l590;
                break;
            default:;
            }
            break;
        default:;
        }
        return l9;
    }
}
static int
l608(void)
{
    register char* l326,
        * l327;
    int l490,
        l10 = 0,
        l9 = 0;
    char l325;
    char l510[64];
    l327 = l600;
    for (;;) {
        l326 = l327;
        l599 = l326;
        while ((*l326 == ' ' || *l326 == '\n' || *l326 == '\r' || *l326 == '\t' || *l326 == '\v' || *l326 == '\f')) {
            if (*l326 == '\n') {
                ++l598;
            }
            l327 = ++l326;
        }
        if (*l327 == '/') {
            if (*(l327 + 1) == '/') {
                while (*++l327) {
                    if (*l327 == '\n') {
                        break;
                    }
                }
                continue;
            }
            else if (*(l327 + 1) == '*') {
                l327 += 2;
                while (*++l327) {
                    if (*l327 == '*' && *(l327 + 1) == '/') {
                        l327 += 2;
                        break;
                    }
                    else if (*l327 == '\n') {
                        ++l598;
                    }
                }
                continue;
            }
        }
        if ((((*l327 >= 'a' && *l327 <= 'z')) || ((*l327 >= 'A' && *l327 <= 'Z')) || ((*l327 >= '0' && *l327 <= '9'))) || *l327 == '_') {
            do
                ++l327;
            while ((((*l327 >= 'a' && *l327 <= 'z')) || ((*l327 >= 'A' && *l327 <= 'Z')) || ((*l327 >= '0' && *l327 <= '9'))) || *l327 == '_');
            l9 = 2;
            l600 = l327;
            while ((*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f')) {
                ++l327;
            }
            if (*l327 == ':') {
                l9 = 1;
            }
            l327 = l600;
            l325 = *l327;
            *l327 = '\0';
            if (!(l47 = l66(l326))) {
                l47 = l67(l9, 0, l326);
                l171(l47);
            }
            *l327 = l325;
            l600 = l327;
            return l47->l9;
        }
        switch (*l327) {
        case '\0':
        l609:
            l47 = l66("END_OF_SLK_INPUT");
            if (!l47) {
                l47 = l67(2, 0,
                    "END_OF_SLK_INPUT");
                l171(l47);
            }
            l600 = l327;
            return 7;
        case '\n':
            ++l598;
            ++l327;
            break;
        case '{':
            l327 = ++l326;
            while ((*l326 == ' ' || *l326 == '\n' || *l326 == '\r' || *l326 == '\t' || *l326 == '\v' || *l326 == '\f')) {
                l327 = ++l326;
            }
            if (l595) {
                int l610 = 1;
                while (l610 > 0) {
                    if (*l327 == '}') {
                        --l610;
                        ++l327;
                    }
                    else if (*l327 == '{') {
                        ++l610;
                        ++l327;
                    }
                    else if (*l327 == '\n') {
                        l598++;
                        ++l327;
                    }
                    else if (!*l327) {
                        goto l609;
                    }
                    else {
                        ++l327;
                    }
                }
                if (l610 > 0) {
                    l604("missing", '}');
                }
                l47 = l66(l326);
            }
            else if (((*l327 >= '0' && *l327 <= '9'))) {
                l490 = atoi(l327);
                if (!l490) {
                    l604("invalid action specification", ' ');
                }
                while (*++l327) {
                    if (*l327 == '}') {
                        break;
                    }
                }
                if (*l327 == '}') {
                    ++l327;
                }
                else {
                    l604("missing", '}');
                }
                sprintf(l510, "_action_%u", l490);
                l47 = l66(l510);
                if (!l47) {
                    l47 = l67(3, l490, l510);
                    l171(l47);
                }
            }
            else {
                while (*++l327) {
                    if (*l327 == '}' || (*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f')) {
                        break;
                    }
                }
                l325 = *l327;
                *l327 = '\0';
                l47 = l66(l326);
                if (!l47 && *l326 != '$') {
                    l47 = l67(3, 0, l326);
                    l171(l47);
                }
                *l327 = l325;
                for (; *l327; ++l327) {
                    if (*l327 == '}') {
                        break;
                    }
                }
                if (*l327 == '}') {
                    ++l327;
                }
                else {
                    l604("missing", '}');
                }
            }
            l600 = l327;
            return 3;
        case '\'':
            ++l326;
            if (*++l327 == '\\') {
                switch (*++l327) {
                case 'b':
                    l10 = '\b';
                    break;
                case 'f':
                    l10 = '\f';
                    break;
                case 't':
                    l10 = '\t';
                    break;
                case 'n':
                    l10 = '\n';
                    break;
                case 'r':
                    l10 = '\r';
                    break;
                default:
                    l10 = *l327;
                }
            }
            else {
                l10 = *l327;
            }
            l325 = *++l327;
            *l327 = '\0';
            l47 = l66(l326);
            if (!l47) {
                l47 = l67(2, l10, l326);
                l171(l47);
            }
            *l327 = l325;
            if (l325 == '\'') {
                ++l327;
            }
            else {
                l604("missing", '\'');
            }
            l600 = l327;
            return (l47->l9);
        case '|':
            l600 = ++l327;
            return 5;
        case ':':
            switch (*++l327) {
            case '?':
                if (!l47->l45) {
                    l47->l45 = 1;
                    ++l152;
                }
                break;
            case '!':
                if (!l47->l35) {
                    l47->l35 = 1;
                    ++l151;
                }
                break;
            }
            l600 = ++l327;
            return (4);
        case ';':
            l600 = ++l327;
            return 6;
        default:
            l604("invalid character", *l327);
            l326 = ++l327;
        }
    }
}
l3 l69(void)
{
    return l598;
}
char*
l70(void)
{
    l3 l342;
    l342 = l600 - l599;
    l342 = l342 < 32 ? l342 : 32 - 1;
    l601[l342] = '\0';
    strncpy(l601, l599, l342);
    return l601;
}
l3 l71(void)
{
    return l594;
}
char*
l72(char* l11)
{
    if (!strncmp(l11, "_action_", 8)) {
        return "_action_";
    }
    if (!strncmp(l11, "__", 2)) {
        return "__";
    }
    return "";
}
l3 l73(char* l11)
{
    if (!strncmp(l11, "_action_", 8)) {
        return 8;
    }
    if (!strncmp(l11, "__", 2)) {
        return 2;
    }
    return 0;
}
int (*l74(char* l341,
    l3 l76))(void)
{
    int (*l347)(void) = NULL;
    l594 = (l76 & 0x00004000);
    l595 = (l76 & 0x00000008);
    l596 = !(l76 & 0x00008000);
    l597 = l588;
    l600 = l341;
    l598 = 1;
    if (l76 & 0x00000010) {
        if (l594) {
            puts("EBNF is not supported with the YACC-style scanner.");
        }
        else {
            l347 = l608;
        }
    }
    else {
        l347 = l78;
    }
    return l347;
}
l3 l219 = 7,
l220,
l221;
static l247* l611,
* l612,
* l613,
* l614;
static l239* l615;
static l239*
l616(void)
{
    register l239* l211 = l615;
    if (l211) {
        l615 = l211->l8;
        memset(l211, 0, sizeof(l239));
    }
    return l211;
}
static void
l617(register l239* l211)
{
    l212(&l211->l238);
    l211->l8 = l615;
    l615 = l211;
}
static l247*
l618(void)
{
    register l247* l211 = l614;
    if (l211) {
        l614 = l211->l8;
        memset(l211, 0, sizeof(l247) + (l219 * sizeof(void*)));
    }
    return l211;
}
static void
l619(register l247* l211)
{
    l239* l141 = l211->l23,
        * l620;
    while (l141) {
        l620 = l141;
        l141 = l141->l8;
        l617(l620);
    }
    l211->l8 = l614;
    l614 = l211;
}
static void
l621(l247* l279)
{
    register l247* l622;
    if (l613) {
        l622 = l613;
        for (; l622->l8; l622 = l622->l8) {
        }
        l622->l8 = l279;
    }
    else {
        l613 = l279;
    }
    l279->l8 = NULL;
}
static l247*
l623(void)
{
    register l247* l279;
    l3 l624 = sizeof(l247) +
        (l219 * sizeof(void*));
    static int l366 = 0;
    static l247* l367;
    if (--l366 > 0) {
        l367 = (l247*)((char*)l367 + l624);
        l279 = l367;
    }
    else {
        l366 = 0;
        l279 = l618();
        if (!l279) {
            l366 = 1024;
            l367 = (l247*)calloc(l366, l624);
            l279 = l367;
            if (!l279) {
                l59(1201, "out of memory");
            }
        }
    }
    l279->l244 = &l279->l246;
    l279->l242 = 1;
    return l279;
}
static l239*
l625(void)
{
    l239* l141;
    static int l366 = 0;
    static l239* l367;
    if (--l366 > 0) {
        ++l367;
        l141 = l367;
    }
    else {
        l366 = 0;
        l141 = l616();
        if (!l141) {
            l366 = 1024;
            l367 = (l239*)calloc(l366,
                sizeof(l239));
            l141 = l367;
            if (!l141) {
                l59(1202, "out of memory");
            }
        }
    }
    return l141;
}
static void
l626(register l46** l627,
    register l46** l628)
{
    while ((*l627++ = *l628++)) {
    }
}
static l3
l629(register l46** l627,
    register l46** l628)
{
    for (; *l627 == *l628; ++l627, ++l628) {
        if (!*l627) {
            break;
        }
    }
    return (*l627 == *l628);
}
static l3
l630(l239** l201,
    register l239* l428)
{
    register l239* l250;
    l239* l430 = NULL;
    if (l428->l8) {
        l59(1222, "append_production: new->next is not null");
    }
    if (!*l201) {
        *l201 = l428;
        return 1;
    }
    for (l250 = *l201; l250; l250 = l250->l8) {
        l430 = l250;
        if (l250->l236 == l428->l236) {
            if (l250->l138 == l428->l138) {
                return 0;
            }
        }
    }
    l430->l8 = l428;
    return 1;
}
static l194*
l631(register l239* l141,
    int l138)
{
    l194* l238 = NULL;
    for (; l141; l141 = l141->l8) {
        if (l141->l236 == l138) {
            l238 = l213(l141->l238);
            break;
        }
    }
    return l238;
}
static l3
l632(l239* l23,
    int l253,
    int l162)
{
    register l239* l167 = l23,
        * l168 = l23;
    l3 l474 = 0;
    for (; l167; l167 = l167->l8) {
        if (l167->l236 == l253) {
            break;
        }
    }
    for (; l168; l168 = l168->l8) {
        if (l168->l236 == l162) {
            break;
        }
    }
    if (!(l167 && l168)) {
        l59(1203, "production not found");
    }
    l474 = l209(l167->l238,
        l168->l238);
    if (l474) {
        l474 = l216(l167->l238);
        if (l474) {
            l474 = l226;
        }
    }
    return l474;
}
static l46*
l633(l239* l634,
    l239* l635)
{
    register l46** l386,
        ** l387;
    l46* l636,
        * l637,
        * l244 = NULL;
    if (!(l634 && l635)) {
        return l244;
    }
    l636 = *l634->l238->l170;
    l637 = *l635->l238->l170;
    l386 = l634->l238->l177;
    l387 = l635->l238->l177;
    if (*l386 && *l387) {
        l244 = l303((*l386)->l14, (*l387)->l14);
        if (l244) {
            return l244;
        }
    }
    if (l176(l386)) {
        if (l176(l387)) {
            l244 = l303(l636->l15, l637->l15);
            if (l244) {
                return l244;
            }
        }
        if (*l387) {
            l244 = l303(l636->l15, (*l387)->l14);
            if (l244) {
                return l244;
            }
        }
    }
    if (l176(l387)) {
        if (*l386) {
            l244 = l303((*l386)->l14, l637->l15);
            if (l244) {
                return l244;
            }
        }
    };
    ;
    l217(l634->l238->l170,
        l634->l238->l177);
    l217(l635->l238->l170,
        l635->l238->l177);
    return l244;
}
static l3
l638(void)
{
    register l247* l279 = l611;
    register l239* l634 = NULL,
        * l639 = NULL;
    l46* l244 = NULL;
    l3 l132 = 0,
        l323 = 0;
    for (; l279; l279 = l279->l8) {
        if (l279->l138 != ++l132) {
            l323 = 1;
            ;
            ;
            return l323;
        }
    }
    l220 = l132;
    if (l49 > 2) {
        ;
        ;
    }
    for (l279 = l611; l279; l279 = l279->l8) {
        l634 = l279->l23;
        if (!l634) {
            l323 = 1;
            ;
            ;
            continue;
        }
        l639 = l634->l8;
        if (!l639) {
            l323 = 1;
            ;
            ;
            continue;
        }
        l244 = l633(l634, l639);
        if (!l244) {
            ;
            ;
            l323 = 1;
            continue;
        }
        *l279->l244 = l244;
        while ((l639 = l639->l8)) {
            l244 = l633(l634, l639);
            if (!l244) {
                ;
                ;
                l323 = 1;
            }
            else if (*l279->l244 != l244) {
                l323 = 1;
                ;
                ;
                ;
                ;
                l217(l634->l238->l170,
                    l634->l238->l177);
                ;
                ;
                l217(l639->l238->l170,
                    l639->l238->l177);
            }
        }
    }
    if (l49 > 2 && l323) {
        ;
        ;
    }
    return l323;
}
static void
l640(l3 l132,
    l239* l162)
{
    register l247* l279 = l611,
        * l641 = NULL;
    l247* l642 = NULL;
    for (; l279; l279 = l279->l8) {
        if (l279->l138 == l132) {
            break;
        }
    }
    if (!l279) {
        l279 = l623();
        l279->l138 = l132;
        l642 = l279;
    }
    l630(&l279->l23, l162);
    if (l642) {
        if (!l611) {
            l611 = l279;
        }
        else {
            l279 = l611;
            l641 = l279;
            if (l279->l138 > l132) {
                l611 = l642;
                l642->l8 = l279;
            }
            else {
                for (; l279; l279 = l279->l8) {
                    if (l279->l138 > l132) {
                        l641->l8 = l642;
                        l642->l8 = l279;
                        break;
                    }
                    l641 = l279;
                }
                if (!l279) {
                    l641->l8 = l642;
                }
            }
        }
        l279 = l642;
    }
    if (l49 > 2) {
        l266(1);
    }
}
static l3
l643(void)
{
    register l46** l177,
        *** l367 = l146;
    l46** l170,
        ** l644;
    l194* l478;
    int l261 = 0;
    int l132;
    l239* l634 = NULL;
    l3 l323 = 0;
    while (*++l367) {
        l170 = *l367;
        l177 = l170;
        ++l261;
        while (*++l177) {
            if (!strncmp((*l177)->l11, "__dot_", 6)) {
                l132 = atoi((*l177)->l11 + 6);
                if (l132 <= 0) {
                    l323 = 1;
                    ;
                    ;
                    break;
                }
                if (l49 > 2) {
                    l188("  ", l170);
                }
                for (l644 = l177; (*l177 = *(l177 + 1)); ++l177) {
                }
                l478 = l199(l170, l644,
                    NULL, l196);
                l634 = l248(l261, l261,
                    l478);
                l640(l132, l634);
                break;
            }
        }
    }
    l323 |= l638();
    if (l49 > 2) {
        l266(1);
        if (l323) {
            ;
            ;
        }
    }
    return l323;
}
l3 l251(void)
{
    register l46** l177,
        *** l367 = l146;
    l46** l170,
        ** l644,
        * l244;
    l194* l478;
    int l261 = 0;
    l239* l634 = NULL,
        * l635 = NULL;
    l3 l323 = 0;
    ;
    ;
    while (*++l367) {
        l170 = *l367;
        l177 = l170;
        ++l261;
        while (*++l177) {
            if (!strcmp((*l177)->l11, "__dot_")) {
                for (l644 = l177; (*l177 = *(l177 + 1)); ++l177) {
                }
                l478 = l199(l170, l644,
                    NULL, l196);
                if (l634) {
                    l635 = l248(l261,
                        l261, l478);
                }
                else {
                    l634 = l248(l261,
                        l261, l478);
                }
                if (l49 > 2) {
                    l188("  ", l170);
                }
                break;
            }
        }
        if (l635) {
            break;
        }
    }
    if (l635) {
        l244 = l633(l634, l635);
        if (l244) {
            if (l49 > 2) {
                ;
                ;
            }
            l252(l244, l634, l635, 0);
        }
    }
    else {
        l323 = l643();
    }
    if (l49 > 2 && l323) {
        ;
        ;
    }
    return l323;
}
l239*
l248(int l138,
    l3 l236,
    l194* l478)
{
    register l239* l428;
    l428 = l625();
    l428->l138 = l138;
    l428->l236 = l236;
    l428->l238 = l478;
    return (l428);
}
l239*
l645(register l239* l250)
{
    register l239* l428;
    l428 = l625();
    l428->l138 = l250->l138;
    l428->l236 = l250->l236;
    l428->l238 = l213(l250->l238);
    return (l428);
}
l3 l252(l46* l244,
    l239* l253,
    l239* l162,
    l3 l245)
{
    register l247* l279 = l611,
        * l641 = NULL;
    l239* l141;
    l3 l382 = 0,
        l132 = 1;
    if (l49 > 2) {
        l264(l244, l253->l138, l162->l138);
    }
    for (; l279; l279 = l279->l8) {
        ++l132;
        l641 = l279;
        l141 = l279->l23;
        if (l141->l236 == l253->l236 &&
            *l279->l244 == l244) {
            if (l279->l245 == l245) {
                l382 = l630(&l279->l23,
                    l162);
                break;
            }
        }
    }
    if (!l279) {
        l279 = l623();
        l279->l138 = l132;
        l220 = l132;
        *l279->l244 = l244;
        l279->l245 = l245;
        l630(&l279->l23, l253);
        l630(&l279->l23, l162);
        if (l641) {
            l641->l8 = l279;
        }
        else {
            l611 = l279;
        }
        l382 = 1;
    }
    return (l382);
}
l3 l254(void* l240,
    l46* l244,
    int l253,
    l239* l162)
{
    register l247* l646,
        * l642;
    l247* l279 = (l247*)l240,
        * l641 = NULL;
    l239* l141;
    l3 l647 = 0;
    if (l279->l242 >= l219) {
        ;
        ;
        l59(1204, "");
    }
    if (l50) {
        l647 = l632(l279->l23, l253,
            l162->l236);
    }
    if (l647) {
        return l647;
    }
    l279->l244[l279->l242] = l244;
    l646 = l612;
    for (; l646; l646 = l646->l8) {
        l641 = l646;
        l141 = l646->l23;
        if (l141->l236 == l253 &&
            l629(l646->l244, l279->l244) &&
            l279->l245 == l646->l245) {
            l630(&l646->l23, l645(l162));
            l647 = l224;
            break;
        }
    }
    if (!l647) {
        l642 = l623();
        l626(l642->l244, l279->l244);
        l141 = l279->l23;
        for (; l141; l141 = l141->l8) {
            if (l141->l236 == l253) {
                break;
            }
        }
        if (!l141) {
            ;
            ;
            l59(1206, "");
        }
        l630(&l642->l23, l645(l141));
        l630(&l642->l23, l645(l162));
        l642->l241 = l279->l241;
        l642->l138 = l279->l138;
        l642->l242 = l279->l242 + 1;
        l642->l245 = l279->l245;
        if (l641) {
            l641->l8 = l642;
        }
        else {
            l612 = l642;
        }
        l647 = l225;
    }
    l279->l244[l279->l242] = NULL;
    return l647;
}
void l255(l3 l132)
{
    register l247* l646,
        * l8;
    for (l646 = l8 = l611; l8;) {
        if (l8->l138 == l132) {
            if (l8 == l611) {
                l646 = l8 = l611 = l611->l8;
            }
            else {
                l8 = l646->l8 = l8->l8;
            }
        }
        else {
            l646 = l8;
            l8 = l646->l8;
        }
    }
}
void l256(void)
{
    register l247* l646,
        * l620;
    for (l646 = l611; l646;) {
        if (l646->l243) {
            l620 = l646;
            l646 = l646->l8;
            l621(l620);
        }
        else {
            l646 = l646->l8;
        }
    }
    if (l54) {
        for (l646 = l611; l646;) {
            l620 = l646;
            l646 = l646->l8;
            l619(l620);
        }
    }
    l611 = l612;
    l612 = NULL;
}
l247*
l257(void)
{
    return l611;
}
l247*
l258(l3 l132)
{
    register l247* l279 = l611;
    for (; l279; l279 = l279->l8) {
        if (l279->l138 == l132) {
            break;
        }
    }
    return l279;
}
l247*
l648(void)
{
    return l613;
}
l3 l259(register l239* l141)
{
    register l239* l168;
    l3 l649 = 0;
    for (; l141; l141 = l141->l8) {
        l168 = l141->l8;
        for (; l168; l168 = l168->l8) {
            l649 = l209(l141->l238,
                l168->l238);
            if (l649) {
                break;
            }
        }
        if (l649) {
            break;
        }
    }
    return l649;
}
l3 l260(void* l240,
    l46* l244,
    int l236)
{
    register l247* l279 = (l247*)l240;
    register l239* l141 = l279->l23;
    l3 l435 = 0;
    for (; l141; l141 = l141->l8) {
        if (l141->l236 == l236) {
            l435 = 1;
            l141->l237 = l244;
            break;
        }
    }
    if (!l435) {
        ;
        ;
        l59(1208, "");
    }
    return l435;
}
l3 l262(l3 l94,
    l3* l97,
    l3 l263)
{
    register l247* l279;
    register l3* l647;
    l3 l650 = 0,
        l651 = 0,
        l652 = 0,
        l132 = 0,
        l653,
        l360 = 0;
    char l654[32];
    *l654 = '\0';
    if (l49 != 1) {
        printf("--------------------------------------------------\n\n");
    }
    for (l647 = &l97[1]; *l647 != -1; ++l647) {
        if (l94) {
            sprintf(l654, " %u", ++l132);
        }
        l653 = (*l647 & l234);
        if (*l647 & l228) {
            if (l49 != 1) {
                printf("Conflict%s on conditional nonterminal \n",
                    l654);
            }
        }
        else if (*l647 & l229) {
            if (l49 != 1) {
                printf("Conflict%s is being ignored by request,"
                    " using the first production\n",
                    l654);
            }
        }
        else if (*l647 & l226) {
            ++l651;
            printf("Conflict%s is ambiguous at level %u.\n",
                l654, l653);
        }
        else if (*l647 & l227) {
            ++l650;
            printf("Conflict%s is unresolvable at level %u.\n",
                l654, l653);
        }
        else if (*l647 & l231) {
            printf("Conflict%s is extended to level %u.\n",
                l654, l653 + 1);
        }
        else if (*l647 & l223) {
            if (l49 != 1) {
                printf("Conflict%s is resolved at level %u.\n",
                    l654, l653);
            }
        }
        else if ((*l647 & l233)) {
            printf("invalid conflict status = 0x%x \n", *l647);
            l59(1705, "");
        }
        else {
            if ((*l647 & l234)) {
                *l647 |= l227;
                ++l650;
                printf("Conflict%s is unresolvable at level %u.\n",
                    l654, l653);
            }
        }
    }
    l279 = l257();
    l132 = 0;
    for (l652 = 0; l279; l279 = l279->l8) {
        ++l652;
        if (l132 == 0 && !l52) {
            printf("\nconflicts remaining:\n\n");
        }
        if (l132 != l279->l138) {
            l132 = l279->l138;
            if (!l52) {
                printf("Conflict %d is unresolved\n", l132);
            }
        }
    }
    printf("--------------------------------------------------\n\n");
    if (l652) {
        printf("%d conflict(s) remain at lookahead level k=%d\n",
            l652, l219);
        l360 = 1;
    }
    if (l651) {
        printf("Ambiguity is suggested by %d ambiguous conflict(s)\n",
            l651);
        l360 = 1;
    }
    if (l650) {
        printf("Ambiguity is suggested by %d unresolvable conflict(s)\n",
            l650);
        l360 = 1;
    }
    if (l152) {
        printf("Backtracking will be used on %d conditional nonterminal(s)\n",
            l152);
    }
    if (l151) {
        printf("Conflicts were ignored by request on %d nonterminal(s)\n",
            l151);
    }
    if (!l360) {
        printf("Conflicts were resolved at lookahead level k=%d\n", l263);
    }
    return l360;
}
void l264(l46* l244,
    int l253,
    int l162)
{
    register l46** l126;
    ;
    ;
    l126 = l146[l253];
    ;
    ;
    while (*++l126) {
        ;
        ;
    };
    ;
    l126 = l146[l162];
    ;
    ;
    while (*++l126) {
        ;
        ;
    };
    ;
}
void l266(l3 l94)
{
    register l247* l279 = l611;
    register l239* l141;
    l46** l244;
    char* l655 = "not set";
    char l654[32];
    char l656[32];
    *l654 = '\0';
    *l656 = '\0';
    for (; l279; l279 = l279->l8) {
        l244 = l279->l244;
        if (*l244) {
            l655 = (*l244)->l11;
        }
        if (l94) {
            sprintf(l654, " %u", l279->l138);
        }
        if (l279->l245) {
            sprintf(l656, " in state %u",
                l279->l245);
        }
        printf("\nConflict%s:  parse table conflict under \"%s\"%s:\n",
            l654, l655, l656);
        l141 = l279->l23;
        for (; l141; l141 = l141->l8) {
            l190(l141->l138);
        }
    }
}
void l265(l3 l94)
{
    register l247* l279 = l613;
    register l239* l141;
    l46** l244;
    char* l657 = "$";
    char l654[32];
    *l654 = '\0';
    if (l66("$")) {
        l657 = "$$$";
    }
    printf("\n\n\t\t LOOKAHEAD STRINGS FOR RESOLVED CONFLICTS\n\n");
    for (; l279; l279 = l279->l8) {
        l244 = l279->l244;
        if (l94) {
            sprintf(l654, " %u", l279->l138);
        }
        printf("Conflict%s was resolved at lookahead level %u:\n",
            l654, l279->l242 + 1);
        l141 = l279->l23;
        for (; l141; l141 = l141->l8) {
            l190(l141->l138);
            printf("      Lookahead string:  ");
            l244 = l279->l244;
            while (*l244) {
                printf("%s ", (*l244)->l11);
                ++l244;
            }
            if (l141->l237) {
                printf("%s \n\n", l141->l237->l11);
            }
            else {
                printf("%s \n\n", l657);
            }
        }
    }
}
static l274* l658;
static l268*
l659(void)
{
    static int l366 = 0;
    static l268* l367;
    if (--l366 > 0) {
        return (++l367);
    }
    else {
        l366 = 1024;
        l367 = (l268*)calloc(l366, sizeof(l268));
        if (!l367) {
            l366 = 0;
            l59(1401, "out of memory");
        }
    }
    return l367;
}
static l271*
l660(void)
{
    static int l366 = 0;
    static l271* l278;
    if (--l366 > 0) {
        return (++l278);
    }
    else {
        l366 = 1024;
        l278 = (l271*)calloc(l366, sizeof(l271));
        if (!l278) {
            l366 = 0;
            l59(1402, "out of memory");
        }
    }
    return l278;
}
static l274*
l661(void)
{
    static int l366 = 0;
    static l274* l276;
    if (--l366 > 0) {
        return (++l276);
    }
    else {
        l366 = 16;
        l276 = (l274*)calloc(l366, sizeof(l274));
        if (!l276) {
            l366 = 0;
            l59(1403, "out of memory");
        }
    }
    return l276;
}
static l268*
l662(register l268* l367,
    register int l131)
{
    for (; l367; l367 = l367->l8) {
        if (l367->l131 == l131) {
            break;
        }
    }
    return l367;
}
static void
l663(register l268* l367)
{
    for (; l367; l367 = l367->l8) {
        ;
        ;
    };
    ;
}
static void
l664(l268** l367,
    int l131,
    int l141)
{
    register l268* l428,
        * l250 = *l367;
    l428 = l659();
    l428->l131 = l131;
    l428->l141 = l141;
    if (!l250) {
        *l367 = l428;
        return;
    }
    if (l250->l131 > l131) {
        l428->l8 = l250;
        *l367 = l428;
        return;
    }
    for (; l250; l250 = l250->l8) {
        if (!l250->l8) {
            l250->l8 = l428;
            break;
        }
        else if (l250->l8->l131 > l131) {
            l428->l8 = l250->l8;
            l250->l8 = l428;
            break;
        }
    }
}
l271*
l275(l274* l276,
    l46* l179)
{
    register l271* l278,
        ** l273;
    l273 = &l276->l273;
    if (!*l273) {
        *l273 = l660();
        (*l273)->l179 = l179;
        return *l273;
    }
    for (l278 = *l273; l278->l8; l278 = l278->l8) {
    }
    l278->l8 = l660();
    l278 = l278->l8;
    l278->l179 = l179;
    return l278;
}
l3 l277(l271* l278,
    register l286* l14,
    void* l279,
    l239* l162)
{
    register l46* l244;
    int l131,
        l253;
    l268** l367 = &l278->l270,
        * l665;
    l3 l647 = 0;
    for (; l14; l14 = l14->l8) {
        l244 = l14->l126;
        l131 = l244->l10;
        l665 = l662(*l367, l131);
        if (l665) {
            l253 = l665->l141;
            if (l253 != l162->l236) {
                if (l49 > 2) {
                    ;
                    ;
                    l264(l244, l253,
                        l162->l138);
                }
                l647 |= l254(l279, l244, l253,
                    l162);
            }
        }
        else {
            l664(l367, l131, l162->l236);
            l647 |= l223;
            l260(l279, l244, l162->l236);
        }
    }
    return l647;
}
l274*
l280(void)
{
    register l274* l276,
        * l646;
    l276 = l661();
    l646 = l658;
    if (l646) {
        while (l646->l8) {
            l646 = l646->l8;
        }
        l646->l8 = l276;
    }
    else {
        l658 = l276;
    }
    return l276;
}
l274*
l281(void)
{
    return (l658);
}
void l282(l271* l278,
    int l131,
    int l132)
{
    register l268* l367,
        * l665;
    l367 = l278->l270;
    l665 = l662(l367, l131);
    if (l665) {
        l665->l141 = (l132 + (l154 - 1));
    }
    else {
        ;
        ;
        l663(l367);
        l59(1404, "");
    }
}
static void
l666(l274* l276,
    int l667,
    int l132)
{
    register l268* l367;
    register l271* l278;
    int l141;
    l3 l668 = 0;
    for (l278 = l276->l273; l278; l278 = l278->l8) {
        if (++l668 != l132) {
            continue;
        }
        for (l367 = l278->l270; l367; l367 = l367->l8) {
            l141 = l367->l141;
            if ((l141 >= l154)) {
                if (l276->l8) {
                    l666(l276->l8,
                        l667 + 1,
                        (l141 - (l154 - 1)));
                }
            }
        }
        if (l49 > 1) {
            ;
            ;
            if (l49 > 1) {
                for (l367 = l278->l270; l367; l367 = l367->l8) {
                    ;
                    ;
                }
            }
        }
        l278->l270 = NULL;
        break;
    }
}
void l283(int l132)
{
    l274* l276;
    l276 = l281();
    l666(l276, 1, l132);
}
void l284(void)
{
    register l268* l367;
    register l271* l278;
    int l132,
        l141;
    l3 l516 = 0,
        l517;
    l3 l518;
    l274* l276;
    ;
    ;
    l276 = l281();
    l132 = l154;
    for (; l276; l276 = l276->l8) {
        l518 = 1;
        l517 = 0;
        for (l278 = l276->l273; l278; l278 = l278->l8) {
            ++l517;
        }
        l516 += l517;
        for (l278 = l276->l273; l278; l278 = l278->l8) {
            ;
            ;
            for (l367 = l278->l270; l367; l367 = l367->l8) {
                l141 = l367->l141;
                if ((l141 >= l154)) {
                    l141 += l516;
                    l518 = 0;
                };
                ;
            };
            ;
            ++l132;
        };
        ;
        if (l518) {
            break;
        }
    }
}
static void
l669(l274* l276,
    int l132,
    int l670)
{
    register l268* l367;
    register l271* l278;
    int l141;
    l3 l668 = 0;
    for (l278 = l276->l273; l278; l278 = l278->l8) {
        if (++l668 != l132) {
            continue;
        }
        for (l367 = l278->l270; l367; l367 = l367->l8) {
            l141 = l367->l141;
            if ((l141 >= l154)) {
                ;
                ;
                ;
                ;
                if (l276->l8) {
                    l669(l276->l8,
                        (l141 - (l154 - 1)),
                        l670 + 1);
                }
            }
        }
        break;
    }
}
void l285(void)
{
    register l46** l179 = l143;
    register l142* l20;
    l274* l276;
    int l132,
        l671;
    l276 = l281();
    ;
    ;
    while (*++l179) {
        l671 = 0;
        for (l20 = (*l179)->l20; l20; l20 = l20->l8) {
            if ((l20->l141 >= l154)) {
                l671 = 1;
                l132 = (l20->l141 - (l154 - 1));
                ;
                ;
                l669(l276, l132, 1);
            }
        }
        if (l671) {
            ;
            ;
        }
    }
}
static l3
l672(register l46** l177)
{
    for (; *l177; ++l177) {
        if ((*l177)->l9 == 3)
            continue;
        if (!(*l177)->l26) {
            break;
        }
    }
    return (*l177 == NULL);
}
static void
l673(l3 l647,
    l3 l674,
    l3 l384,
    l3 l94)
{
    l3 l653 = (l647 & l234);
    char l654[32];
    *l654 = '\0';
    if (l94) {
        sprintf(l654, " %u", l674);
    }
    if (l647 & l228) {
        ;
        ;
    }
    else if (l647 & l229) {
        ;
        ;
    }
    else if (l647 & l226) {
        ;
        ;
    }
    else if (l647 & l227) {
        ;
        ;
    }
    else if (l647 & l231) {
        ;
        ;
    }
    else if (l647 & l223) {
        ;
        ;
    }
    else if ((l647 & l233)) {
        ;
        ;
        l59(1704, "");
    }
    else {
        ;
        ;
    };
    ;
}
static l3
l675(l46* l676,
    l194** l238)
{
    register l46** l177,
        *** l367 = l146;
    l3 l382 = 0;
    while (*++l367) {
        l177 = *l367;
        while (*++l177) {
            if ((*l177)->l9 == 3)
                continue;
            if (*l177 == l676) {
                for (++l177; *l177 && ((*l177)->l9 == 3); ++l177)
                    ;
                l382 |= l203(l238, *l367, l177,
                    NULL, NULL, l197);
                while (*l177) {
                    if ((*l177)->l26) {
                        for (++l177; *l177 && ((*l177)->l9 == 3); ++l177)
                            ;
                        if (*l177) {
                            l382 |= l203(l238, *l367,
                                l177, NULL, NULL, l197);
                        }
                    }
                    else {
                        break;
                    }
                }
                if (!*l177) {
                    break;
                }
            }
        }
    }
    return l382;
}
static void
l677(l194** l238)
{
    register l194* l202;
    l3 l382 = 1;
    while (l382) {
        l382 = 0;
        for (l202 = *l238; l202; l202 = l202->l8) {
            if (l672(l202->l177)) {
                l382 |= l675(*l202->l170, l238);
            }
        }
    }
}
static void
l678(l194** l238)
{
    register l194* l202;
    register l46** l177;
    l3 l382 = 1;
    l194* l204;
    while (l382) {
        l382 = 0;
        for (l202 = *l238; l202; l202 = l202->l8) {
            l177 = l202->l177;
            if (!*l177) {
                l382 |= l203(l238, l202->l170, l177,
                    l202->l192, NULL,
                    l202->l193);
                continue;
            }
            l204 = l202;
            while (*l177 && (*l177)->l9 == 1) {
                l382 |= l205(l238,
                    (*l177)->l23, l204);
                if ((*l177)->l26) {
                    for (++l177; *l177 && ((*l177)->l9 == 3); ++l177)
                        ;
                    l382 |= l203(l238, l202->l170, l177,
                        l204->l192,
                        &l204,
                        l204->l193);
                }
                else {
                    break;
                }
            }
        }
    }
}
static l3
l679(l46* l676,
    l3* l680,
    l194** l681,
    l194** l238)
{
    register l194* l202;
    register l46** l177;
    l46** l682;
    l3 l683 = 0,
        l382;
    for (l202 = *l238; l202; l202 = l202->l8) {
        l177 = l202->l177;
        if (*l177 == l676) {
            for (++l177; *l177 && ((*l177)->l9 == 3); ++l177)
                ;
            l382 = l203(l681, l202->l170, l177,
                l202->l192, NULL,
                l202->l193);
            l683 |= l382;
            while (l382) {
                l382 = 0;
                if (l672(l177)) {
                    l382 = l679(*l202->l170, l680,
                        l681, l238);
                    l683 |= l382;
                }
                else {
                    *l680 = 0;
                }
                if (*l177) {
                    if ((*l177)->l26) {
                        for (++l177; *l177 && ((*l177)->l9 == 3); ++l177)
                            ;
                        if (*l177) {
                            l382 |= l203(l681,
                                l202->l170, l177,
                                l202->l192, NULL,
                                l202->l193);
                        }
                    }
                }
            }
        }
        else {
            l682 = l177 - 1;
            for (; *l682 && ((*l682)->l9 == 3); --l682)
                ;
            if (l682 > l202->l170 && *l682 == l676) {
                l382 = l203(l681, l202->l170, l177,
                    l202->l192, NULL,
                    l202->l193);
                l683 |= l382;
                while (l382) {
                    l382 = 0;
                    if (l672(l177)) {
                        l382 = l679(*l202->l170, l680,
                            l681,
                            l238);
                        l683 |= l382;
                    }
                    else {
                        *l680 = 0;
                    }
                    if (*l177) {
                        if ((*l177)->l26) {
                            for (++l177; *l177 && ((*l177)->l9 == 3); ++l177)
                                ;
                            if (*l177) {
                                l382 |= l203(l681,
                                    l202->l170, l177,
                                    l202->l192, NULL,
                                    l202->l193);
                            }
                        }
                    }
                }
            }
        }
    }
    return l683;
}
static l3
l684(l194** l238,
    l46** l170,
    l46* l244)
{
    register l194* l202;
    l46** l177,
        * l609,
        ** l644;
    l3 l382 = 1,
        l685 = 0,
        l680 = 1;
    l194* l686 = NULL;
    l194* l192,
        * l687;
    for (l202 = *l238; l202; l202 = l202->l8) {
        l177 = l202->l177;
        if (*l177 == l244) {
            l685 = 1;
            for (++l177; *l177 && ((*l177)->l9 == 3); ++l177)
                ;
            l202->l177 = l177;
            l203(&l686, l202->l170, l177,
                l202->l192, NULL,
                l202->l193);
            l644 = l177;
            if (l672(l177)) {
                if (l48 < -3) {
                    l217(l202->l170, l177);
                }
                l192 = l202->l192;
                if (!l192) {
                    if (l48 < -3) {
                        ;
                        ;
                    }
                    if (l202->l170 != l170) {
                        l680 = 0;
                    }
                }
                while (l192) {
                    if (l48 < -3) {
                        ;
                        ;
                        l217(l192->l170, l192->l177);
                    }
                    l177 = l192->l177;
                    for (++l177; *l177 && ((*l177)->l9 == 3); ++l177)
                        ;
                    if (*l177) {
                        l382 |= l203(&l686,
                            l192->l170, l177,
                            l192->l192,
                            NULL,
                            l192->l193);
                        while ((*l177)->l26) {
                            for (++l177; *l177 && ((*l177)->l9 == 3); ++l177)
                                ;
                            if (*l177) {
                                l382 |= l203(&l686,
                                    l192->l170, l177,
                                    l192->l192,
                                    NULL,
                                    l192->l193);
                            }
                            else {
                                break;
                            }
                        }
                    }
                    if (!l672(l177)) {
                        l680 = 0;
                        break;
                    }
                    l192 = l192->l192;
                }
            }
            else {
                l680 = 0;
            }
            l177 = l644;
            if (l672(l177)) {
                l679(*l202->l170, &l680,
                    &l686, l238);
            }
            while (*l177) {
                if ((*l177)->l26) {
                    for (++l177; *l177 && ((*l177)->l9 == 3); ++l177)
                        ;
                    if (*l177) {
                        l382 |= l203(&l686, l202->l170, l177,
                            l202->l192, NULL,
                            l202->l193);
                    }
                }
                else {
                    break;
                }
            }
        }
    }
    l214(l238);
    *l238 = l686;
    l686 = NULL;
    if (l685) {
        for (l202 = *l238; l202; l202 = l202->l8) {
            l177 = l202->l177;
            if (l672(l177)) {
                if (l202->l193) {
                    l687 = NULL;
                    l203(&l687, l202->l170, l177,
                        l202->l192, NULL,
                        l202->l193);
                    l677(&l687);
                    l205(l238, l687, NULL);
                    l212(&l687);
                }
            }
        }
    }
    else {
        l680 = 0;
        l609 = l66("END_OF_SLK_INPUT");
        if (l244 != l609) {
            ;
            ;
            l59(1706, "");
        }
    }
    return l680;
}
static l3
l688(l247* l279)
{
    register l239* l141,
        * l385;
    l3 l474 = 0;
    l141 = l279->l23;
    for (; l141; l141 = l141->l8) {
        l385 = l141->l8;
        for (; l385; l385 = l385->l8) {
            l474 = l209(l141->l238,
                l385->l238);
            if (l474) {
                l474 = l216(
                    l141->l238);
                if (l474) {
                    l474 = l226;
                    return l474;
                }
            }
        }
    }
    return l474;
}
static l3
l689(l247* l279,
    l271* l278,
    l239* l141)
{
    register l194* l202,
        * l430;
    register l46** l177;
    l46** l170,
        * l609,
        * l690;
    l3 l647 = 0,
        l680,
        l691 = 0,
        l242 = l279->l242;
    l46** l244 = l279->l244;
    l194* l687;
    l3 l261 = l141->l138;
    l194** l238 = &l141->l238;
    l170 = l146[l261];
    if (l242 == 1) {
        l177 = l170;
        l690 = *l170;
        for (++l177; *l177 && ((*l177)->l9 == 3); ++l177)
            ;
        if (l690->l45) {
            if (l49) {
                ;
                ;
            }
            return l228;
        }
        if (l690->l35) {
            if (l49) {
                ;
                ;
            }
            return l229;
        }
        if (l690->l44) {
            if (l49) {
                ;
                ;
            }
            return l226;
        }
        l677(l238);
    }
    l678(l238);
    if (l48 < -2) {
        ;
        ;
        ;
        ;
        l218(l238);
    }
    l680 = l684(l238, l170,
        l244[l242 - 1]);
    while (l680) {
        l177 = l170;
        for (++l177; *l177 && ((*l177)->l9 == 3); ++l177)
            ;
        if (l672(l177)) {
            break;
        }
        for (; *l177; ++l177) {
        }
        l687 = NULL;
        l203(&l687, l170, l177, NULL, NULL,
            l196);
        l677(&l687);
        l205(l238, l687, NULL);
        l212(&l687);
        break;
    }
    for (l202 = *l238; l202; l202 = l202->l8) {
        l177 = l202->l177;
        if (*l177) {
            l691 = 1;
            break;
        }
    }
    if (!l691) {
        for (l202 = *l238; l202; l202 = l202->l8) {
            l177 = l202->l177;
            if (!*l177) {
                if ((*l202->l170)->l41) {
                    l609 = l66("END_OF_SLK_INPUT");
                    if (l244[l242 - 1] != l609) {
                        l691 = 1;
                    }
                }
            }
        }
    }
    if (l48 < -1) {
        ;
        ;
        ;
        ;
        l218(l238);
    }
    if (l49) {
        ;
        ;
    }
    if (l691) {
        for (l202 = *l238; l202;) {
            l177 = l202->l177;
            if (*l177) {
                if (l49) {
                    l217(l202->l170, l177);
                }
                l647 |= l277(l278, (*l177)->l14,
                    l279, l141);
            }
            else if ((*l202->l170)->l41) {
                if (l49) {
                    l217(l202->l170, l177);
                }
            }
            else {
                if (l202 == *l238) {
                    *l238 = l202->l8;
                    l210(l202);
                    l202 = *l238;
                }
                else {
                    l430 = *l238;
                    for (; l430->l8; l430 = l430->l8) {
                        if (l430->l8 == l202) {
                            l430->l8 = l202->l8;
                            l210(l202);
                            l202 = l430->l8;
                            break;
                        }
                    }
                }
                continue;
            }
            l202 = l202->l8;
        }
    }
    else {
        l647 = l227;
    }
    if (l49) {
        ;
        ;
    }
    return l647;
}
static l3
l692(l247* l279,
    l3 l653,
    int l132,
    l274* l276)
{
    register l239* l141;
    l46* l170;
    int l131,
        l253;
    l3 l647 = 0;
    l271* l278,
        * l241;
    l141 = l279->l23;
    l253 = l141->l138;
    l170 = *l146[l253];
    l278 = l275(l276, l170);
    l241 = (l271*)l279->l241;
    l279->l241 = l278;
    for (; l141; l141 = l141->l8) {
        l647 |= l689(l279, l278, l141);
    }
    if (!l647) {
        return l647;
    }
    if (l50) {
        l647 |= l688(l279);
    }
    l131 = (l279->l244[l653 - 1])->l10;
    if (l653 == 1) {
        if ((l647 & l232)) {
            if (l170->l20) {
                l173(l170->l20, l131, l132);
            }
            else {
                l130(l131, l132);
            }
        }
    }
    else {
        if ((l647 & l232)) {
            l282(l241, l131, l132);
        }
    }
    return l647;
}
static void
l693(l3* l97,
    l3* l694)
{
    register l3* l647 = &l97[1],
        * l253 = &l694[1];
    register l46* l170;
    int l132 = 1;
    for (; *l647 != -1; ++l647, ++l253, ++l132) {
        if (*l647 & l230) {
            if (!*l253) {
                ;
                ;
                l59(1701, "no production number");
            }
            l170 = *l146[*l253];
            if (l49 > 2) {
                ;
                ;
            }
            l174(l170->l20, l132,
                *l253);
            l255(l132);
        }
    }
}
l3 l93(l3 l94,
    l3 l95,
    l3 l96,
    l3* l97)
{
    register l247* l279;
    l46** l244;
    int l132;
    l3 l653,
        l263 = 1,
        l695 = l220,
        l647,
        * l694;
    l274* l276;
    l694 = calloc(l220 + 4, sizeof(l3));
    if (!l694) {
        l59(1703, "out of memory");
    }
    for (l653 = 1; l653 < l219; ++l653) {
        l279 = l257();
        if (!l279) {
            break;
        }
        if (l49) {
            ;
            ;
        }
        l132 = 0;
        l276 = l280();
        for (; l279; l279 = l279->l8) {
            ++l132;
            if (!(l49 || (l132 % 2000))) {
                ;
                ;
                fflush(stdout);
            }
            if (l95) {
                if (l653 == 1) {
                    if (l132 != l95) {
                        continue;
                    }
                }
            }
            if (l96) {
                if (l653 > 1) {
                    if (l132 != l96) {
                        if (l279->l8) {
                            continue;
                        }
                    }
                }
            }
            l647 = l97[l279->l138];
            if (l647 & l230) {
                if (!l95) {
                    continue;
                }
            }
            if (l49) {
                ;
                ;
                l244 = l279->l244;
                while (*l244) {
                    ;
                    ;
                    ++l244;
                };
                ;
            }
            l647 = l692(l279, l653,
                l132, l276);
            if ((l647 & l233) == l223) {
                l263 = l653 + 1;
                l279->l243 = 1;
            }
            l647 |= l653;
            if ((l97[l279->l138] & l234) == l653) {
                l97[l279->l138] |= l647;
            }
            else {
                l97[l279->l138] = l647;
            }
            l694[l279->l138] = l279->l23->l138;
            if (l49) {
                l673(l647, l279->l138,
                    l279->l23->l138, l94);
            }
        }
        l221 += l132;
        l695 = l221;
        l256();
    }
    l693(l97, l694);
    l215();
    return l263;
}
static struct
{
    l46** l375,
        * l376[63 + 1];
} l452 = { l452.l376 + 63 };
static l46* l696[(1024 * 4) + 4];
static l3
l697(register l46* l179)
{
    register l46** l379 = l452.l375;
    while (*l379) {
        if (*l379++ == l179) {
            return 0;
        }
    }
    return 1;
}
static char*
l698(char* l250)
{
    l46* l126;
    l3 l342;
    l3 l138;
    static char l699[512];
    char* l327;
    l342 = strlen(l250);
    if (l342 >= sizeof(l699) - 12) {
        if (l48 > 0) {
            l186();
        }
        printf("old string too long:\n  %s\n", l250);
        l59(1903, "");
    }
    sprintf(l699, "more_%s", l250);
    for (l327 = l699; *l327; ++l327) {
    }
    for (l138 = 2; l138 < 1000; ++l138) {
        l126 = l66(l699);
        if (l126) {
            sprintf(l327, "_%u", l138);
        }
        else {
            break;
        }
    }
    return l699;
}
static char*
l700(char* l250)
{
    l46* l126;
    l3 l342;
    l3 l138;
    static char l699[512];
    char* l327;
    l342 = strlen(l250);
    if (l342 >= sizeof(l699) - 12) {
        if (l48 > 0) {
            l186();
        }
        printf("old string too long:\n  %s\n", l250);
        l59(1904, "");
    }
    sprintf(l699, "%s_tail", l250);
    for (l327 = l699; *l327; ++l327) {
    }
    for (l138 = 2; l138 < 1000; ++l138) {
        l126 = l66(l699);
        if (l126) {
            sprintf(l327, "_%u", l138);
        }
        else {
            break;
        }
    }
    return l699;
}
static l46*
l701(char* l11)
{
    register l46* l428;
    l428 = l67(1, 0, l11);
    l171(l428);
    return l428;
}
static l46*
l702(char* l11)
{
    register l46* l126 = NULL;
    if (!l11) {
        return l126;
    }
    l126 = l66(l11);
    if (l126) {
        if (l126->l9 != 1) {
            printf("%s: not a nonterminal: type = %s \n", l126->l11,
                l80(l126->l9));
            l126 = NULL;
        }
    }
    else {
        if (l48 > 2) {
            printf("%s: not a symbol \n", l11);
        }
    }
    return l126;
}
static l46**
l703(register l46** l167,
    register l46** l168)
{
    while ((*l167++ = *l168++)) {
    }
    return --l167;
}
static void
l704(l46* l705,
    l46* l706)
{
    register l46*** l367,
        *** l384;
    l46** l707;
    for (;;) {
        if (l48 > 3) {
            l186();
        }
        l367 = l146;
        l384 = NULL;
        while (*++l367) {
            if (**l367 == l706) {
                l384 = l367;
                if (l48 > 2) {
                    l188("  first_production  = ",
                        *l384);
                }
                break;
            }
        }
        if (!l384) {
            break;
        }
        for (; *l367; ++l367) {
            if (**l367 == l705) {
                l707 = *l367;
                if (l48 > 2) {
                    l188("    move_production = ",
                        l707);
                }
                l163(l367);
                l161(l707, l384);
                break;
            }
        }
        if (!*l367) {
            break;
        }
    }
}
static l3
l708(l46* l179)
{
    register l46*** l709,
        *** l710;
    char* l699;
    l3 l138 = 0,
        l711,
        l712 = 0,
        l713,
        l714 = 0,
        l715 = 0;
    l46*** l384,
        *** l716,
        ** l177,
        * l170,
        * l717,
        ** l428,
        ** l141[128];
    if (l48 > 0) {
        printf("direct left factoring %s \n", l179->l11);
    }
    for (l710 = l146; *++l710;) {
        if (**l710 == l179) {
            l141[l138] = *l710;
            if (l138 == 0) {
                l384 = l710;
            }
            if (++l138 >= 128) {
                if (l48 > 2) {
                    l186();
                }
                printf("direct_left_factor: more than 127 productions "
                    "of nonterminal '%s'\n",
                    l179->l11);
                return l715;
            }
        }
    }
    if (l138 <= 1) {
        return l715;
    }
    l716 = &l141[l138 - 1];
    l709 = l141;
    for (; l709 < l716; ++l709) {
        l710 = l709;
        while (++l710 <= l716) {
            if (l710[0][1] == l709[0][1]) {
                l714 = 1;
                break;
            }
        }
        if (l714) {
            break;
        }
    }
    if (!l714) {
        return l715;
    }
    l715 = 1;
    l170 = **l709;
    l710 = l709;
    while (++l710 <= l716) {
        if (l710[0][1] != l709[0][1]) {
            *l710 = NULL;
        }
    }
    for (l713 = 1;; ++l713) {
        l710 = l709;
        while (++l710 <= l716) {
            if (!*l710) {
                continue;
            }
            if (l710[0][l713] != l709[0][l713]) {
                --l713;
                l712 = 1;
                break;
            }
        }
        if (l712) {
            break;
        }
    }
    l428 = l696;
    l177 = *l709;
    for (l711 = 0; l711 <= l713; ++l711) {
        *l428++ = *l177++;
    }
    l699 = l700(l170->l11);
    l717 = l701(l699);
    *l428++ = l717;
    *l428 = NULL;
    l428 = l160(l696);
    l161(l428, l384);
    l710 = l709;
    for (; l710 <= l716; ++l710) {
        if (!*l710) {
            continue;
        }
        l710[0][0] = l717;
        l703(&l710[0][1],
            &l710[0][l713 + 1]);
    }
    l704(l170, l717);
    l717->l32 = 1;
    l178(l717);
    return l715;
}
static l3
l718(l46** l386,
    l46*** l253)
{
    register l46*** l367;
    l46** l177,
        * l170 = *l386,
        ** l428;
    l3 l719 = 0;
    if (l48 > 0) {
        printf("looking for %s productions \n", l170->l11);
    }
    for (l367 = l146; *++l367;) {
        if (**l367 == l170) {
            break;
        }
    }
    if (l48 > 0) {
        l188("first production: ", *l367);
    }
    for (l428 = NULL; *l367 && **l367 == l170; ++l367) {
        l428 = l696;
        l177 = *l253;
        for (; l177 != l386; ++l177) {
            *l428++ = *l177;
        }
        l428 = l703(l428, &l367[0][1]);
        l703(l428, ++l177);
        l428 = l160(l696);
        if (l161(l428, l253)) {
            ++l253;
            ++l719;
            if (l48 > 0) {
                l188("inserted: ", l428);
            }
        }
    }
    if (l428) {
        if (l48 > 0) {
            l188("deleting: ", *l253);
        }
        l163(l253);
    }
    if (l48 > 0) {
        putchar('\n');
    }
    return l719;
}
static l3
l720(l46* l179,
    l3 l721)
{
    register l46** l386,
        ** l387;
    l46*** l709,
        *** l722,
        *** l723,
        ** l724 = NULL,
        * l170,
        * l126;
    l3 l719,
        l725 = 0;
    if (l48 > 0) {
        printf("indirect left factoring %s \n", l179->l11);
    }
    for (l709 = l146; *++l709;) {
        if (**l709 == l179) {
            break;
        }
    }
    for (; *l709; ++l709) {
        if (**l709 != l179) {
            break;
        }
        for (l722 = l709; *++l722;) {
            if (**l722 != l179) {
                break;
            }
            l386 = *l709;
            l387 = *l722;
            for (++l386, ++l387; *l386 && *l387;) {
                if ((*l386)->l27 && !l724) {
                    l724 = l386;
                    l723 = l709;
                }
                if ((*l387)->l27 && !l724) {
                    l724 = l387;
                    l723 = l722;
                }
                if (*l386 == *l387) {
                    ++l386;
                    ++l387;
                    continue;
                }
                if (l721) {
                    l126 = l308((*l386)->l17,
                        (*l387)->l17);
                }
                else {
                    l126 = l303((*l386)->l17,
                        (*l387)->l17);
                    if (!l126) {
                        l126 = l303((*l386)->l14,
                            (*l387)->l14);
                    }
                }
                if (l126) {
                    l725 = 1;
                    break;
                }
                break;
            }
            if (l725) {
                break;
            }
        }
        if (l725) {
            break;
        }
    }
    if (!l725) {
        if (l290(0, l179)) {
            return l725;
        }
        if (l724) {
            l719 = l718(l724,
                l723);
            if (l719) {
                l725 = 1;
            }
        }
        return l725;
    }
    if (l48 > 0) {
        printf("%s: common indirect symbol needs factoring in \n",
            l126->l11);
        l217(*l709, l386);
        l217(*l722, l387);
    }
    l170 = **l722;
    if (l170 == *l387) {
        printf("configuration is left recursive, cannot factor: \n");
        l217(*l722, l387);
        l725 = 0;
        return l725;
    }
    l170 = **l709;
    if (l170 == *l386) {
        printf("configuration is left recursive, cannot factor: \n");
        l217(*l709, l386);
        l725 = 0;
        return l725;
    }
    if (!l98(*l386, *l387, 0)) {
        l719 = l718(l386, l709);
        if (l719) {
            l170->l32 = 1;
            --l719;
            l722 += l719;
        }
    }
    if (!l98(*l387, *l386, 0)) {
        l719 = l718(l387, l722);
        if (l719) {
            l170->l32 = 1;
        }
    }
    if (l48 > 0) {
        l191(l179);
        putchar('\n');
    }
    return l725;
}
static l3
l726(void)
{
    register l46** l179;
    l3 l711, l727,
        l323 = 0,
        l715;
    for (l727 = 0; l727 < 9; ++l727) {
        if (!l291(l49)) {
            break;
        }
        for (l179 = l143; *++l179;) {
            if ((*l179)->l32) {
                for (l711 = 0; l711 < 29; ++l711) {
                    l715 = l708(*l179);
                    if (!l715) {
                        break;
                    }
                }
                if (l711 >= 29) {
                    printf("depth exceeded during direct left factoring"
                        " of %s\n",
                        (*l179)->l11);
                    l323 = 1;
                }
            }
        }
    }
    if (l727 >= 9) {
        printf("outer depth exceeded during direct left factoring\n");
        l323 = 1;
    }
    return l323;
}
static l3
l728(void)
{
    register l46** l179;
    l3 l711, l727, l729,
        l323 = 0,
        l715;
    for (l729 = 0; l729 < 3; ++l729) {
        for (l727 = 0; l727 < 9; ++l727) {
            if (!l292(l49)) {
                break;
            }
            for (l179 = l143; *++l179;) {
                if ((*l179)->l33) {
                    for (l711 = 0; l711 < 29; ++l711) {
                        l715 = l720(*l179, 1);
                        if (!l715) {
                            break;
                        }
                    }
                    if (l711 >= 29) {
                        printf("depth exceeded during indirect left factoring"
                            " of %s\n",
                            (*l179)->l11);
                        l323 = 1;
                    }
                }
            }
        }
        if (l727 >= 9) {
            printf("outer depth exceeded during indirect left factoring\n");
            l323 = 1;
        }
        if (!l323) {
            l726();
        }
    }
    return l323;
}
static l3
l730(l46* l126)
{
    register l46*** l367 = l146,
        ** l177;
    l3 l398 = 0;
    while (*++l367) {
        if (**l367 == l126) {
            l177 = *l367;
            while (*++l177) {
                if ((*l177)->l9 == 2) {
                    break;
                }
                if ((*l177)->l9 == 1) {
                    if (*l177 == l126) {
                        l398 = 1;
                    }
                    break;
                }
            }
        }
        if (l398) {
            break;
        }
    }
    return l398;
}
static void
l731(l46* l732)
{
    register l46*** l367,
        ** l177,
        ** l428;
    l46** l170,
        * l733;
    l3 l9,
        l734 = 0,
        l584;
    l46* l162[4];
    if (l48 > 0) {
        printf("removing   direct left recursion from %s \n",
            l732->l11);
    }
    l733 = l701(
        l698(l732->l11));
    l733->l26 = 1;
    l733->l27 = 1;
    for (l367 = l146; *++l367;) {
        if (**l367 == l732) {
            l170 = *l367;
            l177 = *l367;
            while (*++l177) {
                l9 = (*l177)->l9;
                if (l9 != 3) {
                    break;
                }
            }
            if (*l177 == l732) {
                *l170 = l733;
                for (; *l177; ++l177) {
                    *l177 = *(l177 + 1);
                    if (!*l177) {
                        break;
                    }
                }
                *l177 = l733;
                l177 = *l367;
                while (*++l177) {
                    if ((*l177)->l9 != 3) {
                        break;
                    }
                }
                if (*l177 == l733) {
                    if (l48 > 0) {
                        l186();
                    }
                    printf("  %s: infinite left recursion",
                        l732->l11);
                    l59(1907, "");
                }
                if (l48 > 2) {
                    l186();
                }
            }
            else {
                l734 = 1;
                l428 = l696;
                l177 = *l367;
                *l428 = *l170;
                l584 = 2;
                while (*++l428 = *++l177) {
                    if (++l584 > (1024 * 4)) {
                        *l428 = NULL;
                        if (l48 > 0) {
                            l186();
                        }
                        l188(NULL, l696);
                        l59(1908, "production too long");
                    }
                }
                *l428 = l733;
                *++l428 = NULL;
                *l367 = l160(l696);
                if (l48 > 2) {
                    l186();
                }
            }
        }
    }
    for (l367 = l146; *++l367;) {
        if (**l367 == l733) {
            if (!l734) {
                l703(l696, *l367);
                *l696 = l732;
                l161(l160(l696), l367);
            }
            while (*++l367) {
                if (**l367 != l733) {
                    break;
                }
            }
            break;
        }
    }
    l162[0] = l733;
    l162[1] = NULL;
    l161(l160(l162), l367);
    l704(l732, l733);
    if (l48 > 2) {
        l186();
    }
}
static void
l735(l46*** l141,
    l46* l736)
{
    register l46*** l710 = l146,
        ** l428,
        ** l177;
    l3 l584;
    if (l48 > 1) {
        printf("  expand %s in: \n",
            l736->l11);
        l188("   ", *l141);
    }
    while (*++l710) {
        if (**l710 == l736) {
            l177 = *l710;
            l428 = l696;
            *l428 = **l141;
            l584 = 2;
            while (*++l428 = *++l177) {
                if (++l584 > 256) {
                    *l428 = NULL;
                    l188(NULL, l696);
                    l59(1909, "production too long\n"
                        "  probably need to remove recursion from "
                        "the rhs nonterminal first");
                }
            }
            --l428;
            l177 = *l141;
            while (*++l177 != l736) {
                *++l428 = *l177;
                if (++l584 > 256) {
                    *l428 = NULL;
                    l188(NULL, l696);
                    l59(1910, "production too long\n"
                        "  probably need to remove recursion from "
                        "the rhs nonterminal first");
                }
            }
            while (*++l428 = *++l177) {
                if (++l584 > 256) {
                    *l428 = NULL;
                    l188(NULL, l696);
                    l59(1911, "production too long\n"
                        "  probably need to remove recursion from "
                        "the rhs nonterminal first");
                }
            }
            *++l428 = NULL;
            if (l48 > 1) {
                l188("  new production:\n   ", l696);
            }
            l428 = l160(l696);
            l161(l428, l141 + 1);
            if (l710 > l141) {
                ++l710;
            }
        }
    }
}
static l3
l737(l46* l179)
{
    register l46** l177,
        *** l710 = l146;
    l3 l9,
        l738 = 0;
    if (l48 > 0) {
        printf("removing indirect left recursion from %s \n",
            l179->l11);
    }
    while (*++l710) {
        if (**l710 == l179) {
            l177 = *l710;
            while (*++l177) {
                l9 = (*l177)->l9;
                if (l9 == 3) {
                    continue;
                }
                if (l9 == 1) {
                    if (l179 != *l177) {
                        if (l98(l179, *l177, 0)) {
                            l735(l710, *l177);
                            l163(l710);
                            --l710;
                            l738 = 1;
                            if (l48 > 2) {
                                l186();
                            }
                        }
                    }
                }
                break;
            }
        }
    }
    if (l730(l179)) {
        l731(l179);
        l738 = 1;
    }
    return l738;
}
static void
l739(void)
{
    register l46** l179;
    l3 l738 = 0,
        l711;
    for (l711 = 0; l711 < 30; ++l711) {
        l738 = 0;
        for (l179 = l143; *++l179;) {
            if (l730(*l179)) {
                l731(*l179);
                l738 = 1;
            }
            if (l98(*l179, *l179, 0)) {
                l738 |= l737(*l179);
            }
        }
        if (!l738) {
            break;
        }
    }
    if (l738) {
        printf("remove left recursion is incomplete \n");
    }
}
static l3
l740(l46* l741)
{
    register l46** l179 = l143 + 1,
        *** l367;
    l3 l738 = 0,
        l435 = 0;
    for (l179 = l143; *++l179;) {
        if (*l179 == l741) {
            l435 = 1;
            break;
        }
    }
    if (!l435) {
        printf("  %s: not found \n", l741->l11);
        return l738;
    }
    for (; *l179; ++l179) {
        *l179 = *(l179 + 1);
    }
    l738 = 1;
    --l147;
    for (l367 = l146; *++l367;) {
        if (**l367 == l741) {
            l163(l367);
            --l367;
        }
    }
    return l738;
}
static l3
l742(void)
{
    register l46** l179 = l143 + 1;
    l3 l738 = 0;
    for (l179 = l143; *++l179;) {
        if ((*l179)->l29) {
            l738 |= l740(*l179);
            --l179;
        }
    }
    return l738;
}
static l3
l743(l46* l741,
    l3 l105,
    l3 l106)
{
    register l46** l179,
        ** l177,
        *** l367;
    l46* l744 = NULL;
    l3 l738 = 0,
        l745 = 1,
        l435 = 0;
    for (l179 = l143; *++l179;) {
        if (*l179 == l741) {
            l435 = 1;
            break;
        }
    }
    if (!l435) {
        printf("  %s: not found \n", l741->l11);
        return l738;
    }
    for (l367 = l146; *++l367;) {
        if (**l367 == l741) {
            l177 = *l367;
            if (*++l177) {
                if (l106 && (*l177)->l9 == 2) {
                    l744 = *l177;
                }
                else if (l105 && (*l177)->l9 == 1) {
                    l744 = *l177;
                }
                l745 = 0;
            }
            break;
        }
    }
    if (!l744) {
        if (l745) {
            printf("  %s: no replacement found \n", l741->l11);
        }
        return l738;
    }
    l163(l367);
    for (l367 = l146; *++l367;) {
        l177 = *l367;
        while (*++l177) {
            if (*l177 == l741) {
                *l177 = l744;
            }
        }
    }
    for (; *l179; ++l179) {
        *l179 = *(l179 + 1);
    }
    l738 = 1;
    --l147;
    return l738;
}
static l3
l746(l3 l105,
    l3 l106)
{
    register l46** l179;
    l3 l738 = 0,
        l747;
    for (l179 = l143; *++l179;) {
        if ((*l179)->l43) {
            l747 = l743(*l179,
                l105,
                l106);
            if (l747) {
                --l179;
                l738 = 1;
            }
        }
    }
    l110();
    return l738;
}
l3 l98(l46* l99,
    l46* l100,
    l3 l79)
{
    register l46** l126,
        *** l367;
    l46* l170;
    l3 l380 = 0;
    for (l367 = l146; *++l367;) {
        l126 = *l367;
        l170 = *l126;
        if (l170 == l100) {
            while (*++l126) {
                if ((*l126)->l9 == 1) {
                    if (*l126 == l99) {
                        l380 = 1;
                        break;
                    }
                    if (l697(*l126)) {
                        if (l452.l375 > l452.l376)
                            *--l452.l375 = *l126;
                        else
                            l59(1901, "stack overflow");
                        l380 = l98(l99,
                            *l126, l79);
                        if (*l452.l375)
                            l452.l375++;
                        ;
                    }
                    if (l380) {
                        break;
                    }
                    if (!(*l126)->l26) {
                        break;
                    }
                }
                else if ((*l126)->l9 == 2) {
                    if (*l126 == l99) {
                        l380 = 1;
                    }
                    break;
                }
                else if ((*l126)->l9 == 3) {
                    continue;
                }
            }
        }
        if (l380) {
            if (l79) {
                l188("   ", *l367);
            }
            break;
        }
    }
    return l380;
}
void l101(char* l509)
{
    register l46** l99,
        ** l100;
    l3 l342,
        l748;
    l46* l126;
    if (l509) {
        l126 = l66(l509);
        if (l126) {
            if (l126->l9 == 1 || l126->l9 == 2) {
                printf("%s is derived by: \n", l126->l11);
                l748 = 0;
                l100 = l143;
                while (*++l100) {
                    if (*l100 == l126) {
                        continue;
                    }
                    if (l98(l126, *l100, 0)) {
                        l342 = strlen((*l100)->l11) + 2;
                        if (l748 + l342 > 79) {
                            l748 = 0;
                            putchar('\n');
                        }
                        printf("  %s", (*l100)->l11);
                        l748 += l342;
                    }
                }
                putchar('\n');
                if (l748) {
                    putchar('\n');
                }
            }
            else {
                printf("%s: invalid type = %s \n", l126->l11,
                    l80(l126->l9));
            }
        }
        else {
            printf("%s: not a symbol name \n", l509);
        }
    }
    else {
        printf("\n      Nonterminals Deriving Other Nonterminals \n\n");
        for (l99 = l143; *++l99;) {
            printf("%s is derived by: \n", (*l99)->l11);
            l748 = 0;
            l100 = l143;
            while (*++l100) {
                if (*l100 == *l99) {
                    continue;
                }
                if (l98(*l99, *l100, 0)) {
                    l342 = strlen((*l100)->l11) + 2;
                    if (l748 + l342 > 79) {
                        l748 = 0;
                        putchar('\n');
                    }
                    printf("  %s", (*l100)->l11);
                    l748 += l342;
                }
            }
            putchar('\n');
            if (l748) {
                putchar('\n');
            }
        }
    }
}
void l103(char* l102)
{
    l46* l179;
    l3 l711,
        l738;
    l294();
    if (l102) {
        l179 = l702(l102);
        if (l179) {
            if (l179->l29) {
                printf("removing unused nonterminal %s \n",
                    l179->l11);
                l740(l179);
            }
            else {
                printf("not unused: %s \n", l179->l11);
            }
        }
    }
    else {
        printf("removing unused nonterminals \n");
        for (l711 = 0; l711 < 9; ++l711) {
            l738 = l742();
            if (!l738) {
                break;
            }
            l294();
        }
    }
}
void l104(char* l102,
    l3 l105,
    l3 l106)
{
    l46* l179;
    if (l102) {
        l179 = l702(l102);
        if (l179) {
            if (l179->l43) {
                printf("removing equivalent nonterminal %s \n",
                    l179->l11);
                l743(l179,
                    l105,
                    l106);
            }
            else {
                printf("not equivalent: %s \n", l179->l11);
            }
        }
        else {
            printf("not a nonterminal: %s \n", l102);
        }
    }
    else {
        printf("removing equivalent nonterminals \n");
        l746(l105,
            l106);
    }
}
void l107(char* l102)
{
    l46* l179;
    if (l102) {
        l179 = l702(l102);
        if (l179) {
            printf("removing left recursion from %s \n", l179->l11);
            l737(l179);
        }
    }
    else {
        printf("removing left recursion \n");
        l739();
    }
}
l3 l108(void)
{
    register l46*** l367,
        *** l385;
    l46*** l384;
    l3 l406 = 0;
    l46* l636,
        * l637,
        ** l386,
        ** l387;
    for (l367 = l146; *++l367;) {
        l384 = l367;
        l385 = l367;
        l386 = *l384;
        ++l386;
        if (!*l386) {
            continue;
        }
        while (*++l385) {
            l387 = *l385;
            ++l387;
            if (l166(l386, l387)) {
                l636 = **l384;
                l637 = **l385;
                if (l98(l636, l637, 0)) {
                    l406 = 1;
                    printf("duplicate rhs where %s derives %s:\n",
                        l637->l11, l636->l11);
                    l188("   ", *l385);
                    l188("   ", *l384);
                    if (l48 > 0) {
                        printf("\n  reverse derivation trace:\n");
                        l98(l636, l637, 1);
                    }
                    putchar('\n');
                }
                if (l98(l637, l636, 0)) {
                    l406 = 1;
                    printf("duplicate rhs where %s derives %s:\n",
                        l636->l11, l637->l11);
                    l188("   ", *l384);
                    l188("   ", *l385);
                    if (l48 > 0) {
                        printf("\n  reverse derivation trace:\n");
                        l98(l637, l636, 1);
                    }
                    putchar('\n');
                }
            }
        }
    }
    if (l406) {
        putchar('\n');
    }
    return l406;
}
l3 l109(void)
{
    register l46*** l367,
        *** l384,
        *** l385;
    l3 l406 = 0;
    for (l367 = l146; *++l367;) {
        l384 = l367;
        l385 = l367;
        while (*++l385) {
            if (**l385 != **l384) {
                break;
            }
            if (l166(*l385, *l384)) {
                l188("duplicate production:\n ", *l385);
                if (l48 > 2) {
                    l188("  first_production  = ",
                        *l384);
                    l188("   next_production  = ",
                        *l385);
                }
                l406 = 1;
            }
        }
    }
    if (l406) {
        putchar('\n');
    }
    return l406;
}
void l110(void)
{
    register l46*** l367,
        *** l384,
        *** l385;
    if (l48 > 3) {
        l186();
    }
    for (l367 = l146; *++l367;) {
        l384 = l367;
        l385 = l367;
        while (*++l385) {
            if (l166(*l385, *l384)) {
                if (l48 > 0) {
                    l188("removing duplicate production:\n  ",
                        *l385);
                }
                if (l48 > 2) {
                    l188("  first_production  = ",
                        *l384);
                    l188("   next_production  = ",
                        *l385);
                }
                l163(l385);
                --l385;
            }
        }
    }
    if (l48 > 3) {
        l186();
    }
}
l3 l111(char* l102)
{
    l46* l179;
    l3 l711,
        l323 = 0,
        l715;
    if (l102) {
        l179 = l702(l102);
        if (l179) {
            if (!l48) {
                printf("left factoring %s \n", l179->l11);
            }
            for (l711 = 0; l711 < 29; ++l711) {
                l715 = l720(l179, 1);
                if (!l715) {
                    break;
                }
            }
            if (l711 >= 29) {
                l323 = 1;
            }
            else {
                for (l711 = 0; l711 < 29; ++l711) {
                    l715 = l708(l179);
                    if (!l715) {
                        break;
                    }
                }
                if (l711 >= 29) {
                    l323 = 1;
                }
            }
        }
        else {
            printf("%s: not found \n", l102);
        }
    }
    else {
        printf("left factoring grammar \n");
        l323 = l728();
    }
    if (l323) {
        printf("left factoring was not completed\n");
    }
    return l323;
}
l3 l112(char* l102)
{
    l46* l179;
    l3 l711,
        l323 = 0,
        l715;
    if (l102) {
        l179 = l702(l102);
        if (l179) {
            if (!l48) {
                printf("direct left factoring %s \n", l179->l11);
            }
            for (l711 = 0; l711 < 29; ++l711) {
                l715 = l708(l179);
                if (!l715) {
                    break;
                }
            }
            if (l711 >= 29) {
                l323 = 1;
            }
        }
        else {
            printf("%s: not found \n", l102);
        }
    }
    else {
        printf("direct left factoring grammar \n");
        l323 = l726();
    }
    if (l323) {
        printf("direct left factoring was not completed\n");
    }
    return l323;
}
l3 l113(char* l102)
{
    l46* l179;
    l3 l711,
        l323 = 0,
        l715;
    if (l102) {
        l179 = l702(l102);
        if (l179) {
            if (!l48) {
                printf("left factoring %s \n", l179->l11);
            }
            for (l711 = 0; l711 < 29; ++l711) {
                l715 = l720(l179, 0);
                if (!l715) {
                    break;
                }
            }
            if (l711 >= 29) {
                l323 = 1;
            }
            else {
                for (l711 = 0; l711 < 29; ++l711) {
                    l715 = l708(l179);
                    if (!l715) {
                        break;
                    }
                }
                if (l711 >= 29) {
                    l323 = 1;
                }
            }
        }
        else {
            printf("%s: not found \n", l102);
        }
    }
    else {
        printf("nonterminal was not specified\n");
    }
    if (l323) {
        printf("left factoring was not completed\n");
    }
    return l323;
}
typedef struct l7** l749;
typedef struct l750
{
    l749* l201;
    int l646;
    int l751;
    int l752;
    int l753;
    l749(*l754)(struct l750*);
    void (*l755)(struct l750*, l749 l756);
    void (*l757)(struct l750*);
    void (*l758)(struct l750*);
    void (*l759)(struct l750*);
} l760;
void l761(l760* l201);
static l46* l762[(1024 * 4) + 4];
static l760 l763;
static char*
l764(l46** l765,
    l46** l327,
    char* l125,
    int l766)
{
    int l342,
        l767 = 0;
    l46* l126;
    l3 l138;
    static char l699[(2 * 1024)];
    register char* l11 = l699;
    for (++l765; l765 < l327; ++l765) {
        if ((*l765)->l9 == 3) {
            continue;
        }
        l342 = sprintf(l11, "%s_", (*l765)->l11);
        if (l342 > 0) {
            l11 += l342;
            l767 += l342;
        }
        else {
            l59(2201, "sprintf failed");
        }
        if (l767 >= sizeof(l699) - 12) {
            printf("EBNF name too long:\n  %s\n", l699);
            l59(2202, "");
        }
    }
    for (l11 = l699; *l11; ++l11) {
        if (*l11 == '\\') {
            if (*(l11 + 1) == '\\') {
                strcpy(l11, l11 + 2);
            }
            else {
                strcpy(l11, l11 + 1);
            }
        }
    }
    for (l11 = l699; *l11; ++l11) {
        if (*l11 == '\\') {
            *l11 = '_';
        }
        if (*l11 == '_') {
            if (*(l11 + 1) == '_') {
                strcpy(l11, l11 + 1);
            }
        }
    }
    sprintf(l11, "%s", l125);
    if (l766) {
        for (l138 = 2; l138 < 1000; ++l138) {
            l126 = l66(l699);
            if (l126) {
                sprintf(l11, "%u_%s", l138, l125);
            }
            else {
                break;
            }
        }
    }
    return l699;
}
static l46*
l768(l46** l765,
    l46** l327,
    l46* l769)
{
    register l46** l141 = l762;
    char* l11,
        * l125 = "???";
    int l40 = 0;
    int l766 = l53;
    l46* l770,
        * l771[8];
    switch ((*l327)->l10) {
    case -2:
        l125 = "opt";
        l40 = 1;
        break;
    case -4:
    case -5:
        l125 = "*";
        break;
    default:
        l59(2203, "invalid end token");
    }
    l11 = l764(l765, l327, l125, l766);
    l770 = l66(l11);
    if (l770) {
        if (l766) {
            printf("EBNF name already exists:\n  %s\n", l11);
            l59(2204, "");
        }
    }
    else {
        l770 = l67(1, 0, l11);
        l171(l770);
        l770->l37 = 1;
        if (l40) {
            l770->l40 = 1;
        }
    }
    switch ((*l327)->l10) {
    case -2:
        *l141++ = l770;
        while (++l765 < l327) {
            *l141++ = *l765;
        }
        *l141 = NULL;
        l763.l755(&l763, l160(l762));
        l141 = l771;
        *l141++ = l770;
        if (l769) {
            *l141++ = l769;
        }
        *l141 = NULL;
        l763.l755(&l763, l160(l771));
        break;
    case -4:
    case -5:
        *l141++ = l770;
        while (++l765 < l327) {
            *l141++ = *l765;
        }
        *l141++ = l770;
        *l141 = NULL;
        l763.l755(&l763, l160(l762));
        l141 = l771;
        *l141++ = l770;
        if (l769) {
            *l141++ = l769;
        }
        *l141 = NULL;
        l763.l755(&l763, l160(l771));
        break;
    }
    return l770;
}
static int l772 = 0;
static l46**
l773(register l46** l177)
{
    register l46** l765 = NULL,
        ** l327 = NULL;
    l46* l774,
        * l769;
    l3 l775;
    for (; *l177; ++l177) {
        if ((*l177)->l36) {
            switch ((*l177)->l10) {
            case -1:
            case -3:
                l765 = l177;
                l327 = l773(l177 + 1);
                if (!(l327 && *l327)) {
                    puts("missing end ebnf marker");
                    l772 = 1;
                    break;
                }
                l775 = (*l327)->l10;
                if ((*l177)->l10 == -1) {
                    if (l775 != -2) {
                        puts("missing ]");
                        l772 = 1;
                        break;
                    }
                }
                else {
                    if (l775 != -4 && l775 != -5) {
                        puts("missing }");
                        l772 = 1;
                        break;
                    }
                }
                l769 = *(l327 + 1);
                if (l769 && l769->l9 != 3) {
                    l769 = NULL;
                }
                l774 = l768(l765, l327, l769);
                if (l775 != -5) {
                    *l765 = l774;
                    if (l769) {
                        ++l327;
                    }
                    while (*++l765 = *++l327) {
                    }
                }
                else {
                    *l327 = l774;
                    while (*l765 = *(l765 + 1)) {
                        ++l765;
                    }
                    l177 = --l327;
                    if (l769) {
                        l765 = l327 + 1;
                        while (*l765 = *(l765 + 1)) {
                            ++l765;
                        }
                    }
                }
                break;
            case -2:
            case -4:
            case -5:
                return l177;
            default:
                printf("ebnf token = %d  %s\n", (*l177)->l10, (*l177)->l11);
                l59(2205, "invalid ebnf symbol");
            }
        }
    }
    return l327;
}
void l114(void)
{
    register l46*** l367 = l146;
    l46** l177,
        ** l141;
    l761(&l763);
    while (*++l367) {
        l177 = *l367;
        l772 = 0;
        l773(++l177);
        if (l772) {
            l188(" ", *l367);
            l63();
        }
    }
    while (l141 = l763.l754(&l763)) {
        l165(l141);
    }
    l763.l759(&l763);
}
static void
l776(register l46** l627,
    register l46** l628)
{
    while ((*l627++ = *l628++)) {
    }
}
static l46***
l777(register l46* l170)
{
    register l46*** l367 = l146;
    while (*++l367) {
        if (l170 == **l367) {
            break;
        }
    }
    return l367;
}
static l46**
l778(register l46** l177)
{
    register l46** l327 = l762;
    l46* l170,
        ** l387,
        *** l367,
        * l779,
        * l780;
    *l327 = *l177;
    ++l327;
    ++l177;
    for (; *l177; ++l177) {
        if ((*l177)->l37) {
            l367 = l777(*l177);
            l387 = *l367;
            l170 = *l387;
            if (l170->l40) {
                l779 = l66("\\[");
                l780 = l66("\\]");
            }
            else {
                l779 = l66("\\{");
                l780 = l66("\\}");
                if (!l780) {
                    l780 = l67(2, -4, "\\}");
                    l780->l36 = 1;
                }
            }
            *l327 = l779;
            ++l327;
            for (++l387; *l387; ++l387, ++l327) {
                *l327 = *l387;
            }
            --l387;
            if (l170 == *l387) {
                --l327;
            }
            *l327 = l780;
            ++l327;
            l387 = *++l367;
            if (*++l387) {
                *l327 = *l387;
                ++l327;
            }
        }
        else {
            *l327 = *l177;
            ++l327;
        }
    }
    *l327 = NULL;
    return l762;
}
static l46**
l781(register l46** l177)
{
    register l46** l327 = l762;
    l46** l141 = NULL,
        ** l644,
        ** l782,
        ** l783,
        * l779,
        * l784,
        * l780;
    l780 = l66("\\}");
    if (!l780) {
        return l141;
    }
    l779 = l66("\\{");
    l784 = l66("\\}+");
    if (!l784) {
        l784 = l67(2, -5, "\\}+");
        l784->l36 = 1;
    }
    *l327 = *l177;
    ++l327;
    ++l177;
    for (; *l177; ++l177) {
        if (*l177 == l780) {
            l644 = l177;
            l782 = l327;
            l783 = l177;
            while (*--l327 != l779) {
            }
            for (--l177, --l327; *l177 != l779; --l177, --l327) {
                if (l327 < l762) {
                    break;
                }
                if (*l177 != *l327) {
                    break;
                }
            }
            if (*l177 == l779) {
                *l783 = l784;
                l776(l327 + 1, l177);
                l141 = l762;
                break;
            }
            else {
                l177 = l644;
                l327 = l782;
                *l327 = *l177;
                ++l327;
            }
        }
        else {
            *l327 = *l177;
            ++l327;
        }
    }
    return l141;
}
void l115(void)
{
    register l46*** l367;
    register l46** l177;
    l46** l141;
    int l785 = 1;
    for (l785 = 1; l785;) {
        l785 = 0;
        for (l367 = l146; *++l367;) {
            l177 = *l367;
            if ((*l177)->l37) {
                continue;
            }
            while (*++l177) {
                if ((*l177)->l37) {
                    l141 = l778(*l367);
                    *l367 = l160(l141);
                    l785 = 1;
                    break;
                }
            }
        }
    }
    for (l785 = 1; l785;) {
        l785 = 0;
        for (l367 = l146; *++l367;) {
            l177 = *l367;
            if ((*l177)->l37) {
                continue;
            }
            while (*++l177) {
                if ((*l177)->l36) {
                    l141 = l781(*l367);
                    if (l141) {
                        *l367 = l160(l141);
                        l785 = 1;
                    }
                    break;
                }
            }
        }
    }
}
struct
{
    char** l375,
        * l376[511 + 1];
} l786 = { l786.l376 + 511 };
static char*
l787(char* l124,
    register char* l376,
    char* l327,
    register char* l788)
{
    for (; *l124; ++l124) {
        *l788++ = *l124;
    }
    if (l376) {
        for (; l376 <= l327; ++l376) {
            *l788++ = *l376;
        }
    }
    return l788;
}
static int
l789(register char* l327,
    register char* l65)
{
    while ((*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f')) {
        ++l327;
    }
    while (*l65 && *l327 == *l65) {
        ++l327;
        ++l65;
    }
    return (!*l65);
}
int l116(char* l117,
    char* l118)
{
    register char* l327;
    char* l376;
    char* l790 = NULL;
    char* l791;
    char* l792;
    char* l793;
    char* l124 = " ";
    char l794 = '\0';
    int l322 = 1;
    int l795 = 0;
    FILE* l320;
    char* l341;
    char* l796;
    char* l788;
    l3 l797;
    l3 l798 = 0;
    size_t l122;
    l341 = l120(l117, &l122);
    l327 = l341;
    if (!l341) {
        perror(l117);
        exit(1);
    }
    l320 = fopen(l118, "wb");
    if (!l320) {
        perror(l118);
        exit(1);
    }
    l796 = (char*)malloc(l122 * 4);
    l788 = l796;
    if (!l788) {
        printf("malloc failed for size %lu\n", (l4)(l122 * 4));
        exit(1);
    }
    for (;;) {
        l376 = l327;
        switch (*l327++) {
        case 0:
            *l788++ = '\n';
            goto l799;
        case 9:
        case 13:
            goto l800;
        case 10:
            ++l322;
            l376 = l327 + 1;
            goto l800;
        case 32:
        l800:
            *(l327 - 1) = ' ';
            while ((*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f')) {
                if (*l327 == '\n') {
                    ++l322;
                    l376 = l327 + 1;
                }
                *l327 = ' ';
                ++l327;
            }
            break;
        case '/':
            if (*l327 == '/') {
                while (*l327 && *l327 != '\n') {
                    ++l327;
                }
                goto l800;
            }
            goto l801;
        case '$':
            goto l802;
        case '[':
        case '{':
            ++l795;
            goto l801;
        case ']':
        case '}':
            if (l795 > 0) {
                --l795;
                if (!l795) {
                    l124 = " ";
                }
            }
            else {
                printf("%d: extra '%c' bracket\n", l322,
                    *(l327 - 1));
            }
            goto l801;
        case '|':
            if (l795 > 0) {
                if (l124 != "~") {
                    for (; l793 < l788; ++l793) {
                        if (*l793 == ' ') {
                            *l793 = '~';
                        }
                    }
                }
                *l788++ = '|';
                l124 = "~";
            }
            else {
                l788 = l787("\n   ", NULL, NULL, l788);
                l794 = '|';
            }
            break;
        case '<':
            if (!(((*l327 >= 'a' && *l327 <= 'z')) || ((*l327 >= 'A' && *l327 <= 'Z')) || ((*l327 >= '0' && *l327 <= '9')))) {
                goto l801;
            }
            l790 = l376;
            while (*l327) {
                if (*l327 == ' ') {
                    *l327 = '_';
                }
                else if (*l327 == '\r' || *l327 == '\n') {
                    *l327 = '>';
                    break;
                }
                else if (*l327 == '>') {
                    break;
                }
                ++l327;
            }
            l791 = l327;
            ++l327;
            l797 = 0;
            if (*l327 == '.' && *(l327 + 1) == '.' && *(l327 + 2) == '.') {
                l327 += 3;
                l797 = 1;
            }
            if (l789(l327, "::=") || l789(l327, ":=")) {
                if (l794 == '|') {
                    l788 = l787("_epsilon_", NULL, NULL, l788);
                }
                l788 = l787("\n\n", l790, l791, l788);
                if (l797) {
                    printf("%d: repeating nonterminal on lhs\n",
                        l322);
                }
            }
            else if (l797) {
                l788 = l787(l124, "{", "{", l788);
                l788 = l787(l124, l790, l791, l788);
                l788 = l787(l124, NULL, NULL, l788);
                l788 = l787("}+", NULL, NULL, l788);
            }
            else {
                l788 = l787(l124, l790, l791, l788);
            }
            l794 = '\0';
            break;
        default:
        l801:
            if ((((*l376 >= 'a' && *l376 <= 'z')) || ((*l376 >= 'A' && *l376 <= 'Z')) || ((*l376 >= '0' && *l376 <= '9')))) {
                goto l802;
            }
            l794 = '\0';
            switch (*l376) {
            case ':':
                if (*l327 == ':') {
                    if (*(l327 + 1) == '=') {
                        ++l327;
                        l788 = l787(l124, l376, l327, l788);
                        ++l327;
                        break;
                    }
                }
                else if (*l327 == '=') {
                    l788 = l787(l124, l376, l327, l788);
                    ++l327;
                    break;
                }
                goto l803;
            case ',':
            case ';':
            case '(':
            case ')':
            case ']':
                l788 = l787(l124, l376, l376, l788);
                break;
            case '[':
                l788 = l787(l124, l376, l376, l788);
                l793 = l788 + 1;
                break;
            case '{':
                l788 = l787(l124, l376, l376, l788);
                (l786.l375 > l786.l376 ? *--l786.l375 = l788 - 1 : 0);
                l793 = l788 + 1;
                break;
            case '}':
                l797 = 0;
                if (*l327 == '.' && *(l327 + 1) == '.' &&
                    *(l327 + 2) == '.') {
                    l327 += 3;
                    l797 = 1;
                }
                if (l797) {
                    l788 = l787(l124, NULL, NULL, l788);
                    l788 = l787("}+", NULL, NULL, l788);
                }
                else {
                    l792 = (*l786.l375 ? *l786.l375++ : 0);
                    if (l792) {
                        *l792 = ' ';
                    }
                    else {
                        printf("%d: extra end '}...'\n", l322);
                    }
                }
                break;
            default:
            l803:
                while (!((*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f') || (((*l327 >= 'a' && *l327 <= 'z')) || ((*l327 >= 'A' && *l327 <= 'Z')) || ((*l327 >= '0' && *l327 <= '9'))))) {
                    if (*l327 == '|' ||
                        *l327 == ',' ||
                        *l327 == ';' ||
                        *l327 == '(' ||
                        *l327 == ')' ||
                        *l327 == '[' ||
                        *l327 == ']' ||
                        *l327 == '{' ||
                        *l327 == '}') {
                        break;
                    }
                    ++l327;
                }
                if ((*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f')) {
                    *l327 = ' ';
                }
                if ((*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f') || (((*l327 >= 'a' && *l327 <= 'z')) || ((*l327 >= 'A' && *l327 <= 'Z')) || ((*l327 >= '0' && *l327 <= '9'))) ||
                    *l327 == '|' ||
                    *l327 == ',' ||
                    *l327 == ';' ||
                    *l327 == '(' ||
                    *l327 == ')' ||
                    *l327 == '[' ||
                    *l327 == ']' ||
                    *l327 == '{' ||
                    *l327 == '}') {
                    l788 = l787(l124, l376, l327 - 1, l788);
                }
                else {
                    l788 = l787(l124, l376, l327, l788);
                }
            }
            break;
        l802:
            l790 = l376;
            while (*l327) {
                if (!((((*l327 >= 'a' && *l327 <= 'z')) || ((*l327 >= 'A' && *l327 <= 'Z')) || ((*l327 >= '0' && *l327 <= '9'))) || *l327 == '_')) {
                    break;
                }
                ++l327;
            }
            l791 = l327 - 1;
            l788 = l787(l124, l790, l791, l788);
            l794 = '\0';
            break;
        }
    }
l799:
    if (l795 != 0) {
        printf("unbalanced brackets\n");
    }
    fwrite(l796, 1, l788 - l796, l320);
    fclose(l320);
    return l798;
}
int l119(char* l117,
    char* l118)
{
    register char* l327;
    char* l376;
    char* l790 = NULL;
    char* l791;
    char* l793;
    char* l124 = " ";
    char l794 = '\0';
    int l322 = 1;
    int l795 = 0;
    FILE* l320;
    char* l341;
    char* l796;
    char* l788;
    l3 l798 = 0;
    size_t l122;
    l341 = l120(l117, &l122);
    l327 = l341;
    if (!l341) {
        perror(l117);
        exit(1);
    }
    l320 = fopen(l118, "wb");
    if (!l320) {
        perror(l118);
        exit(1);
    }
    l796 = (char*)malloc(l122 * 4);
    l788 = l796;
    if (!l788) {
        printf("malloc failed for size %lu\n", (l4)(l122 * 4));
        exit(1);
    }
    for (;;) {
        l376 = l327;
        switch (*l327++) {
        case 0:
            *l788++ = '\n';
            goto l799;
        case 9:
        case 13:
            goto l800;
        case 10:
            ++l322;
            l376 = l327 + 1;
            goto l800;
        case 32:
        l800:
            *(l327 - 1) = ' ';
            while ((*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f')) {
                if (*l327 == '\n') {
                    ++l322;
                    l376 = l327 + 1;
                }
                *l327 = ' ';
                ++l327;
            }
            break;
        case '/':
            if (*l327 == '/') {
                while (*l327 && *l327 != '\n') {
                    ++l327;
                }
                goto l800;
            }
            goto l801;
        case '$':
            goto l802;
        case '[':
        case '{':
            ++l795;
            goto l801;
        case ']':
        case '}':
            if (l795 > 0) {
                --l795;
                if (!l795) {
                    l124 = " ";
                }
            }
            else {
                printf("%d: extra '%c' bracket\n", l322,
                    *(l327 - 1));
            }
            goto l801;
        case '|':
            if (l795 > 0) {
                if (l124 != "~") {
                    for (; l793 < l788; ++l793) {
                        if (*l793 == ' ') {
                            *l793 = '~';
                        }
                    }
                }
                *l788++ = '|';
                l124 = "~";
            }
            else {
                l788 = l787("\n   ", NULL, NULL, l788);
                l794 = '|';
            }
            break;
        default:
        l801:
            if ((((*l376 >= 'a' && *l376 <= 'z')) || ((*l376 >= 'A' && *l376 <= 'Z')) || ((*l376 >= '0' && *l376 <= '9')))) {
                goto l802;
            }
            l794 = '\0';
            switch (*l376) {
            case ':':
                if (*l327 == ':') {
                    if (*(l327 + 1) == '=') {
                        ++l327;
                        l788 = l787(l124, l376, l327, l788);
                        ++l327;
                        break;
                    }
                }
                else if (*l327 == '=') {
                    l788 = l787(l124, l376, l327, l788);
                    ++l327;
                    break;
                }
                goto l803;
            case ',':
            case ';':
            case '(':
            case ')':
            case ']':
            case '}':
                l788 = l787(l124, l376, l376, l788);
                break;
            case '[':
            case '{':
                l788 = l787(l124, l376, l376, l788);
                l793 = l788 + 1;
                break;
            default:
            l803:
                while (!((*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f') || (((*l327 >= 'a' && *l327 <= 'z')) || ((*l327 >= 'A' && *l327 <= 'Z')) || ((*l327 >= '0' && *l327 <= '9'))))) {
                    if (*l327 == '|' ||
                        *l327 == ',' ||
                        *l327 == ';' ||
                        *l327 == '(' ||
                        *l327 == ')' ||
                        *l327 == '[' ||
                        *l327 == ']' ||
                        *l327 == '{' ||
                        *l327 == '}') {
                        break;
                    }
                    ++l327;
                }
                if ((*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f')) {
                    *l327 = ' ';
                }
                if ((*l327 == ' ' || *l327 == '\n' || *l327 == '\r' || *l327 == '\t' || *l327 == '\v' || *l327 == '\f') || (((*l327 >= 'a' && *l327 <= 'z')) || ((*l327 >= 'A' && *l327 <= 'Z')) || ((*l327 >= '0' && *l327 <= '9'))) ||
                    *l327 == '|' ||
                    *l327 == ',' ||
                    *l327 == ';' ||
                    *l327 == '(' ||
                    *l327 == ')' ||
                    *l327 == '[' ||
                    *l327 == ']' ||
                    *l327 == '{' ||
                    *l327 == '}') {
                    l788 = l787(l124, l376, l327 - 1, l788);
                }
                else {
                    l788 = l787(l124, l376, l327, l788);
                }
            }
            break;
        l802:
            l790 = l376;
            while (*l327) {
                if (!((((*l327 >= 'a' && *l327 <= 'z')) || ((*l327 >= 'A' && *l327 <= 'Z')) || ((*l327 >= '0' && *l327 <= '9'))) || *l327 == '_')) {
                    break;
                }
                ++l327;
            }
            l791 = l327 - 1;
            if (l789(l327, "::=") || l789(l327, ":=")) {
                if (l794 == '|') {
                    l788 = l787("_epsilon_", NULL, NULL, l788);
                }
                l788 = l787("\n\n", l790, l791, l788);
            }
            else {
                l788 = l787(l124, l790, l791, l788);
            }
            l794 = '\0';
            break;
        }
    }
l799:
    if (l795 != 0) {
        printf("unbalanced brackets\n");
    }
    fwrite(l796, 1, l788 - l796, l320);
    fclose(l320);
    return l798;
}
char*
l120(char* l121,
    size_t* l122)
{
    size_t l804;
    FILE* l320;
    char* l805 = NULL;
    l320 = fopen(l121, "rb");
    if (l320) {
        fseek(l320, 0L, 2);
        l804 = ftell(l320);
        rewind(l320);
        l805 = (char*)malloc(l804 + 4);
        if (l805) {
            *l122 = fread(l805, 1, l804, l320);
            if (*l122 == l804) {
                l805[l804] = '\0';
                l805[l804 + 1] = '\0';
            }
            else {
                free(l805);
                l805 = NULL;
            }
        }
        else {
            printf("malloc failed for size %lu\n", (l4)(*l122 * 4));
        }
        fclose(l320);
    }
    return l805;
}
static char l806[] =
"typedef struct {\n"
"    slk_size_t  (*get)  ( void );\n"
"    slk_size_t  (*peek) ( int level );\n"
"} xxxToken;\n"
"\n"
"typedef struct {\n"
"    slk_size_t  (*mismatch) ( slk_size_t symbol, slk_size_t token );\n"
"    slk_size_t  (*no_entry) ( slk_size_t symbol, slk_size_t token, int level );\n"
"    void        (*input_left) ( void );\n"
"    void        (*message) ( char  *message );\n"
"} xxxError;\n"
"\n"
"typedef struct {\n"
"    void  (*execute) ( slk_size_t action );\n"
"    void  (*predict) ( slk_size_t entry );\n"
"    void  (*reduce)  ( slk_size_t entry );\n"
"    void  (*state)   ( slk_size_t state );\n"
"} xxxAction;\n";
static char l807[] =
"#include \"xxxToken.h\"\n"
"#include \"xxxError.h\"\n"
"#include \"xxxAction.h\"\n";
static char l808[] =
"#define SLK_PUSH(symbol,stack,top) if ( top > stack ) *--top = symbol\n"
"#define SLK_POP(top)   (*top ? *top++ : 0)\n";
static char l809[] =
"#define NOT_A_SYMBOL       0\n"
"#define NONTERMINAL_SYMBOL 1\n"
"#define TERMINAL_SYMBOL    2\n"
"#define ACTION_SYMBOL      3\n\n"
"int xxxGetSymbolType ( slk_size_t symbol )";
static char l810[] =
"{\n"
"   int   symbol_type = NOT_A_SYMBOL;\n"
"\n"
"   if ( symbol >= START_ACTION  &&  symbol < END_ACTION ) {\n"
"       symbol_type = ACTION_SYMBOL;\n"
"   } else if ( symbol >= START_SYMBOL ) {\n"
"       symbol_type = NONTERMINAL_SYMBOL;\n"
"   } else if ( symbol > 0 ) {\n"
"       symbol_type = TERMINAL_SYMBOL;\n"
"   }\n"
"   return  symbol_type;\n"
"}\n";
static char l811[] =
"slk_size_t *xxxGetProductionArray ( slk_size_t   production_number )";
static char l812[] =
"{\n"
"    return   &Production [ Production_row [production_number] ];\n"
"}\n";
static char l813[] =
"slk_size_t xxxGetProduction ( slk_size_t   conflict_number,\n"
"                              xxxToken yyytokens ) ";
static char l814[] =
"{\n"
"    slk_size_t  entry = 0;\n"
"    int         index, level;\n"
"\n"
"    if ( conflict_number <= TOTAL_CONFLICTS ) {\n"
"        entry = conflict_number + (START_CONFLICT -1);\n"
"        level = 1;\n"
"        while ( entry >= START_CONFLICT ) {\n"
"            index = Conflict_row [entry - (START_CONFLICT -1)];\n"
"            index += peek ( tokens, level );\n"
"            entry = Conflict [ index ];\n"
"            ++level;\n"
"        }\n"
"    }\n"
"\n"
"    return  entry;\n"
"}\n";
static char l815[] =
"int xxxIsNonterminal ( slk_size_t symbol )";
static char l816[] =
"{\n"
"   return ( symbol >= START_SYMBOL  &&  symbol < START_ACTION );\n"
"}\n";
static char l817[] =
"int xxxIsTerminal ( slk_size_t symbol )";
static char l818[] =
"{\n"
"   return ( symbol > 0  &&  symbol < START_SYMBOL );\n"
"}\n";
static char l819[] =
"int xxxIsAction ( slk_size_t symbol )";
static char l820[] =
"{\n"
"   return ( symbol >= START_ACTION  &&  symbol < END_ACTION );\n"
"}\n";
static char l821[] =
"static slk_size_t\n"
"get_predicted_entry ( xxxTokenyyytokens, \n"
"                      slk_size_t production_number,\n"
"                      slk_size_t token,\n"
"                      int        scan_level,\n"
"                      int        depth )\n"
"{\n"
" register\n"
" slk_size_t  *top, *production;\n"
" slk_size_t   entry, symbol, predicted_entry, lhs;\n"
" slk_size_t   save_token = token;\n"
" int          save_scan_level = scan_level;\n"
" int          production_length, index, level;\n"
" slk_size_t   stack [ PARSE_STACK_SIZE ];\n"
"\n"
" top = stack + (PARSE_STACK_SIZE-1);\n"
" *top = 0;\n"
" predicted_entry = production_number;\n"
" production = &Production [ Production_row [predicted_entry] ];\n"
" lhs = *(production + 1);\n"
"\n"
" for (;;) {\n"
"   top = stack + (PARSE_STACK_SIZE-1);\n"
"   token = save_token;\n"
"   scan_level = save_scan_level;\n"
"   production = &Production [ Production_row [predicted_entry] ];\n"
"   symbol = *(production+1);\n"
"   if ( symbol != lhs ) {\n"
"       predicted_entry = 0;\n"
"       break;\n"
"   }\n"
"   production_length = *production - 1;\n"
"   production += production_length + 1;\n"
"   for (;  production_length-- > 0;  --production ) {\n"
"       SLK_PUSH ( *production, stack, top );\n"
"   }\n"
"   for ( symbol = SLK_POP ( top );  symbol;  symbol = SLK_POP ( top ) ) {\n"
"\n"
"       if ( symbol >= START_SYMBOL  &&  symbol < START_ACTION ) {\n"
"           entry = 0;\n"
"           production_number = GET_CONDITIONAL_PRODUCTION ( symbol );\n"
"           if ( production_number ) {\n"
"               entry = get_predicted_entry ( tokens, \n"
"                                             production_number, token, \n"
"                                             scan_level, depth + 1 );\n"
"           }\n"
"           if ( ! entry ) {\n"
"               index = Parse_row [symbol - (START_SYMBOL-1)];\n"
"               index += token;\n"
"               entry = Parse [ index ];\n"
"           }\n"
"           level = scan_level;\n"
"           while ( entry >= START_CONFLICT ) {\n"
"               index = Conflict_row [entry - (START_CONFLICT -1)];\n"
"               index += peek (tokens, level);\n"
"               entry = Conflict [ index ];\n"
"               ++level;\n"
"           }\n"
"           if ( entry ) {\n"
"               production = &Production [ Production_row [entry] ];\n"
"               production_length = *production - 1;\n"
"               if ( *++production == symbol ) {\n";
static char l822[] =
"                   production += production_length;\n"
"                   for (;  production_length-- > 0;  --production ) {\n"
"                       SLK_PUSH ( *production, stack, top );\n"
"                   }\n"
"               } else {\n"
"                   ++predicted_entry;\n"
"                   break;\n"
"               }\n"
"           } else {\n"
"               ++predicted_entry;\n"
"               break;\n"
"           }\n"
"       } else if ( symbol > 0 ) {\n"
"           if ( symbol == token ) {\n"
"               token = peek ( tokens, scan_level++ );\n"
"           } else {\n"
"               ++predicted_entry;\n"
"               break;\n"
"           }\n"
"       }\n"
"   }\n"
"   if ( ! symbol ) {\n"
"       break;\n"
"   }\n"
" }\n"
"\n"
" return  predicted_entry;\n"
"}\n";
static char l823[] =
"void xxxParse ( xxxActionyyyaction, \n"
"                xxxToken yyytokens, \n"
"                xxxError yyyerror, \n"
"                slk_size_t  start_symbol ) ";
static char l824[] =
"{\n"
" register\n"
" slk_size_t  *top, *production;\n"
" slk_size_t   production_number, entry, symbol, token, new_token;\n"
" int          production_length, index, level;\n"
" slk_size_t   stack [ PARSE_STACK_SIZE ];\n"
"\n"
" top = stack + (PARSE_STACK_SIZE-1);\n"
" *top = 0;\n"
" if ( ! start_symbol ) {\n"
"     start_symbol = START_SYMBOL;\n"
" }\n"
" SLK_PUSH ( start_symbol, stack, top );\n"
" token = get(tokens);\n"
" new_token = token;\n"
"\n"
" for ( symbol = SLK_POP ( top );  symbol;  ) {\n"
"\n"
"     if ( symbol >= START_ACTION ) {\n"
"         execute ( action, (symbol-(START_ACTION-1)) );\n"
"\n"
"     } else if ( symbol >= START_SYMBOL ) {\n"
"         entry = 0;\n"
"         level = 1;\n"
"         production_number = GET_CONDITIONAL_PRODUCTION ( symbol );\n"
"         if ( production_number ) {\n"
"             entry = get_predicted_entry ( tokens,\n"
"                                           production_number, token,\n"
"                                           level, 1 );\n"
"         }\n"
"         if ( ! entry ) {\n"
"             index = Parse_row [symbol - (START_SYMBOL-1)];\n"
"             index += token;\n"
"             entry = Parse [ index ];\n"
"         }\n"
"         while ( entry >= START_CONFLICT ) {\n"
"             index = Conflict_row [entry - (START_CONFLICT -1)];\n"
"             index += peek (tokens, level);\n"
"             entry = Conflict [ index ];\n"
"             ++level;\n"
"         }\n"
"         if ( entry ) {\n"
"             production = &Production [ Production_row [entry] ];\n"
"             production_length = *production - 1;\n"
"             if ( *++production == symbol ) {\n"
"                 predict ( action, entry, symbol, token, level - 1, tokens.getLastToken(), tokens.getLastLineNumber(), tokens.getCurToken(), tokens.getLineNumber() );\n"
"                 production += production_length;\n"
"                 for (;  production_length-- > 0;  --production ) {\n"
"                     SLK_PUSH ( *production, stack, top );\n"
"                 }\n"
"             } else {\n"
"                 new_token = no_entry ( error, entry, symbol, token, level - 1, tokens );\n"
"             }\n"
"         } else {\n"
"             new_token = no_entry ( error, entry, symbol, token, level - 1, tokens );\n"
"         }\n"
"     } else if ( symbol > 0 ) {\n"
"         if ( symbol == token ) {\n"
"             token = get(tokens);\n"
"             new_token = token;\n"
"         } else {\n"
"             new_token = mismatch ( error, symbol, token, tokens );\n"
"         }\n"
"     }\n"
"     if ( token != new_token ) {\n"
"         if ( new_token ) {\n"
"             token = new_token;\n"
"         }\n"
"         if ( token != END_OF_SLK_INPUT_ ) {\n"
"             continue;\n"
"         }\n"
"     }\n"
"     symbol = SLK_POP ( top );\n"
" }\n"
" if ( token != END_OF_SLK_INPUT_ ) {\n"
"     input_left ( error, tokens );\n"
" }\n"
"}\n";
static char l825[] =
"void xxxParse ( xxxActionyyyaction, \n"
"                xxxToken yyytokens, \n"
"                xxxError yyyerror, \n"
"                slk_size_t  start_symbol ) ";
static char l826[] =
"{\n"
" register\n"
" slk_size_t  *top, *production;\n"
" slk_size_t   state, production_number, entry, symbol, token, new_token;\n"
" int          action_number, production_length, index, level;\n"
" slk_size_t   stack [ PARSE_STACK_SIZE ];\n"
"\n"
" top = stack + (PARSE_STACK_SIZE-1);\n"
" *top = 0;\n"
" if ( ! start_symbol ) {\n"
"     start_symbol = START_SYMBOL;\n"
" }\n"
" SLK_PUSH ( 1, stack, top );\n"
" token = get(tokens);\n"
" new_token = token;\n"
"\n"
" for ( state = *top;  state;  ) {\n"
"     index = Parse_row [ state ];\n"
"     index += token;\n"
"     entry = Parse [ index ];\n"
"     if ( state != Parse_state [ index ] )  entry = 0;\n"
"     level = 1;\n"
"     state ( action, state );\n"
"\n"
"     if ( entry >= START_CONFLICT ) {\n"
"         while ( entry >= START_CONFLICT && entry < END_CONFLICT ) {\n"
"             index = Conflict_row [entry - (START_CONFLICT -1)];\n"
"             index += peek (tokens, level);\n"
"             entry = Conflict [ index ];\n"
"             ++level;\n"
"         }\n"
"     }\n"
"     if ( entry >= START_STATE ) {\n"
"         state = entry - (START_STATE-1);\n"
"         SLK_PUSH ( state, stack, top );\n"
"         token = get(tokens);\n"
"         new_token = token;\n"
"\n"
"     } else if ( entry > 0 ) {\n"
"         reduce ( action, entry );\n"
"         production_number = entry;\n"
"         action_number = Action_number [production_number];\n"
"         if ( action_number ) {\n"
"             action_number -= (START_ACTION-1);\n"
"             if ( action_number < END_ACTION ) {\n"
"                 execute ( action, action_number );\n"
"             } else {\n"
"                 message ( error, \"\\n error: action out of range\\n\" );\n"
"             }\n"
"         }\n"
"         production = &Production [ Production_row [production_number] ];\n"
"         production_length = *production - 1;\n"
"         symbol = *++production;\n"
"         for (;  production_length > 0;  --production_length ) {\n"
"             SLK_POP ( top );\n"
"         }\n"
"         state = *top;\n"
"         index = Parse_row [ state ];\n"
"         index += symbol;\n"
"         entry = Parse [ index ];\n"
"         if ( state != Parse_state [ index ] )  entry = 0;\n"
"         if ( entry >= START_CONFLICT ) {\n"
"             message ( error, \"\\n reduce error: conflict not state\\n\" );\n"
"         } else if ( entry >= START_STATE ) {\n"
"             state = entry - (START_STATE-1);\n"
"             SLK_PUSH ( state, stack, top );\n"
"         } else if ( entry > 0 ) {\n"
"             message ( error, \"\\n reduce error: not a state\\n\" );\n"
"         } else if ( token != END_OF_SLK_INPUT_ ) {\n"
"             new_token = no_entry ( error, state, token, level-1 );\n"
"         }\n"
"     } else {\n"
"         new_token = no_entry ( error, state, token, level-1 );\n"
"         if ( new_token == END_OF_SLK_INPUT_ ) {\n"
"             break;\n"
"         }\n"
"     }\n"
"     if ( token != new_token ) {\n"
"         if ( new_token ) {\n"
"             token = new_token;\n"
"         }\n"
"     }\n"
"     state = *top;\n"
"     if ( state <= 1 ) {\n"
"         break;\n"
"     }\n"
" }\n"
" if ( token != END_OF_SLK_INPUT_ ) {\n"
"     input_left ( error );\n"
" }\n"
"}\n";
static void
l827(char* l83,
    l3 l85,
    l3 l89)
{
    register l46** l126;
    FILE* l566;
    l5* l509,
        * l510,
        l828[16],
        l75[16];
    if (l85 & 0x00001000) {
        sprintf(l828, "%sAction *", l83);
    }
    else {
        sprintf(l828, "void");
    }
    sprintf(l75, "%sTable.h", l83);
    l566 = fopen(l75, "w");
    if (!l566) {
        perror(l75);
        l59(1107, "");
    }
    fprintf(l566, "\n// %s - generated by the SLK parser generator \n\n",
        l75);
    fprintf(l566, "#ifndef _%sTABLE_H\n#define _%sTABLE_H\n\n",
        l83, l83);
    if (l85 & 0x00001000) {
        fprintf(l566, "#include \"%sAction.h\"\n\n", l83);
    }
    fprintf(l566, "#ifdef __cplusplus\n"
        "extern \"C\" {\n"
        "#endif\n\n");
    for (l126 = l145; *++l126;) {
        l509 = (*l126)->l11;
        l510 = l509;
        if (!l89) {
            l510 += l73(l510);
        }
        fprintf(l566, "void    %s ( %s );\n", l510, l828);
        if (((*l510 >= '0' && *l510 <= '9'))) {
            l59(1110, "Cannot mix numbered actions with named actions");
        }
    }
    fprintf(l566, "\nextern void (*%sActions []) ( %s );\n\n",
        l83, l828);
    fprintf(l566, "#ifdef __cplusplus\n"
        "}\n"
        "#endif\n");
    fprintf(l566, "\n#endif\n");
    fclose(l566);
    sprintf(l75, "%sTable.c", l83);
    l566 = fopen(l75, "w");
    if (!l566) {
        perror(l75);
        l59(1109, "");
    }
    fprintf(l566, "\n// %s - generated by the SLK parser generator \n\n",
        l75);
    fprintf(l566, "#include \"%sTable.h\"\n\n", l83);
    fprintf(l566, "void ( *%sActions [] ) ( %s ) = { 0\n",
        l83, l828);
    for (l126 = l145; *++l126;) {
        l509 = (*l126)->l11;
        l510 = l509;
        if (!l89) {
            l510 += l73(l510);
        }
        fprintf(l566, "   ,%s\n", l510);
    }
    fprintf(l566, "};\n");
    fclose(l566);
    sprintf(l75, "%sExecute.txt", l83);
    l566 = fopen(l75, "w");
    if (!l566) {
        perror(l75);
        l59(1109, "");
    }
    fprintf(l566, "\n// %s - generated by the SLK parser generator \n\n",
        l75);
    fprintf(l566, "static void ( *%sActions [] ) ( %s ) = { 0\n",
        l83, l828);
    for (l126 = l145; *++l126;) {
        l509 = (*l126)->l11;
        l510 = l509;
        if (!l89) {
            l510 += l73(l510);
        }
        fprintf(l566, "   ,%s\n", l510);
    }
    fprintf(l566, "};\n\n");
    if (l85 & 0x00001000) {
        fprintf(l566, "static void\n"
            "(execute) ( %sa, slk_size_t  n ) "
            "  { ( %sActions [ n ] ) ( a ); }\n",
            l828,
            l83);
    }
    else {
        fprintf(l566, "static void\n"
            "execute ( slk_size_t  number ) "
            "  { ( %sActions [ number ] ) (); }\n",
            l83);
    }
    fclose(l566);
}
static void
l829(char* l83,
    l3 l85,
    char* l84,
    l3 l89)
{
    register l46** l126;
    int l830,
        l831 = 0;
    FILE* l566;
    l5* l509,
        * l510,
        l75[16];
    sprintf(l75, "%sTable.h", l83);
    l566 = fopen(l75, "w");
    if (!l566) {
        perror(l75);
        l59(1112, "");
    }
    fprintf(l566, "\n// %s - generated by the SLK parser generator \n\n",
        l75);
    fprintf(l566, "#ifndef _%sTABLE_H\n#define _%sTABLE_H\n\n",
        l83, l83);
    if (l84) {
        fprintf(l566, "namespace %s {\n\n", l84);
    }
    fprintf(l566, "public:\n\n");
    for (l126 = l145; *++l126; ++l831) {
        l509 = (*l126)->l11;
        l510 = l509;
        if (!l89) {
            l510 += l73(l510);
        }
        fprintf(l566, "void    %s ( void );\n", l510);
        if (((*l510 >= '0' && *l510 <= '9'))) {
            l59(1113, "Cannot mix numbered actions with named actions");
        }
    }
    fprintf(l566, "\nvoid    ( %sAction::*Action [ %u ] ) ( void );\n\n",
        l83, l831 + 1);
    fprintf(l566, "void    initialize_table ( void );\n");
    fprintf(l566, "void\n"
        "execute ( int  number ) "
        "  { ( this->*Action [ number ] ) (); }\n");
    if (l84) {
        fprintf(l566, "\n\n}\n");
    }
    fprintf(l566, "\n#endif\n");
    fclose(l566);
    sprintf(l75, "%sTable.cpp", l83);
    l566 = fopen(l75, "w");
    if (!l566) {
        perror(l75);
        l59(1114, "");
    }
    fprintf(l566, "\n// %s - generated by the SLK parser generator \n\n",
        l75);
    fprintf(l566, "#include \"%sAction.h\"\n\n", l83);
    if (l84) {
        fprintf(l566, "namespace %s {\n\n", l84);
    }
    fprintf(l566, "void\n"
        "%sAction ::\n"
        "initialize_table ( void )\n"
        "{\n"
        "    Action [ 0 ] = 0;\n",
        l83);
    for (l126 = l145; *++l126;) {
        l509 = (*l126)->l11;
        l830 = (*l126)->l10;
        l510 = l509;
        if (!l89) {
            l510 += l73(l510);
        }
        fprintf(l566, "    Action [ %u ] = &%sAction::%s;\n",
            (l830 - (l155 - 1)),
            l83, l510);
    }
    fprintf(l566, "}\n");
    if (l84) {
        fprintf(l566, "\n\n}\n");
    }
    fclose(l566);
    sprintf(l75, "%sExecute.txt", l83);
    l566 = fopen(l75, "w");
    if (!l566) {
        perror(l75);
        l59(1112, "");
    }
    fprintf(l566, "\n// %s - generated by the SLK parser generator \n\n"
        "private:\n",
        l75);
    for (l126 = l145; *++l126; ++l831) {
        l509 = (*l126)->l11;
        l510 = l509;
        if (!l89) {
            l510 += l73(l510);
        }
        fprintf(l566, "void    %s ( void );\n", l510);
        if (((*l510 >= '0' && *l510 <= '9'))) {
            l59(1113, "Cannot mix numbered actions with named actions");
        }
    }
    fprintf(l566, "\npublic:\nvoid execute ( slk_size_t  number )\n"
        "{\n"
        "  switch ( number ) {\n");
    for (l126 = l145; *++l126; ++l831) {
        l509 = (*l126)->l11;
        l830 = (*l126)->l10;
        l510 = l509;
        if (!l89) {
            l510 += l73(l510);
        }
        fprintf(l566, "    case %d:  %s();  break;\n",
            (l830 - (l155 - 1)), l510);
        if (((*l510 >= '0' && *l510 <= '9'))) {
            l59(1119, "Cannot mix numbered actions with named actions");
        }
    }
    fprintf(l566, "  }\n}\n");
    fclose(l566);
}
static void
l832(char* l83,
    char* l84,
    l3 l85)
{
    register l46** l126;
    int l10,
        l833;
    FILE* l566,
        * l834;
    l5 l75[32],
        * l12;
    char* l124 = "",
        * l125 = "";
    char* l835 = "short";
    if (l147 + l148 + l149 > (64 * 1024 - 4)) {
        l835 = "int";
    }
    else if (l150 + l221 > (64 * 1024 - 4)) {
        l835 = "int";
    }
    if (l85 & 0x00000002) {
        l125 = l83;
    }
    sprintf(l75, "%sParse.h", l83);
    l834 = fopen(l75, "w");
    if (!l834) {
        perror(l75);
        l59(1101, "");
    }
    sprintf(l75, "%sConstants.h", l83);
    l566 = fopen(l75, "w");
    if (!l566) {
        perror(l75);
        l59(1101, "");
    }
    fprintf(l834, "\n// %sParse.h - generated by the SLK parser generator \n\n",
        l83);
    fprintf(l834, "#ifndef _%sPARSE_H\n#define _%sPARSE_H\n\n",
        l83, l83);
    fprintf(l566, "\n// %sConstants.h - generated by the SLK parser generator \n\n",
        l83);
    fprintf(l566, "#ifndef _%sCONSTANTS_H\n#define _%sCONSTANTS_H\n\n",
        l83, l83);
    if (l85 & 0x00000100) {
        fprintf(l834, "#ifdef __cplusplus\n"
            "extern \"C\" {\n"
            "#endif\n\n");
        fprintf(l566, "#ifdef __cplusplus\n"
            "extern \"C\" {\n"
            "#endif\n\n");
    }
    else if (l85 & 0x00000200) {
        if (l84) {
            fprintf(l834, "namespace %s {\n\n", l84);
            fprintf(l566, "namespace %s {\n\n", l84);
        }
    }
    fprintf(l566, "enum _%s_token_defines { \n", l83);
    l833 = 0;
    for (l126 = l144; *++l126;) {
        l10 = (*l126)->l10;
        l12 = l123(l124, l125, l126, 1);
        (*l126)->l12 = l64(l12);
        if (l833) {
            fprintf(l566, ", %s = %u \n", l12, l10);
        }
        else {
            fprintf(l566, "  %s = %u \n", l12, l10);
            l833 = 1;
        }
    }
    fprintf(l566, "}; \n\n");
    l833 = 0;
    l124 = "NT_";
    fprintf(l566, "enum _%s_Nonterminal_defines { \n", l83);
    for (l126 = l143; *++l126;) {
        l10 = (*l126)->l10;
        l12 = l123(l124, l125, l126, 0);
        if (l833) {
            fprintf(l566, ", %s = %u \n", l12, l10);
        }
        else {
            fprintf(l566, "  %s = %u \n", l12, l10);
            l833 = 1;
        }
    }
    fprintf(l566, "}; \n\n");
    fprintf(l834, "typedef unsigned %s   slk_size_t;\n\n", l835);
    fprintf(l566, "typedef unsigned %s   slk_size_t;\n\n", l835);
    fprintf(l834, "%s;\n", l809);
    fprintf(l834, "%s;\n", l811);
    fprintf(l834, "slk_size_t *%sGetState ( slk_size_t  state_number );\n",
        l83);
    fprintf(l834, "%s;\n", l815);
    fprintf(l834, "%s;\n", l817);
    fprintf(l834, "%s;\n\n", l819);
    fprintf(l566, "%s;\n", l809);
    fprintf(l566, "%s;\n", l811);
    fprintf(l566, "slk_size_t *%sGetState ( slk_size_t  state_number );\n",
        l83);
    fprintf(l566, "%s;\n", l815);
    fprintf(l566, "%s;\n", l817);
    fprintf(l566, "%s;\n\n", l819);
    if (l85 & 0x00000100) {
        fprintf(l834, "%s \n", l806);
    }
    else {
        fprintf(l834, "%s \n", l807);
    }
    fprintf(l834, "%s;\n", l813);
    if (l85 & (0x00000004 | 0x00000008)) {
        fprintf(l834, "%s;\n\n", l823);
    }
    if (l85 & 0x00000100) {
        fprintf(l834, "#ifdef __cplusplus\n"
            "}\n"
            "#endif\n");
        fprintf(l566, "#ifdef __cplusplus\n"
            "}\n"
            "#endif\n");
    }
    else if (l85 & 0x00000200) {
        if (l84) {
            fprintf(l834, "\n\n}\n");
            fprintf(l566, "\n\n}\n");
        }
    }
    fprintf(l834, "\n#endif\n");
    fprintf(l566, "\n#endif\n");
    fclose(l834);
    fclose(l566);
}
static void
l836(char* l83,
    char* l84,
    l3 l85)
{
    register l46** l126;
    int l10,
        l837,
        l833;
    l46* l609;
    FILE* l566;
    l5 l75[32],
        * l12,
        * l11;
    sprintf(l75, "%sKeywords.txt", l83);
    l566 = fopen(l75, "w");
    if (!l566) {
        perror(l75);
        l59(1191, "");
    }
    fprintf(l566, "\n// %s - generated by the SLK parser generator \n\n",
        l75);
    fprintf(l566, "// Assumes all alpha terminals are keywords, "
        "usually needs manual editing to remove non-keywords.\n\n");
    fprintf(l566, "#ifndef _%sKEYWORDS_H\n#define _%sKEYWORDS_H\n\n",
        l83, l83);
    if (l85 & 0x00000100) {
        fprintf(l566, "#ifdef __cplusplus\n"
            "extern \"C\" {\n"
            "#endif\n\n");
    }
    else if (l85 & 0x00000200) {
        if (l84) {
            fprintf(l566, "namespace %s {\n\n", l84);
        }
    }
    fprintf(l566, "#include \"%sConstants.h\" \n\n", l83);
    fprintf(l566, "typedef struct _%s_keyword { \n"
        "    slk_size_t  token;\n    char  *name;\n}"
        "  %s_keyword_t};\n\n",
        l83, l83);
    fprintf(l566, "static %s_keyword_t %s_keyword [] = { \n",
        l83, l83);
    l833 = 0;
    l609 = l66("END_OF_SLK_INPUT");
    l837 = l609->l10;
    for (l126 = l144; *++l126;) {
        l10 = (*l126)->l10;
        if (l10 == l837) {
            continue;
        }
        l11 = (*l126)->l11;
        if (l11 && (((*l11 >= 'a' && *l11 <= 'z')) || ((*l11 >= 'A' && *l11 <= 'Z'))) || (((*(l11 + 1) >= 'a' && *(l11 + 1) <= 'z')) || ((*(l11 + 1) >= 'A' && *(l11 + 1) <= 'Z')))) {
            l12 = (*l126)->l12;
            if (l833) {
                fprintf(l566, ",{ %s, \"%s\" } \n", l12, l11);
            }
            else {
                fprintf(l566, " { %s, \"%s\" } \n", l12, l11);
                l833 = 1;
            }
        }
    }
    fprintf(l566, ",{ 0, NULL } \n");
    fprintf(l566, "}; \n\n");
    if (l85 & 0x00000100) {
        fprintf(l566, "#ifdef __cplusplus\n"
            "}\n"
            "#endif\n");
    }
    else if (l85 & 0x00000200) {
        if (l84) {
            fprintf(l566, "\n\n}\n");
        }
    }
    fprintf(l566, "\n#endif\n");
    fclose(l566);
}
static void
l838(char* l83,
    char* l84,
    l3 l85)
{
    register l46** l126;
    int l833;
    FILE* l566;
    l5 l75[32],
        * l12,
        * l11;
    sprintf(l75, "%sTerminals.h", l83);
    l566 = fopen(l75, "w");
    if (!l566) {
        perror(l75);
        l59(1191, "");
    }
    fprintf(l566, "\n// %s - generated by the SLK parser generator \n\n",
        l75);
    fprintf(l566, "// Declaration of terminals values as int, "
        "can be used to seed the symbol table with terminals\n\n");
    fprintf(l566, "#ifndef _%sTERMINALS_H\n#define _%sTERMINALS_H\n\n",
        l83, l83);
    if (l85 & 0x00000100) {
        fprintf(l566, "#ifdef __cplusplus\n"
            "extern \"C\" {\n"
            "#endif\n\n");
    }
    else if (l85 & 0x00000200) {
        if (l84) {
            fprintf(l566, "namespace %s {\n\n", l84);
        }
    }
    fprintf(l566, "#include \"%sConstants.h\" \n\n", l83);
    fprintf(l566, "typedef struct _%s_terminal { \n"
        "    slk_size_t  token;\n    char  *name;\n}"
        " %s_terminal_t;\n\n",
        l83, l83);
    fprintf(l566, "static %s_terminal_t %s_terminal [] = { \n",
        l83, l83);
    l833 = 0;
    for (l126 = l144; *++l126;) {
        l11 = (*l126)->l11;
        if (l11) {
            l12 = (*l126)->l12;
            if (l833) {
                fprintf(l566, ",{ %s, \"%s\" } \n", l12, l11);
            }
            else {
                fprintf(l566, " { %s, \"%s\" } \n", l12, l11);
                l833 = 1;
            }
        }
    }
    fprintf(l566, ",{ 0, NULL } \n");
    fprintf(l566, "}; \n\n");
    if (l85 & 0x00000100) {
        fprintf(l566, "#ifdef __cplusplus\n"
            "}\n"
            "#endif\n");
    }
    else if (l85 & 0x00000200) {
        if (l84) {
            fprintf(l566, "\n\n}\n");
        }
    }
    fprintf(l566, "\n#endif\n");
    fclose(l566);
}
static void
l839(register FILE* l88)
{
    register l46** l179;
    int l261,
        l438 = 0,
        l840;
    if (l152 == 0) {
        fputs("#define GET_CONDITIONAL_PRODUCTION( symbol )  0 \n", l88);
        fputs("#define get_predicted_entry( a,b,c,d,e )  0 \n\n", l88);
    }
    else if (l152 == 1) {
        fputs("#define GET_CONDITIONAL_PRODUCTION( symbol ) \\ \n (", l88);
        for (l179 = l143; *++l179;) {
            if ((*l179)->l45) {
                l261 = l169(*l179);
                fprintf(l88, " symbol == %u ? %u :", (*l179)->l10,
                    l261);
            }
        }
        fputs(" 0 ) \n\n", l88);
    }
    else {
        l840 = l156 + l147 - 1 -
            l152;
        fputs("static slk_size_t Conditional_production[] = {0\n", l88);
        for (l179 = l143; *++l179;) {
            if ((*l179)->l45) {
                l261 = l169(*l179);
                fprintf(l88, ",%u", l261);
                if (++l438 > 20) {
                    l438 = 0;
                    fputs("\n", l88);
                }
            }
        }
        fputs("};\n\n", l88);
        fputs("#define GET_CONDITIONAL_PRODUCTION( symbol ) \\ \n (", l88);
        fprintf(l88, " symbol > %u ? Conditional_production [ symbol - %u ]"
            " : 0 ) \n\n",
            l840, l840);
    }
}
static void
l841(char* l83,
    l3 l85)
{
    char* l568, * l842;
    char* l843 = "   ";
    if (l85 & 0x00000200) {
        l843 = "  &";
    }
    else if (l85 & 0x00001000) {
        l843 = "  *";
    }
    if (!(l85 & 0x00000001)) {
        for (l568 = l826; l568;) {
            l568 = strstr(l568, "if ( state != Parse_state");
            if (l568) {
                strncpy(l568, "//   ", 5);
            }
        }
    }
    for (l568 = l806; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l807; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l808; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l809; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l811; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l815; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l817; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l819; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l821; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l823; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l824; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l825; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l826; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l813; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l814; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l842 = l821; l842;) {
        l842 = strstr(l842, "yyy");
        if (l842) {
            strncpy(l842, l843, 3);
        }
    }
    for (l842 = l823; l842;) {
        l842 = strstr(l842, "yyy");
        if (l842) {
            strncpy(l842, l843, 3);
        }
    }
    for (l842 = l813; l842;) {
        l842 = strstr(l842, "yyy");
        if (l842) {
            strncpy(l842, l843, 3);
        }
    }
    for (l842 = l825; l842;) {
        l842 = strstr(l842, "yyy");
        if (l842) {
            strncpy(l842, l843, 3);
        }
    }
}
void l91(char* l83,
    char* l84,
    int l87,
    l3 l85,
    FILE* l88,
    int l89)
{
    l46* l609;
    l841(l83, l85);
    l832(l83, l84, l85);
    l836(l83, l84, l85);
    l838(l83, l84, l85);
    if (l87) {
        if (l85 & 0x00000200) {
            l829(l83, l85,
                l84, l89);
        }
        else {
            l827(l83, l85,
                l89);
        }
    }
    l839(l88);
    l609 = l66("END_OF_SLK_INPUT");
    fprintf(l88, "#define START_SYMBOL %u\n", l156);
    fprintf(l88, "#define %s_ %u\n", "END_OF_SLK_INPUT", l609->l10);
    fprintf(l88, "#define START_STATE %u\n", l57);
    fprintf(l88, "#define START_CONFLICT %u\n", l154);
    fprintf(l88, "#define END_CONFLICT %u\n", l154 + l221);
    fprintf(l88, "#define START_ACTION %u\n", l155);
    fprintf(l88, "#define END_ACTION %u\n", l155 + l149);
    fprintf(l88, "#define TOTAL_CONFLICTS %u\n", l221);
    fprintf(l88, "#define PARSE_STACK_SIZE %u\n", l55);
    fprintf(l88, "%s\n", l808);
    if (!(l85 & 0x00001000)) {
        fprintf(l88,
            "#define peek(self,a)                   self.peek(a)\n"
            "#define get(self)                      self.get()\n"
            "#define mismatch(self,a,b,c)           self.mismatch(a,b,c)\n"
            "#define no_entry(self,a,b,c,d,e)       self.no_entry(a,b,c,d,e)\n"
            "#define input_left(self,a)             self.input_left(a)\n"
            "#define message(self,a,b)              self.message(a,b)\n"
            "#define predict(self,a,b,c,d,e,f,g,h)  self.predict(a,b,c,d,e,f,g,h)\n"
            "#define reduce(self,a)                 self.reduce(a)\n"
            "#define state(self,a)                  self.state(a)\n"
            "#define execute(self,a)                self.execute(a)\n\n");
    }
    fprintf(l88, "%s\n", l809);
    fprintf(l88, "%s\n", l810);
    fprintf(l88, "%s\n", l811);
    fprintf(l88, "%s\n", l812);
    fprintf(l88, "%s\n", l815);
    fprintf(l88, "%s\n", l816);
    fprintf(l88, "%s\n", l817);
    fprintf(l88, "%s\n", l818);
    fprintf(l88, "%s\n", l819);
    fprintf(l88, "%s\n", l820);
    if (l221 > 0) {
        fprintf(l88, "%s\n", l813);
        fprintf(l88, "%s\n", l814);
    }
    if (l85 & 0x00000004) {
        if (l152 > 0) {
            if (l85 & 0x00100000) {
                fprintf(l88, "#include <stdio.h>\n#include \"SlkString.h\"\n\n");
            }
            fprintf(l88, "%s", l821);
            if (l85 & 0x00100000) {
                fprintf(l88, "\t\t   printf ( \"--%%s\\n\", "
                    "SlkGetProductionName ( entry ) );\n");
            }
            fprintf(l88, "%s\n", l822);
        }
        fprintf(l88, "%s\n", l823);
        fprintf(l88, "%s\n", l824);
    }
    else if (l85 & 0x00000008) {
        fprintf(l88, "%s\n", l825);
        fprintf(l88, "%s\n", l826);
    }
}
static char l844[] =
"public static short[]\n"
"GetProductionArray ( short  production_number )\n"
"{\n"
"   short   index = (short)  Production_row [ production_number ],\n"
"           array_length = (short)  Production [ index ],\n"
"           new_index = 0;\n"
"   short[] productionArray = new short[yyy         \n"
"\n"
"   while ( array_length-- >= 0 ) {\n"
"       productionArray [ new_index++ ] = Production [ index++ ];\n"
"   }\n"
"   return  productionArray;\n"
"}\n";
static char l845[] =
"public static int GetSymbolType ( short   symbol )\n"
"{\n"
"   int   symbol_type = NOT_A_SYMBOL;\n"
"\n"
"   if ( symbol >= START_ACTION  &&  symbol < END_ACTION ) {\n"
"       symbol_type = ACTION_SYMBOL;\n"
"   } else if ( symbol >= START_SYMBOL ) {\n"
"       symbol_type = NONTERMINAL_SYMBOL;\n"
"   } else if ( symbol > 0 ) {\n"
"       symbol_type = TERMINAL_SYMBOL;\n"
"   }\n"
"   return  symbol_type;\n"
"}\n";
static char l846[] =
"public static boolean IsNonterminal ( short   symbol )\n"
"{\n"
"   return ( symbol >= START_SYMBOL  &&  symbol < START_ACTION );\n"
"}\n";
static char l847[] =
"public static boolean IsTerminal ( short   symbol )\n"
"{\n"
"   return ( symbol > 0  &&  symbol < START_SYMBOL );\n"
"}\n";
static char l848[] =
"public static boolean IsAction ( short   symbol )\n"
"{\n"
"   return ( symbol >= START_ACTION  &&  symbol < END_ACTION );\n"
"}\n";
static char l849[] =
"public static short GetTerminalIndex ( short   token )"
"{\n"
" return ( token );\n"
"}\n";
static char l850[] =
"public static short\n"
"get_production ( short     conflict_number,\n"
"                 xxxToken  tokens )\n"
"{\n"
"    short   entry = 0;\n"
"    int     index, level;\n"
"\n"
"    if ( conflict_number <= TOTAL_CONFLICTS ) {\n"
"        entry = (short) ( conflict_number + (START_CONFLICT - 1) );\n"
"        level = 1;\n"
"        while ( entry >= START_CONFLICT ) {\n"
"            index = Conflict_row [entry - (START_CONFLICT -1)];\n"
"            index += tokens.peek ( level );\n"
"            entry = Conflict [ index ];\n"
"            ++level;\n"
"        }\n"
"    }\n"
"\n"
"    return  entry;\n"
"}\n";
static char l851[] =
"private static short\n"
"get_predicted_entry ( xxxToken   tokens,\n"
"                      short      production_number,\n"
"                      short      token,\n"
"                      int        scan_level,\n"
"                      int        depth )\n";
static char l852[] =
"{\n"
" short     entry, symbol, predicted_entry, lhs;\n"
" short     save_token = token;\n"
" int       save_scan_level = scan_level;\n"
" int       production_length, top, index, level;\n"
" short[]   stack = new short[128];\n"
"\n"
" top = 127;\n"
" stack [ top ] = 0;\n"
" predicted_entry = production_number;\n"
" index = Production_row [ predicted_entry ];\n"
" lhs = Production [ ++index ];\n"
"\n"
" for (;;) {\n"
"   top = 127;\n"
"   token = save_token;\n"
"   scan_level = save_scan_level;\n"
"   index = Production_row [ predicted_entry ];\n"
"   symbol = Production [ ++index ];\n"
"   if ( symbol != lhs ) {\n"
"       predicted_entry = (short) 0;\n"
"       break;\n"
"   }\n"
"   production_length = Production [ index ] - 1;\n"
"   lhs = Production [ ++index ];\n"
"   index += production_length;\n"
"   for (;  production_length-- > 0;  --index ) {\n"
"       if ( top > 0 ) { stack [--top] = Production [index];\n"
"       } else { return 0; }\n"
"   }\n"
"   symbol = (stack[top] != 0  ? stack[top++] : (short) 0);\n"
"\n"
"   for ( ;  symbol != 0 ;  symbol = (stack[top] != 0  ? stack[top++] : (short) 0) ) {\n"
"\n"
"       if ( symbol >= START_SYMBOL  &&  symbol < START_ACTION ) {\n"
"           entry = 0;\n"
"           production_number = get_conditional_production ( symbol );\n"
"           if ( production_number != 0 ) {\n"
"               entry = get_predicted_entry ( tokens,\n"
"                                             production_number, token,\n"
"                                             scan_level, depth + 1 );\n"
"           }\n"
"           if ( entry == 0 ) {\n"
"               index = Parse_row [ symbol - (START_SYMBOL-1) ];\n"
"               index += token;\n"
"               entry = Parse [ index ];\n"
"           }\n"
"           level = scan_level;\n"
"           while ( entry >= START_CONFLICT ) {\n"
"               index = Conflict_row [entry - (START_CONFLICT -1)];\n"
"               index += tokens.peek (level);\n"
"               entry = Conflict [ index ];\n"
"               ++level;\n"
"           }\n"
"           if ( entry != 0 ) {\n"
"               index = Production_row [ entry ];\n"
"               production_length = Production [ index ] - 1;\n"
"               lhs = Production [ ++index ];\n"
"               if ( lhs == symbol ) {\n"
"                 index += production_length;\n"
"                 for (;  production_length-- > 0;  --index ) {\n"
"                     if ( top > 0 ) { stack [--top] = Production [index];\n"
"                     } else { return 0; }\n"
"                 }\n"
"               } else {\n"
"                   ++predicted_entry;\n"
"                   break;\n"
"               }\n"
"           } else {\n"
"               ++predicted_entry;\n"
"               break;\n"
"           }\n"
"       } else if ( symbol > 0 ) {\n"
"           if ( symbol == token ) {\n"
"               token = tokens.peek ( scan_level++ );\n"
"           } else {\n"
"               ++predicted_entry;\n"
"               break;\n"
"           }\n"
"       }\n"
"   }\n"
"   if ( symbol == 0 ) {\n"
"       break;\n"
"   }\n"
" }\n"
" return  predicted_entry;\n"
"}\n";
static char l853[] =
"public static void\n"
"parse ( xxxAction   action,\n"
"        xxxToken    tokens,\n"
"        xxxError    error,\n"
"        short       start_symbol )\n"
"{\n"
" short     lhs;\n"
" short     production_number, entry, symbol, token, new_token;\n"
" int       production_length, top, index, level;\n"
" short[]   stack = new short[512];\n"
"\n"
" top = 511;\n"
" stack [ top ] = 0;\n"
" if ( start_symbol == 0 ) {\n"
"     start_symbol = START_SYMBOL;\n"
" }\n"
" if ( top > 0 ) { stack [--top] = start_symbol;\n"
" } else { error.message (\"xxxParse: stack overflow\\n\"); return; }\n"
" token = tokens.get();\n"
" new_token = token;\n"
"\n"
" for ( symbol = (stack[top] != 0  ? stack[top++] : (short) 0);  symbol != 0; ) {\n"
"\n"
"     if ( symbol >= START_ACTION ) {\n"
"         action.execute ( symbol - (START_ACTION-1) );\n"
"\n"
"     } else if ( symbol >= START_SYMBOL ) {\n"
"         entry = 0;\n"
"         level = 1;\n"
"         production_number = get_conditional_production ( symbol );\n"
"         if ( production_number != 0 ) {\n"
"             entry = get_predicted_entry ( tokens,\n"
"                                           production_number, token,\n"
"                                           level, 1 );\n"
"         }\n"
"         if ( entry == 0 ) {\n"
"             index = Parse_row [ symbol - (START_SYMBOL-1) ];\n"
"             index += token;\n"
"             entry = Parse [ index ];\n"
"         }\n"
"         while ( entry >= START_CONFLICT ) {\n"
"             index = Conflict_row [entry - (START_CONFLICT -1)];\n"
"             index += tokens.peek (level);\n"
"             entry = Conflict [ index ];\n"
"             ++level;\n"
"         }\n"
"         if ( entry != 0 ) {\n"
"             index = Production_row [ entry ];\n"
"             production_length = Production [ index ] - 1;\n"
"             lhs = Production [ ++index ];\n"
"             if ( lhs == symbol ) {\n"
"                 action.predict ( entry );\n"
"                 index += production_length;\n"
"                 for (;  production_length-- > 0;  --index ) {\n"
"                     if ( top > 0 ) { stack [--top] = Production [index];\n"
"                     } else { error.message (\"xxxParse: stack overflow\\n\"); return; }\n"
"                 }\n"
"             } else {\n"
"                 new_token = error.no_entry ( symbol, token, level-1 );\n"
"             }\n"
"         } else {                                       // no table entry\n"
"             new_token = error.no_entry ( symbol, token, level-1 );\n"
"         }\n"
"     } else if ( symbol > 0 ) {\n"
"         if ( symbol == token ) {\n"
"             token = tokens.get();\n"
"             new_token = token;\n"
"         } else {\n"
"             new_token = error.mismatch ( symbol, token );\n"
"         }\n"
"     } else {\n"
"         error.message ( \"\\n parser error: symbol value 0\\n\" );\n"
"     }\n"
"     if ( token != new_token ) {\n"
"         if ( new_token != 0 ) {\n"
"             token = new_token;\n"
"         }\n"
"         if ( token != END_OF_SLK_INPUT_ ) {\n"
"             continue;\n"
"         }\n"
"     }\n"
"     symbol = (stack[top] != 0  ? stack[top++] : (short) 0);\n"
" }\n"
" if ( token != END_OF_SLK_INPUT_ ) {\n"
"     error.input_left ();\n"
" }\n"
"}\n";
static char l853_cs[] =
"internal unsafe static void\n"
"parse (ref xxxAction   action,\n"
"        ref xxxToken    tokens,\n"
"        ref xxxError    error,\n"
"        short       start_symbol )\n"
"{\n"
" short     lhs;\n"
" short     production_number, entry, symbol, token, new_token;\n"
" int       production_length, top, index, level;\n"
" short* stack = stackalloc short[PARSE_STACK_SIZE];\n"
"\n"
" top = PARSE_STACK_SIZE - 1;\n"
" stack [ top ] = 0;\n"
" if ( start_symbol == 0 ) {\n"
"     start_symbol = START_SYMBOL;\n"
" }\n"
" if ( top > 0 ) { stack [--top] = start_symbol;\n"
" } else { error.message (\"xxxParse: stack overflow\\n\", ref tokens); return; }\n"
" token = tokens.get();\n"
" new_token = token;\n"
"\n"
" for ( symbol = (stack[top] != 0  ? stack[top++] : (short) 0);  symbol != 0; ) {\n"
"\n"
"     if ( symbol >= START_ACTION ) {\n"
"         action.execute ( symbol - (START_ACTION-1) );\n"
"\n"
"     } else if ( symbol >= START_SYMBOL ) {\n"
"         entry = 0;\n"
"         level = 1;\n"
"         production_number = get_conditional_production ( symbol );\n"
"         if ( production_number != 0 ) {\n"
"             entry = get_predicted_entry ( tokens,\n"
"                                           production_number, token,\n"
"                                           level, 1 );\n"
"         }\n"
"         if ( entry == 0 ) {\n"
"             index = Parse_row [ symbol - (START_SYMBOL-1) ];\n"
"             index += token;\n"
"             entry = Parse [ index ];\n"
"         }\n"
"         while ( entry >= START_CONFLICT ) {\n"
"             index = Conflict_row [entry - (START_CONFLICT -1)];\n"
"             index += tokens.peek (level);\n"
"             entry = Conflict [ index ];\n"
"             ++level;\n"
"         }\n"
"         if ( entry != 0 ) {\n"
"             index = Production_row [ entry ];\n"
"             production_length = Production [ index ] - 1;\n"
"             lhs = Production [ ++index ];\n"
"             if ( lhs == symbol ) {\n"
"                 action.predict ( entry, symbol, token, level - 1, tokens.getLastToken(), tokens.getLastLineNumber(), tokens.getCurToken(), tokens.getLineNumber() );\n"
"                 index += production_length;\n"
"                 for (;  production_length-- > 0;  --index ) {\n"
"                     if ( top > 0 ) { stack [--top] = Production [index];\n"
"                     } else { error.message (\"xxxParse: stack overflow\\n\", ref tokens); return; }\n"
"                 }\n"
"             } else {\n"
"                 new_token = error.no_entry ( entry, symbol, token, level - 1, ref tokens );\n"
"             }\n"
"         } else {                                       // no table entry\n"
"             new_token = error.no_entry ( entry, symbol, token, level - 1, ref tokens );\n"
"         }\n"
"     } else if ( symbol > 0 ) {\n"
"         if ( symbol == token ) {\n"
"             token = tokens.get();\n"
"             new_token = token;\n"
"         } else {\n"
"             new_token = error.mismatch ( symbol, token, ref tokens );\n"
"         }\n"
"     } else {\n"
"         error.message ( \"\\n parser error: symbol value 0\\n\", ref tokens );\n"
"     }\n"
"     if ( token != new_token ) {\n"
"         if ( new_token != 0 ) {\n"
"             token = new_token;\n"
"         }\n"
"         if ( token != END_OF_SLK_INPUT_ ) {\n"
"             continue;\n"
"         }\n"
"     }\n"
"     symbol = (stack[top] != 0  ? stack[top++] : (short) 0);\n"
" }\n"
" if ( token != END_OF_SLK_INPUT_ ) {\n"
"     error.input_left (ref tokens);\n"
" }\n"
"}\n";
static char l854[] =
"public static void\n"
"parse ( xxxAction   action,\n"
"        xxxToken    tokens,\n"
"        xxxError    error,\n"
"        short       start_symbol )\n"
"{\n"
" short     lhs;\n"
" short     state, production_number, entry, symbol, token, new_token;\n"
" int       action_number, production_length, top, index, level;\n"
" short[]   stack = new short[512];\n"
"\n"
" top = 511;\n"
" stack [ top ] = 0;\n"
" if ( start_symbol == 0 ) {\n"
"     start_symbol = START_SYMBOL;\n"
" }\n"
" if ( top > 0 ) { stack [--top] = 1;\n"
" } else { error.message (\"xxxParse: stack overflow\\n\"); return; }\n"
" token = tokens.get();\n"
" new_token = token;\n"
"\n"
" for ( state = stack[top];  state != 0;  ) {\n"
"     index = Parse_row [ state ];\n"
"     index += token;\n"
"     entry = Parse [ index ];\n"
"     if ( state != Parse_state [ index ] )  entry = 0;\n"
"     level = 1;\n"
"     action.state ( state );\n"
"\n"
"     if ( entry >= START_CONFLICT ) {\n"
"         while ( entry >= START_CONFLICT && entry < END_CONFLICT ) {\n"
"             index = Conflict_row [entry - (START_CONFLICT -1)];\n"
"             index += tokens.peek (level);\n"
"             entry = Conflict [ index ];\n"
"             ++level;\n"
"         }\n"
"     }\n"
"     if ( entry >= START_STATE ) {\n"
"         state = (short) (entry - (START_STATE - 1));\n"
"         if ( top > 0 ) { stack [--top] = state;\n"
"         } else { error.message (\"xxxParse: stack overflow\\n\"); return; }\n"
"         token = tokens.get();\n"
"         new_token = token;\n"
"\n"
"     } else if ( entry > 0 ) {\n"
"         action.reduce ( entry );\n"
"         production_number = entry;\n"
"         action_number = Action_number [production_number];\n"
"         if ( action_number != 0 ) {\n"
"             action_number -= (START_ACTION-1);\n"
"             if ( action_number < END_ACTION ) {\n"
"                 action.execute ( action_number );\n"
"             } else {\n"
"                 error.message ( \"\\n error: action out of range\\n\" );\n"
"             }\n"
"         }\n"
"         index = Production_row [ entry ];\n"
"         production_length = Production [ index ] - 1;\n"
"         lhs = Production [ ++index ];\n"
"         for (;  production_length > 0;  --production_length ) {\n"
"              if ( stack[top] != 0 )  ++top;\n"
"         }\n"
"         state = stack[top];\n"
"         index = Parse_row [ state ];\n"
"         index += lhs;\n"
"         entry = Parse [ index ];\n"
"         if ( state != Parse_state [ index ] )  entry = 0;\n"
"         if ( entry >= START_CONFLICT ) {\n"
"             error.message ( \"\\n reduce error: conflict not state\\n\" );\n"
"         } else if ( entry >= START_STATE ) {\n"
"             state = (short) (entry - (START_STATE - 1));\n"
"             if ( top > 0 ) { stack [--top] = state;\n"
"             } else { error.message (\"xxxParse: stack overflow\\n\"); return; }\n"
"         } else if ( entry > 0 ) {\n"
"             error.message ( \"\\n reduce error: not a state\\n\" );\n"
"         } else if ( token != END_OF_SLK_INPUT_ ) {\n"
"             new_token = error.no_entry ( state, token, level-1 );\n"
"         }\n"
"     } else {\n"
"         new_token = error.no_entry ( state, token, level-1 );\n"
"         if ( new_token == END_OF_SLK_INPUT_ ) {\n"
"             break;\n"
"         }\n"
"     }\n"
"     if ( token != new_token ) {\n"
"         if ( new_token != 0 ) {\n"
"             token = new_token;\n"
"         }\n"
"     }\n"
"     state = stack[top];\n"
"     if ( state <= 1 ) {\n"
"         break;\n"
"     }\n"
" }\n"
" if ( token != END_OF_SLK_INPUT_ ) {\n"
"     error.input_left ();\n"
" }\n"
"}\n";
static char l855[] =
"function\n"
"GetProductionArray ( production_number )\n"
"{\n"
"   var     index =    Production_row [ production_number ],\n"
"           array_length =    Production [ index ],\n"
"           new_index = 0;\n"
"   var     productionArray = new Array(yyy         \n"
"\n"
"   while ( array_length-- >= 0 ) {\n"
"       productionArray [ new_index++ ] = Production [ index++ ];\n"
"   }\n"
"   return  productionArray;\n"
"}\n";
static char l856[] =
"function GetSymbolType ( symbol )\n"
"{\n"
"   var   symbol_type = NOT_A_SYMBOL;\n"
"\n"
"   if ( symbol >= START_ACTION  &&  symbol < END_ACTION ) {\n"
"       symbol_type = ACTION_SYMBOL;\n"
"   } else if ( symbol >= START_SYMBOL ) {\n"
"       symbol_type = NONTERMINAL_SYMBOL;\n"
"   } else if ( symbol > 0 ) {\n"
"       symbol_type = TERMINAL_SYMBOL;\n"
"   }\n"
"   return  symbol_type;\n"
"}\n";
static char l857[] =
"function IsNonterminal ( symbol )\n"
"{\n"
"   return ( symbol >= START_SYMBOL  &&  symbol < START_ACTION );\n"
"}\n";
static char l858[] =
"function IsTerminal ( symbol )\n"
"{\n"
"   return ( symbol > 0  &&  symbol < START_SYMBOL );\n"
"}\n";
static char l859[] =
"function IsAction ( symbol )\n"
"{\n"
"   return ( symbol >= START_ACTION  &&  symbol < END_ACTION );\n"
"}\n";
static char l860[] =
"function GetTerminalIndex ( token )"
"{\n"
" return ( token );\n"
"}\n";
static char l861[] =
"function\n"
"get_production ( conflict_number, tokens )\n"
"{\n"
"    var     entry = 0;\n"
"    var     index, level;\n"
"\n"
"    if ( conflict_number <= TOTAL_CONFLICTS ) {\n"
"        entry =   ( conflict_number + (START_CONFLICT - 1) );\n"
"        level = 1;\n"
"        while ( entry >= START_CONFLICT ) {\n"
"            index = Conflict_row [entry - (START_CONFLICT -1)];\n"
"            index += tokens.peek ( level );\n"
"            entry = Conflict [ index ];\n"
"            ++level;\n"
"        }\n"
"    }\n"
"\n"
"    return  entry;\n"
"}\n";
static char l862[] =
"function\n"
"get_predicted_entry ( tokens, production_number, token, scan_level, depth )\n";
static char l863[] =
"{\n"
" var       entry, symbol, predicted_entry, lhs;\n"
" var       save_token = token;\n"
" var       save_scan_level = scan_level;\n"
" var       production_length, top, index, level;\n"
" var       stack = new Array(128);\n"
"\n"
" top = 127;\n"
" stack [ top ] = 0;\n"
" predicted_entry = production_number;\n"
" index = Production_row [ predicted_entry ];\n"
" lhs = Production [ ++index ];\n"
"\n"
" for (;;) {\n"
"   top = 127;\n"
"   token = save_token;\n"
"   scan_level = save_scan_level;\n"
"   index = Production_row [ predicted_entry ];\n"
"   symbol = Production [ ++index ];\n"
"   if ( symbol != lhs ) {\n"
"       predicted_entry =   0;\n"
"       break;\n"
"   }\n"
"   production_length = Production [ index ] - 1;\n"
"   lhs = Production [ ++index ];\n"
"   index += production_length;\n"
"   for (;  production_length-- > 0;  --index ) {\n"
"       if ( top > 0 ) { stack [--top] = Production [index];\n"
"       } else { return 0; }\n"
"   }\n"
"   symbol = (stack[top] != 0  ? stack[top++] :   0);\n"
"\n"
"   for ( ;  symbol != 0 ;  symbol = (stack[top] != 0  ? stack[top++] :   0) ) {\n"
"\n"
"       if ( symbol >= START_SYMBOL  &&  symbol < START_ACTION ) {\n"
"           entry = 0;\n"
"           production_number = get_conditional_production ( symbol );\n"
"           if ( production_number != 0 ) {\n"
"               entry = get_predicted_entry ( tokens,\n"
"                                             production_number, token,\n"
"                                             scan_level, depth + 1 );\n"
"           }\n"
"           if ( entry == 0 ) {\n"
"               index = Parse_row [ symbol - (START_SYMBOL-1) ];\n"
"               index += token;\n"
"               entry = Parse [ index ];\n"
"           }\n"
"           level = scan_level;\n"
"           while ( entry >= START_CONFLICT ) {\n"
"               index = Conflict_row [entry - (START_CONFLICT -1)];\n"
"               index += tokens.peek (level);\n"
"               entry = Conflict [ index ];\n"
"               ++level;\n"
"           }\n"
"           if ( entry != 0 ) {\n"
"               index = Production_row [ entry ];\n"
"               production_length = Production [ index ] - 1;\n"
"               lhs = Production [ ++index ];\n"
"               if ( lhs == symbol ) {\n"
"                 index += production_length;\n"
"                 for (;  production_length-- > 0;  --index ) {\n"
"                     if ( top > 0 ) { stack [--top] = Production [index];\n"
"                     } else { return 0; }\n"
"                 }\n"
"               } else {\n"
"                   ++predicted_entry;\n"
"                   break;\n"
"               }\n"
"           } else {\n"
"               ++predicted_entry;\n"
"               break;\n"
"           }\n"
"       } else if ( symbol > 0 ) {\n"
"           if ( symbol == token ) {\n"
"               token = tokens.peek ( scan_level++ );\n"
"           } else {\n"
"               ++predicted_entry;\n"
"               break;\n"
"           }\n"
"       }\n"
"   }\n"
"   if ( symbol == 0 ) {\n"
"       break;\n"
"   }\n"
" }\n"
" return  predicted_entry;\n"
"}\n";
static char l864[] =
"function\n"
"parse ( action, tokens, error, start_symbol )\n"
"{\n"
" var     lhs;\n"
" var     production_number, entry, symbol, token, new_token;\n"
" var       production_length, top, index, level;\n"
" var   stack = new Array(512);\n"
"\n"
" top = 511;\n"
" stack [ top ] = 0;\n"
" if ( start_symbol == 0 ) {\n"
"     start_symbol = START_SYMBOL;\n"
" }\n"
" if ( top > 0 ) { stack [--top] = start_symbol;\n"
" } else { error.message (\"xxxParse: stack overflow\\n\"); return; }\n"
" token = tokens.get();\n"
" new_token = token;\n"
"\n"
" for ( symbol = (stack[top] != 0  ? stack[top++] : 0);  symbol != 0; ) {\n"
"\n"
"     if ( symbol >= START_ACTION ) {\n"
"         action.execute ( symbol - (START_ACTION-1) );\n"
"\n"
"     } else if ( symbol >= START_SYMBOL ) {\n"
"         entry = 0;\n"
"         level = 1;\n"
"         production_number = get_conditional_production ( symbol );\n"
"         if ( production_number != 0 ) {\n"
"             entry = get_predicted_entry ( tokens,\n"
"                                           production_number, token,\n"
"                                           level, 1 );\n"
"         }\n"
"         if ( entry == 0 ) {\n"
"             index = Parse_row [ symbol - (START_SYMBOL-1) ];\n"
"             index += token;\n"
"             entry = Parse [ index ];\n"
"         }\n"
"         while ( entry >= START_CONFLICT ) {\n"
"             index = Conflict_row [entry - (START_CONFLICT -1)];\n"
"             index += tokens.peek (level);\n"
"             entry = Conflict [ index ];\n"
"             ++level;\n"
"         }\n"
"         if ( entry != 0 ) {\n"
"             index = Production_row [ entry ];\n"
"             production_length = Production [ index ] - 1;\n"
"             lhs = Production [ ++index ];\n"
"             if ( lhs == symbol ) {\n"
"                 action.predict ( entry );\n"
"                 index += production_length;\n"
"                 for (;  production_length-- > 0;  --index ) {\n"
"                     if ( top > 0 ) { stack [--top] = Production [index];\n"
"                     } else { error.message (\"xxxParse: stack overflow\\n\"); return; }\n"
"                 }\n"
"             } else {\n"
"                 new_token = error.no_entry ( symbol, token, level-1 );\n"
"             }\n"
"         } else {                                       // no table entry\n"
"             new_token = error.no_entry ( symbol, token, level-1 );\n"
"         }\n"
"     } else if ( symbol > 0 ) {\n"
"         if ( symbol == token ) {\n"
"             token = tokens.get();\n"
"             new_token = token;\n"
"         } else {\n"
"             new_token = error.mismatch ( symbol, token );\n"
"         }\n"
"     } else {\n"
"         error.message ( \"\\n parser error: symbol value 0\\n\" );\n"
"     }\n"
"     if ( token != new_token ) {\n"
"         if ( new_token != 0 ) {\n"
"             token = new_token;\n"
"         }\n"
"         if ( token != END_OF_SLK_INPUT_ ) {\n"
"             continue;\n"
"         }\n"
"     }\n"
"     symbol = (stack[top] != 0  ? stack[top++] : 0);\n"
" }\n"
" if ( token != END_OF_SLK_INPUT_ ) {\n"
"     error.input_left ();\n"
" }\n"
"}\n";
static char l865[] =
"function\n"
"parse (   action,\n"
"           tokens,\n"
"           error,\n"
"              start_symbol )\n"
"{\n"
" var     lhs;\n"
" var     state, production_number, entry, symbol, token, new_token;\n"
" var       action_number, production_length, top, index, level;\n"
" var   stack = new Array(512);\n"
"\n"
" top = 511;\n"
" stack [ top ] = 0;\n"
" if ( start_symbol == 0 ) {\n"
"     start_symbol = START_SYMBOL;\n"
" }\n"
" if ( top > 0 ) { stack [--top] = 1;\n"
" } else { error.message (\"xxxParse: stack overflow\\n\"); return; }\n"
" token = tokens.get();\n"
" new_token = token;\n"
"\n"
" for ( state = stack[top];  state != 0;  ) {\n"
"     index = Parse_row [ state ];\n"
"     index += token;\n"
"     entry = Parse [ index ];\n"
"     if ( state != Parse_state [ index ] )  entry = 0;\n"
"     level = 1;\n"
"     action.state ( state );\n"
"\n"
"     if ( entry >= START_CONFLICT ) {\n"
"         while ( entry >= START_CONFLICT && entry < END_CONFLICT ) {\n"
"             index = Conflict_row [entry - (START_CONFLICT -1)];\n"
"             index += tokens.peek (level);\n"
"             entry = Conflict [ index ];\n"
"             ++level;\n"
"         }\n"
"     }\n"
"     if ( entry >= START_STATE ) {\n"
"         state =   (entry - (START_STATE - 1));\n"
"         if ( top > 0 ) { stack [--top] = state;\n"
"         } else { error.message (\"xxxParse: stack overflow\\n\"); return; }\n"
"         token = tokens.get();\n"
"         new_token = token;\n"
"\n"
"     } else if ( entry > 0 ) {\n"
"         action.reduce ( entry );\n"
"         production_number = entry;\n"
"         action_number = Action_number [production_number];\n"
"         if ( action_number != 0 ) {\n"
"             action_number -= (START_ACTION-1);\n"
"             if ( action_number < END_ACTION ) {\n"
"                 action.execute ( action_number );\n"
"             } else {\n"
"                 error.message ( \"\\n error: action out of range\\n\" );\n"
"             }\n"
"         }\n"
"         index = Production_row [ entry ];\n"
"         production_length = Production [ index ] - 1;\n"
"         lhs = Production [ ++index ];\n"
"         for (;  production_length > 0;  --production_length ) {\n"
"              if ( stack[top] != 0 )  ++top;\n"
"         }\n"
"         state = stack[top];\n"
"         index = Parse_row [ state ];\n"
"         index += lhs;\n"
"         entry = Parse [ index ];\n"
"         if ( state != Parse_state [ index ] )  entry = 0;\n"
"         if ( entry >= START_CONFLICT ) {\n"
"             error.message ( \"\\n reduce error: conflict not state\\n\" );\n"
"         } else if ( entry >= START_STATE ) {\n"
"             state =   (entry - (START_STATE - 1));\n"
"             if ( top > 0 ) { stack [--top] = state;\n"
"             } else { error.message (\"xxxParse: stack overflow\\n\"); return; }\n"
"         } else if ( entry > 0 ) {\n"
"             error.message ( \"\\n reduce error: not a state\\n\" );\n"
"         } else if ( token != END_OF_SLK_INPUT_ ) {\n"
"             new_token = error.no_entry ( state, token, level-1 );\n"
"         }\n"
"     } else {\n"
"         new_token = error.no_entry ( state, token, level-1 );\n"
"         if ( new_token == END_OF_SLK_INPUT_ ) {\n"
"             break;\n"
"         }\n"
"     }\n"
"     if ( token != new_token ) {\n"
"         if ( new_token != 0 ) {\n"
"             token = new_token;\n"
"         }\n"
"     }\n"
"     state = stack[top];\n"
"     if ( state <= 1 ) {\n"
"         break;\n"
"     }\n"
" }\n"
" if ( token != END_OF_SLK_INPUT_ ) {\n"
"     error.input_left ();\n"
" }\n"
"}\n";
typedef struct l866
{
    char* l867;
    char* l559;
    char* l560;
    char* l868;
    char* l869;
    char* l870;
    char* l871;
    char* l872;
    char* l873;
    char* l874;
    char* l875;
    char* l876;
    char* l877;
    char* l878;
    char* l879;
    char* l880;
    char* l881;
    char* l882;
    char* l883;
    char* l884;
    char* l885;
    char* l886;
    char* l887;
    char* l888;
    char* l889;
    char* l890;
} l891;
static l891 l892 = {
    "java",
    "{",
    "}",
    "",
    "package",
    "public class",
    "(short)",
    "short",
    "private static final short",
    "public static final short",
    "public static final int",
    "private static short",
    "private static short[]",
    "public static short[]",
    "public static String[]",
    l844,
    l845,
    l846,
    l847,
    l848,
    l849,
    l850,
    l851,
    l852,
    l853,
    l854 };
static l891 l893 = {
    "js",
    "[",
    "]",
    "=",
    "",
    "var",
    "",
    "",
    "var",
    "var",
    "var",
    "function",
    "var",
    "var",
    "var",
    l855,
    l856,
    l857,
    l858,
    l859,
    l860,
    l861,
    l862,
    l863,
    l864,
    l865 };
static l891 l894 = {
    "cs",
    "{",
    "}",
    "",
    "namespace",
    "class",
    "(short)",
    "short",
    "private const short",
    "public const short",
    "public const int",
    "private static short",
    "private static short[]",
    "public static short[]",
    "public static string[]",
    l844,
    l845,
    l846,
    l847,
    l848,
    l849,
    l850,
    l851,
    l852,
    l853_cs,
    l854 };
static l891 l895;
static void
l896(char* l83,
    l3 l85,
    l3 l89)
{
    register l46** l126;
    int l830,
        l831 = 0;
    FILE* l566;
    l5* l509,
        * l510,
        * type_name = "public void ",
        * l897 = "",
        * l898 = "int",
        l75[32];
    sprintf(l75, "%sExecute.txt", l83);
    if (l85 & 0x00002000) {
        type_name = "this.";
        l897 = "= function";
        l898 = "";
    }
    l566 = fopen(l75, "w");
    if (!l566) {
        perror(l75);
        l59(1118, "");
    }
    fprintf(l566, "\n// %s - generated by the SLK parser generator \n\n",
        l75);
    fprintf(l566, "// This file can be edited into the SlkAction class. \n\n");
    fprintf(l566, "%sexecute %s ( %s  number )\n"
        "{\n"
        "  switch ( number ) {\n",
        type_name, l897, l898);
    for (l126 = l145; *++l126; ++l831) {
        l509 = (*l126)->l11;
        l830 = (*l126)->l10;
        l510 = l509;
        if (!l89) {
            l510 += l73(l510);
        }
        fprintf(l566, "    case %d:  %s();  break;\n",
            (l830 - (l155 - 1)), l510);
        if (((*l510 >= '0' && *l510 <= '9'))) {
            l59(1119, "Cannot mix numbered actions with named actions");
        }
    }
    fprintf(l566, "  }\n}\n");
    fclose(l566);
}
static void
l899(char* l83,
    char* l84,
    l3 l85)
{
    register l46** l126;
    int l10,
        l837,
        l833;
    l46* l609;
    FILE* l566;
    l5 l75[32],
        l900[32] = "",
        * l12,
        * l11;
    char* l901 = "static";
    if (l85 & 0x00000800) {
        l901 = "";
    }
    if (!(l85 & 0x00002000)) {
        sprintf(l900, "%sConstants.", l83);
    }
    sprintf(l75, "%sKeywords.txt", l83);
    l566 = fopen(l75, "w");
    if (!l566) {
        perror(l75);
        l59(1191, "");
    }
    fprintf(l566, "\n// %s - generated by the SLK parser generator \n\n",
        l75);
    fprintf(l566, "// Assumes all alpha terminals are keywords, "
        "usually needs manual editing to remove non-keywords.\n\n");
    if (!(l85 & 0x00002000)) {
        fprintf(l566, "%s %sKeywords {\n\n", l895.l870, l83);
    }
    l609 = l66("END_OF_SLK_INPUT");
    l837 = l609->l10;
    fprintf(l566, "%s name = %s\n\n", l895.l879, l895.l559);
    l833 = 0;
    for (l126 = l144; *++l126;) {
        l10 = (*l126)->l10;
        if (l10 == l837) {
            continue;
        }
        l11 = (*l126)->l11;
        if (l11 && (((*l11 >= 'a' && *l11 <= 'z')) || ((*l11 >= 'A' && *l11 <= 'Z'))) || (((*(l11 + 1) >= 'a' && *(l11 + 1) <= 'z')) || ((*(l11 + 1) >= 'A' && *(l11 + 1) <= 'Z')))) {
            if (l833) {
                fprintf(l566, ",\"%s\"\n", l11);
            }
            else {
                fprintf(l566, " \"%s\"\n", l11);
                l833 = 1;
            }
        }
    }
    fprintf(l566, "%s; \n\n", l895.l560);
    if (l85 & 0x00002000) {
        fprintf(l566, "var token = [\n\n");
    }
    else {
        fprintf(l566, "public %s short[] token = {\n\n", l901);
    }
    l833 = 0;
    for (l126 = l144; *++l126;) {
        l10 = (*l126)->l10;
        if (l10 == l837) {
            continue;
        }
        l11 = (*l126)->l11;
        if (l11 && (((*l11 >= 'a' && *l11 <= 'z')) || ((*l11 >= 'A' && *l11 <= 'Z'))) || (((*(l11 + 1) >= 'a' && *(l11 + 1) <= 'z')) || ((*(l11 + 1) >= 'A' && *(l11 + 1) <= 'Z')))) {
            l12 = (*l126)->l12;
            if (l833) {
                fprintf(l566, ",%s%s \n", l900, l12);
            }
            else {
                fprintf(l566, " %s%s \n", l900, l12);
                l833 = 1;
            }
        }
    }
    fprintf(l566, "%s; \n\n", l895.l560);
    if (!(l85 & 0x00002000)) {
        fprintf(l566, "}; \n\n");
    }
    if (!(l85 & 0x00000400)) {
        if (l84) {
            fprintf(l566, "\n\n}\n");
        }
    }
    fclose(l566);
}
static void
l902(char* l83,
    char* l84,
    l3 l85)
{
    register l46** l126;
    int l10;
    FILE* l566;
    l5 l75[32],
        * l12;
    char* l124 = "",
        * l125 = "";
    if (l85 & 0x00000002) {
        l125 = l83;
    }
    sprintf(l75, "%sConstants.%s", l83, l895.l867);
    l566 = fopen(l75, "w");
    if (!l566) {
        perror(l75);
        l59(1121, "");
    }
    fprintf(l566, "\n// %s - generated by the SLK parser generator \n\n", l75);
    if (l84) {
        if (l85 & 0x00000400)
            fprintf(l566, "%s %s;\n\n", l895.l869, l84);
        else
            fprintf(l566, "%s %s {\n\n", l895.l869, l84);
    }
    if (!(l85 & 0x00002000)) {
        fprintf(l566, "%s %sConstants {\n\n", l895.l870, l83);
    }
    for (l126 = l144; *++l126;) {
        l10 = (*l126)->l10;
        l12 = l123(l124, l125, l126, 1);
        (*l126)->l12 = l64(l12);
        fprintf(l566, "%s  %s = %d;\n", l895.l874, l12, l10);
    }
    fprintf(l566, "\n\n");
    l124 = "NT_";
    for (l126 = l143; *++l126;) {
        l10 = (*l126)->l10;
        l12 = l123(l124, l125, l126, 0);
        fprintf(l566, "%s  %s = %d;\n", l895.l874, l12, l10);
    }
    if (!(l85 & 0x00002000)) {
        fprintf(l566, "\n\n};\n");
    }
    if (!(l85 & 0x00000400)) {
        if (l84) {
            fprintf(l566, "\n\n}\n");
        }
    }
    fclose(l566);
}
static void
l903(register FILE* l88)
{
    register l46** l179;
    int l261,
        l438 = 0,
        l840;
    if (l152 == 0) {
        fprintf(l88, "%s get_conditional_production ( %s symbol ) "
            "{ return %s 0; }\n\n",
            l895.l876, l895.l872,
            l895.l871);
    }
    else if (l152 == 1) {
        fprintf(l88, "%s get_conditional_production ( %s symbol )\n"
            "{ return (",
            l895.l876, l895.l872);
        for (l179 = l143; *++l179;) {
            if ((*l179)->l45) {
                l261 = l169(*l179);
                fprintf(l88, " symbol == %d ? %d :", (*l179)->l10,
                    l261);
            }
        }
        fprintf(l88, " %s 0 ); }\n\n", l895.l871);
    }
    else {
        l840 = l156 + l147 - 1 -
            l152;
        fprintf(l88, "%s Conditional_production = {0\n", l895.l877);
        for (l179 = l143; *++l179;) {
            if ((*l179)->l45) {
                l261 = l169(*l179);
                fprintf(l88, ",%d", l261);
                if (++l438 > 20) {
                    l438 = 0;
                    fputs("\n", l88);
                }
            }
        }
        fprintf(l88, "};\n\n");
        fprintf(l88,
            "%s get_conditional_production ( %s symbol )\n"
            "{ return ( symbol > %d ? Conditional_production [symbol - %d]"
            " : %s 0 ); }\n\n",
            l895.l876, l895.l872,
            l840, l840, l895.l871);
    }
}
static void
l904(char* l83,
    l3 l85)
{
    char* l568,
        * l842;
    for (l568 = l851; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l852; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    if (!(l85 & 0x00000080)) {
        for (l568 = l852; l568;) {
            l568 = strstr(l568, "display != 0");
            if (l568) {
                strncpy(l568, "    false   ", 12);
            }
        }
    }
    if (!(l85 & 0x00000001)) {
        for (l568 = l854; l568;) {
            l568 = strstr(l568, "if ( state != Parse_state");
            if (l568) {
                strncpy(l568, "//   ", 5);
            }
        }
    }
    for (l568 = l854; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l853; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l853_cs; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l850; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    if (l85 & 0x00000800) {
        for (l568 = l846; l568;) {
            l568 = strstr(l568, "ean");
            if (l568) {
                strncpy(l568, "   ", 3);
            }
            break;
        }
        for (l568 = l847; l568;) {
            l568 = strstr(l568, "ean");
            if (l568) {
                strncpy(l568, "   ", 3);
            }
            break;
        }
        for (l568 = l848; l568;) {
            l568 = strstr(l568, "ean");
            if (l568) {
                strncpy(l568, "   ", 3);
            }
            break;
        }
    }
    for (l842 = l844; l842;) {
        char l342[32];
        sprintf(l342, "%d];", l153 + 4);
        l842 = strstr(l842, "yyy");
        if (l842) {
            strncpy(l842, l342, strlen(l342));
        }
        break;
    }
}
static void
l905(char* l83,
    l3 l85)
{
    char* l568,
        * l842;
    for (l568 = l862; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l863; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    if (!(l85 & 0x00000080)) {
        for (l568 = l863; l568;) {
            l568 = strstr(l568, "display != 0");
            if (l568) {
                strncpy(l568, "    false   ", 12);
            }
        }
    }
    if (!(l85 & 0x00000001)) {
        for (l568 = l865; l568;) {
            l568 = strstr(l568, "if ( state != Parse_state");
            if (l568) {
                strncpy(l568, "//   ", 5);
            }
        }
    }
    for (l568 = l865; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l864; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    for (l568 = l861; l568;) {
        l568 = strstr(l568, "xxx");
        if (l568) {
            strncpy(l568, l83, 3);
        }
    }
    if (l85 & 0x00000800) {
        for (l568 = l857; l568;) {
            l568 = strstr(l568, "ean");
            if (l568) {
                strncpy(l568, "   ", 3);
            }
            break;
        }
        for (l568 = l858; l568;) {
            l568 = strstr(l568, "ean");
            if (l568) {
                strncpy(l568, "   ", 3);
            }
            break;
        }
        for (l568 = l859; l568;) {
            l568 = strstr(l568, "ean");
            if (l568) {
                strncpy(l568, "   ", 3);
            }
            break;
        }
    }
    for (l842 = l855; l842;) {
        char l342[32];
        sprintf(l342, "%d);", l153 + 4);
        l842 = strstr(l842, "yyy");
        if (l842) {
            strncpy(l842, l342, strlen(l342));
        }
        break;
    }
}
void l90(char* l83,
    char* l84,
    int l87,
    l3 l85,
    FILE* l88,
    int l89)
{
    l46* l126;
    if (l85 & 0x00002000) {
        l895 = l893;
    }
    else if (l85 & 0x00000400) {
        l895 = l892;
    }
    else if (l85 & 0x00000800) {
        l895 = l894;
    }
    l904(l83, l85);
    l905(l83, l85);
    l902(l83, l84, l85);
    l899(l83, l84, l85);
    if (l87) {
        l896(l83, l85, l89);
    }
    l903(l88);
    l126 = l66("END_OF_SLK_INPUT");
    fprintf(l88, "%s   %s_ = %d;\n",
        l895.l873, "END_OF_SLK_INPUT", l126->l10);
    fprintf(l88, "%s   START_SYMBOL = %d;\n",
        l895.l873, l156);
    fprintf(l88, "%s   START_STATE = %d;\n",
        l895.l873, l57);
    fprintf(l88, "%s   START_CONFLICT = %d;\n",
        l895.l873, l154);
    fprintf(l88, "%s   END_CONFLICT = %d;\n",
        l895.l873, l154 + l221);
    fprintf(l88, "%s   START_ACTION = %d;\n",
        l895.l873, l155);
    fprintf(l88, "%s   END_ACTION = %d;\n",
        l895.l873, l155 + l149);
    fprintf(l88, "%s   TOTAL_CONFLICTS = %d;\n\n",
        l895.l873, l221);
    fprintf(l88, "%s   NOT_A_SYMBOL = 0;\n", l895.l875);
    fprintf(l88, "%s   NONTERMINAL_SYMBOL = 1;\n", l895.l875);
    fprintf(l88, "%s   TERMINAL_SYMBOL = 2;\n", l895.l875);
    fprintf(l88, "%s   ACTION_SYMBOL = 3;\n\n", l895.l875);
    fprintf(l88, "%s   PARSE_STACK_SIZE = %d;\n\n", l895.l875, l55);
    fprintf(l88, "%s\n", l895.l880);
    fprintf(l88, "%s\n", l895.l881);
    fprintf(l88, "%s\n", l895.l882);
    fprintf(l88, "%s\n", l895.l883);
    fprintf(l88, "%s\n", l895.l884);
    fprintf(l88, "%s\n", l895.l885);
    fprintf(l88, "%s\n", l895.l886);
    fprintf(l88, "%s", l895.l887);
    if (l152 > 0) {
        fprintf(l88, "%s\n", l895.l888);
    }
    else {
        fprintf(l88, "{\n return  0;\n}\n\n");
    }
    if (l85 & 0x00000004) {
        fprintf(l88, "%s\n", l895.l889);
    }
    else if (l85 & 0x00000008) {
        fprintf(l88, "%s\n", l895.l890);
    }
    if (!(l85 & 0x00002000)) {
        fprintf(l88, "\n\n};\n");
    }
}
#include <stdio.h>
#include <stdlib.h>

static l749(l754)(l760* l906)
{
    if (l906->l646 < l906->l751) {
        return l906->l201[l906->l646++];
    }
    else {
        return NULL;
    }
}
static void(l755)(l760* l906,
    l749 l756)
{
    if (l906->l751 >= l906->l752) {
        l906->l201 = (l749*)realloc(l906->l201,
            (l906->l752 + 1 + l906->l753) * sizeof(l749));
        if (!l906->l201) {
            puts("list_t: out of memory");
            exit(1);
        }
        l906->l752 += l906->l753 - 1;
    }
    l906->l201[l906->l751++] = l756;
}
static void(l757)(l760* l906)
{
    int l711;
    for (l711 = 0; l711 < l906->l751; ++l711) {
        puts((*(l906->l201[l711]))->l11);
    }
}
static void(l758)(l760* l906)
{
    l906->l646 = 0;
}
static void(l759)(l760* l906)
{
    free(l906->l201);
}
void l761(l760* l201)
{
    int l753 = 64 * 1024;
    l201->l646 = 0;
    l201->l751 = 0;
    l201->l753 = l753;
    l201->l752 = l753 - 1;
    l201->l201 = (l749*)malloc(l753 * sizeof(l749));
    l201->l758 = l758;
    l201->l754 = l754;
    l201->l755 = l755;
    l201->l757 = l757;
    l201->l759 = l759;
}
extern char* l502;
typedef struct l907
{
    struct l907* l8;
    l3 l131;
    l3 l367;
    struct l908* l202;
} l909;
typedef struct l908
{
    struct l908* l8;
    struct l7** l170,
        ** l177;
    struct l13* l15;
    l3 l261;
    l3 l910;
} l911;
typedef struct l912
{
    struct l912* l8;
    struct l913* l914;
    l46* l126;
} l915;
typedef struct l913
{
    struct l913* l8;
    l3 l138;
    struct l908* l916;
    struct l912* l917;
    struct l907* l278;
    l3 l918;
    l3 l919;
} l920;
l3 l58 = 0;
l3 l921 = 0;
l3 l57 = 0;
l3 l922 = 0;
l3 l923 = 0;
static l920* l924 = NULL;
static l920* l925 = NULL;
static l911* l926 = NULL;
static l3 l927 = 0;
static void l928(register l911* l202);
static l911*
l929(void)
{
    register l911* l202 = l926;
    if (l202) {
        l926 = l202->l8;
        memset(l202, 0, sizeof(l911));
        ++l927;
    }
    return l202;
}
static void
l930(l911* l201)
{
    register l911* l211,
        * l430;
    if (!(l54 && l201)) {
        return;
    }
    for (l211 = l201; l211; l211 = l211->l8) {
        l430 = l211;
    }
    if (l926) {
        l430->l8 = l926;
    }
    l926 = l201;
}
static l911*
l931(void)
{
    register l911* l202;
    static int l366 = 0;
    static l911* l367;
    if (--l366 > 0) {
        ++l367;
        l202 = l367;
    }
    else {
        l366 = 0;
        l202 = l929();
        if (!l202) {
            l366 = 1024;
            l367 = (l911*)calloc(l366, sizeof(l911));
            l202 = l367;
            if (!l202) {
                l59(2304, "out of memory");
            }
        }
    }
    return l202;
}
static l909*
l932(void)
{
    register l909* l933;
    static int l366 = 0;
    static l909* l367;
    if (--l366 > 0) {
        ++l367;
        l933 = l367;
    }
    else {
        l366 = 1024;
        l367 = (l909*)calloc(l366, sizeof(l909));
        l933 = l367;
        if (!l933) {
            l59(2301, "out of memory");
        }
    }
    return l933;
}
static l915*
l934(void)
{
    register l915* l935;
    static int l366 = 0;
    static l915* l367;
    if (--l366 > 0) {
        ++l367;
        l935 = l367;
    }
    else {
        l366 = 1024;
        l367 = (l915*)calloc(l366, sizeof(l915));
        l935 = l367;
        if (!l935) {
            l59(2302, "out of memory");
        }
    }
    return l935;
}
static l920*
l936(void)
{
    register l920* l914;
    static int l366 = 0;
    static l920* l367;
    if (--l366 > 0) {
        ++l367;
        l914 = l367;
    }
    else {
        l366 = 1024;
        l367 = (l920*)calloc(l366, sizeof(l920));
        l914 = l367;
        if (!l914) {
            l59(2303, "out of memory");
        }
    }
    return l914;
}
static void
l937(l920* l914,
    l920* l938,
    l46* l126)
{
    register l915* l935;
    for (l935 = l914->l917; l935; l935 = l935->l8) {
        if (l935->l914 == l938) {
            return;
        }
    }
    l935 = l934();
    l935->l914 = l938;
    l935->l126 = l126;
    l935->l8 = l914->l917;
    l914->l917 = l935;
}
static l3
l939(register l911* l206,
    register l911* l207,
    l3 l129)
{
    for (; l206 && l207; l206 = l206->l8, l207 = l207->l8) {
        if (l206->l177 != l207->l177) {
            break;
        }
        if (l129 == 0x00040000) {
            if (!l306(l206->l15, l207->l15)) {
                break;
            }
        }
    }
    return (!(l206 || l207));
}
static void
l940(register l286* l15,
    l911* l202)
{
    if (l202) {
        l928(l202);
    };
    for (; l15; l15 = l15->l8) {
        ;
    };
    ;
}
static void
l941(l911** l916)
{
    register l911* l202;
    register l46** l177;
    l46* l170,
        ** l465;
    l3 l382 = 1;
    for (l202 = *l916; l202; l202 = l202->l8) {
        l170 = *l202->l170;
        l170->l16 = NULL;
        for (l177 = l202->l177; *l177; ++l177) {
            (*l177)->l16 = NULL;
        }
    }
    while (l382) {
        l382 = 0;
        for (l202 = *l916; l202; l202 = l202->l8) {
            l170 = *l202->l170;
            l177 = l202->l177;
            for (; *l177 && ((*l177)->l9 == 3); ++l177)
                ;
            if (!*l177) {
                continue;
            }
            l465 = l177;
            for (++l465; *l465; ++l465) {
                if ((*l465)->l9 == 3) {
                    continue;
                }
                l382 |= l299(&(*l177)->l16,
                    (*l465)->l14);
                if (!(*l465)->l26) {
                    break;
                }
            }
            if (!*l465) {
                l382 |= l299(&(*l177)->l16, l202->l15);
                l382 |= l299(&(*l177)->l16, l170->l16);
                ;
                ;
                ;
                ;
            }
        }
    }
    l202 = *l916;
    if (l202) {
        l202 = l202->l8;
    }
    for (; l202; l202 = l202->l8) {
        l170 = *l202->l170;
        l299(&l202->l15, l170->l16);
        ;
        ;
    }
}
static void
l942(void)
{
    register l920* l914;
    for (l914 = l924; l914; l914 = l914->l8) {
        l914->l919 = 0;
    }
}
static int
l943(l920* l914)
{
    register l911* l202,
        * l944;
    register l915* l935;
    l911* l945;
    l3 l382 = 0;
    for (l935 = l914->l917; l935; l935 = l935->l8) {
        if (l935->l914->l919) {
            continue;
        }
        if (l935->l914 == l914) {
            continue;
        }
        l935->l914->l919 = 1;
        for (l202 = l914->l916; l202; l202 = l202->l8) {
            if (*l202->l177 != l935->l126) {
                continue;
            }
            l944 = l935->l914->l916;
            for (; l944; l944 = l944->l8) {
                if (l944->l261 == l202->l261) {
                    l382 |= l299(&l944->l15, l202->l15);
                    l945 = l944;
                    l941(&l945);
                    break;
                }
            }
        }
    }
    return l382;
}
static l920*
l946(l911* l916,
    l3 l129)
{
    register l920* l914;
    l911* l947,
        * l204;
    l3 l382 = 1;
    for (l914 = l924; l914; l914 = l914->l8) {
        if (l939(l914->l916, l916, l129)) {
            if (l129 == 0x00020000) {
                l947 = l914->l916;
                l204 = l916;
                while (l947 && l204) {
                    l299(&l947->l15, l204->l15);
                    l947 = l947->l8;
                    l204 = l204->l8;
                }
                while (l382) {
                    l382 = 0;
                    l942();
                    l914->l919 = 1;
                    l382 |= l943(l914);
                }
            }
            l930(l916);
            return l914;
        }
    }
    l914 = l936();
    l914->l138 = ++l58;
    l914->l916 = l916;
    l914->l917 = NULL;
    l925->l8 = l914;
    l925 = l914;
    return l914;
}
static l3
l948(l911** l201,
    l46** l170,
    l46** l177,
    l286* l15,
    l3 l261)
{
    register l911* l430 = NULL,
        * l250;
    l911* l428 = NULL;
    if (!*l201) {
        l428 = l931();
        l428->l170 = l170;
        l428->l177 = l177;
        l428->l15 = l15;
        l428->l261 = l261;
        *l201 = l428;
        return 1;
    }
    for (l250 = *l201; l250; l250 = l250->l8) {
        l430 = l250;
        if (l250->l177 == l177) {
            return 0;
        }
    }
    l428 = l931();
    l428->l170 = l170;
    l428->l177 = l177;
    l428->l15 = l15;
    l428->l261 = l261;
    l430->l8 = l428;
    return 1;
}
static l3
l949(l911** l206,
    register l194* l207,
    l286* l15,
    l3 l950)
{
    l3 l429 = 0;
    for (; l207; l207 = l207->l8) {
        l429 |= l948(l206, l207->l170, l207->l177, l15,
            l950++);
    }
    return l429;
}
static l911*
l951(l911** l916)
{
    register l911* l202;
    register l46** l177;
    l3 l950;
    l3 l382 = 1;
    while (l382) {
        l382 = 0;
        for (l202 = *l916; l202; l202 = l202->l8) {
            l177 = l202->l177;
            if (*l177 && (*l177)->l9 == 1) {
                l950 = l169(*l177);
                l382 |= l949(l916, (*l177)->l23,
                    NULL, l950);
            }
        }
    }
    l941(l916);
    return *l916;
}
static l911*
l952(register l911* l202,
    l46* l126)
{
    register l46** l177;
    l911* l201 = NULL;
    for (; l202; l202 = l202->l8) {
        l177 = l202->l177;
        if (*l177 == l126) {
            ++l177;
            for (; *l177 && ((*l177)->l9 == 3); ++l177)
                ;
            l948(&l201, l202->l170, l177, l202->l15,
                l202->l261);
            l202->l910 = 1;
        }
    }
    return l951(&l201);
}
static void
l953(void)
{
    register l920* l914;
    l3 l382;
    for (l382 = 1; l382;) {
        l382 = 0;
        for (l914 = l924; l914; l914 = l914->l8) {
            l942();
            l382 |= l943(l914);
        }
    }
}
static void
l954(l3 l129)
{
    register l911* l202;
    register l920* l914;
    l46* l126;
    l920* l938;
    l911* l204;
    l46* l609;
    l914 = l936();
    l914->l138 = ++l58;
    l949(&l914->l916, l143[1]->l23, NULL, 1);
    l609 = l66("END_OF_SLK_INPUT");
    l202 = l914->l916;
    l300(&l202->l15, l609);
    l951(&l914->l916);
    l924 = l914;
    l925 = l914;
    for (; l914; l914 = l914->l8) {
        ;
        if (l48 == -1) {
            printf("State  %d\n", l914->l138);
        }
        for (l202 = l914->l916; l202; l202 = l202->l8) {
            if (l48 == -1) {
                l928(l202);
            }
            l126 = *l202->l177;
            if (l126 && !l202->l910) {
                l204 = l952(l202, l126);
                l938 = l946(l204, l129);
                l937(l914, l938, l126);
            }
        }
    }
    if (l129 == 0x00020000) {
        l953();
    }
}
static l909*
l955(register l909* l278,
    register l3 l131)
{
    for (; l278; l278 = l278->l8) {
        if (l278->l131 == l131) {
            break;
        }
    }
    return l278;
}
static void
l956(l909** l278,
    l3 l131,
    l911* l202,
    l3 l957)
{
    register l909* l428,
        * l367 = *l278;
    l428 = l932();
    l428->l131 = l131;
    l428->l202 = l202;
    l428->l367 = l957;
    if (!l367) {
        *l278 = l428;
        return;
    }
    if (l367->l131 > l131) {
        l428->l8 = l367;
        *l278 = l428;
        return;
    }
    for (; l367; l367 = l367->l8) {
        if (!l367->l8) {
            l367->l8 = l428;
            break;
        }
        else if (l367->l8->l131 > l131) {
            l428->l8 = l367->l8;
            l367->l8 = l428;
            break;
        }
    }
}
static l194*
l958(l911* l202)
{
    return l199(l202->l170, l202->l177, NULL, l196);
}
static void
l959(l920* l914,
    l911* l202,
    int l136)
{
    register l286* l481;
    l909** l278 = &l914->l278;
    l909* l960;
    l46* l170 = *l202->l170;
    l3 l131;
    l3 l261 = l202->l261;
    if (l136) {
        l481 = l170->l15;
    }
    else {
        l481 = l202->l15;
    }
    for (; l481; l481 = l481->l8) {
        l131 = l481->l126->l10;
        l960 = l955(*l278, l131);
        if (l960) {
            if (l960->l367 != l261) {
                l194* l947,
                    * l204;
                l947 = l958(l960->l202);
                l204 = l958(l202);
                l252(l481->l126,
                    l248(l960->l202->l261,
                        l960->l367, l947),
                    l248(l261,
                        l261, l204),
                    l914->l138);
            }
        }
        else {
            l956(l278, l131, l202, l261);
            ++l914->l918;
        }
    }
}
static l3
l961(register l915* l935,
    l46* l126)
{
    l3 l962 = 0;
    for (; l935; l935 = l935->l8) {
        if (l935->l126 == l126) {
            l962 = l935->l914->l138;
            break;
        }
    }
    return l962;
}
static void
l963(l920* l914,
    l911* l202,
    l46* l126)
{
    register l909** l278 = &l914->l278;
    l909* l960;
    l3 l131;
    l3 l962;
    l962 = l961(l914->l917, l126);
    l962 += l922;
    l131 = l126->l10;
    l960 = l955(*l278, l131);
    if (l960) {
        if (l960->l367 != l962) {
            l194* l947, * l204;
            l3 l261 = l202->l261;
            l947 = l958(l960->l202);
            l204 = l958(l202);
            l252(l126,
                l248(l960->l202->l261,
                    l960->l367, l947),
                l248(l261, l962,
                    l204),
                l914->l138);
        }
    }
    else {
        l956(l278, l131, l202, l962);
        ++l914->l918;
    }
}
static void
l964(int l136)
{
    register l911* l202;
    register l920* l914;
    l46* l126;
    for (l914 = l924; l914; l914 = l914->l8) {
        for (l202 = l914->l916; l202; l202 = l202->l8) {
            l126 = *l202->l177;
            if (l126) {
                l963(l914, l202, l126);
            }
            else {
                l959(l914, l202, l136);
            }
        }
    }
}
int l128(int l129)
{
    int l323 = 0;
    char* l965 = "SLR";
    switch (l129) {
    case 0x00020000:
        l965 = "LALR";
        break;
    case 0x00040000:
        l965 = "LR";
        break;
    }
    l57 = l150 + 1;
    l922 = l150;
    l921 = l147 + l148;
    ;
    ;
    l954(l129);
    l154 = l150 + l58 + 1;
    l923 = l150 + l58;
    ;
    ;
    l964(l129 == 0x00010000);
    if (l54) {
        printf("\tLR reused config count = %u\n", l927);
    }
    return l323;
}
void l130(l3 l131,
    l3 l132)
{
    register l920* l914;
    register l909* l278 = NULL;
    l247* l279;
    l3 l962 = 0;
    l279 = l258(l132);
    if (l279) {
        l962 = l279->l245;
    }
    for (l914 = l924; l914; l914 = l914->l8) {
        if (l914->l138 == l962) {
            l278 = l914->l278;
            break;
        }
    }
    for (; l278; l278 = l278->l8) {
        if (l278->l131 == l131) {
            l278->l367 = (l132 + (l154 - 1));
            break;
        }
    }
    if (!l278) {
        ;
        ;
    }
}
static int*
l966(FILE* l88,
    l3 l85)
{
    register l46*** l367 = l146,
        ** l126;
    int l471 = 0,
        l122;
    int* l584;
    l584 = calloc(l150 + 4, sizeof(int));
    if (!l584) {
        l59(2307, "out of memory");
    }
    while (*++l367) {
        l126 = *l367;
        for (l122 = 1; *++l126;) {
            ++l122;
            if (l85 & 0x00000008) {
                if ((*l126)->l9 == 3) {
                    --l122;
                }
            }
        }
        l584[++l471] = l122;
    }
    return l584;
}
void l133(FILE* l88,
    l3 l85)
{
    register l46*** l367,
        ** l126;
    int l513,
        l967, l471;
    int* l968,
        * l957;
    int* l584;
    if (l85 & 0x00002000) {
        fputs("var Production = [0\n\n", l88);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fputs("static slk_size_t Production[] = {0\n\n", l88);
    }
    else {
        fputs("private static short[] Production = {0\n\n", l88);
    }
    l968 = calloc(l150 + 4, sizeof(int));
    if (!l968) {
        l59(2308, "out of memory");
    }
    l584 = l966(l88, l85);
    l513 = 1;
    l471 = 0;
    l367 = l146;
    l957 = l968;
    while (*++l367) {
        ++l957;
        l126 = *l367;
        fprintf(l88, ",%u,%u", *++l584, (*l126)->l10);
        l967 = 2;
        while (*++l126) {
            if (l85 & 0x00000008) {
                if ((*l126)->l9 == 3) {
                    continue;
                }
            }
            fprintf(l88, ",%u", (*l126)->l10);
            ++l967;
        }
        fputs(" ", l88);
        *l957 = l513;
        l513 += l967;
        l471 += l967;
        if (l471 >= 16) {
            l471 = 0;
            fputs("\n", l88);
        }
    }
    fprintf(l88, "\n,0%s;\n\n", l502);
    *++l957 = 0;
    if (l85 & 0x00002000) {
        fputs("var Production_row = [0\n\n", l88);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fputs("static slk_size_t Production_row[] = {0\n\n", l88);
    }
    else {
        fputs("private static int[] Production_row = {0\n\n", l88);
    }
    l957 = l968;
    for (l471 = 1; *++l957; ++l471) {
        fprintf(l88, ",%u", *l957);
        if (l471 >= 16) {
            l471 = 0;
            fputs("\n", l88);
        }
    }
    fprintf(l88, "\n,0%s;\n\n", l502);
}
static void
l969(char* l83,
    char* l84,
    l3 l85)
{
    register l920* l914;
    register l911* l202;
    int l513,
        l970,
        l471;
    int* l971,
        * l957;
    int l972;
    int l547 = 0x00000100;
    FILE* l88;
    char l75[32];
    if (l85 & (0x00000200)) {
        l547 = 0x00000200;
    }
    else if (l85 & (0x00001000)) {
        l547 = 0x00001000;
    }
    else if (l85 & (0x00000800)) {
        l547 = 0x00000800;
    }
    else if (l85 & (0x00000400)) {
        l547 = 0x00000400;
    }
    else if (l85 & (0x00002000)) {
        l547 = 0x00002000;
    }
    l83[3] = '\0';
    strcpy(l75, l83);
    switch (l547) {
    case 0x00000200:
        strcat(l75, "State.cpp");
        break;
    case 0x00000100:
    case 0x00001000:
        strcat(l75, "State.c");
        break;
    case 0x00000800:
        strcat(l75, "State.cs");
        break;
    case 0x00000400:
        strcat(l75, "State.java");
        break;
    case 0x00002000:
        strcat(l75, "State.js");
        break;
    }
    l88 = fopen(l75, "w");
    if (!l88) {
        perror(l75);
        return;
    }
    fprintf(l88, "\n// %s - generated by the SLK parser generator \n\n",
        l75);
    if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fprintf(l88, "#include \"%sParse.h\" \n\n", l83);
    }
    if (l84) {
        switch (l547) {
        case 0x00000200:
        case 0x00000800:
            fprintf(l88, "namespace %s {\n\n", l84);
            break;
        case 0x00000400:
            fprintf(l88, "package %s;\n\n", l84);
            break;
        }
    }
    switch (l547) {
    case 0x00000800:
        fprintf(l88, "class %sState {\n\n", l83);
        break;
    case 0x00000400:
        fprintf(l88, "public class %sState {\n\n", l83);
        break;
    }
    if (l85 & 0x00002000) {
        fputs("var State = [0\n\n", l88);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fputs("static slk_size_t State[] = {0\n\n", l88);
    }
    else {
        fputs("private static int[] State = {0\n\n", l88);
    }
    l971 = calloc(l58 + 4, sizeof(int));
    if (!l971) {
        l59(2308, "out of memory");
    }
    l513 = 1;
    l471 = 0;
    l957 = l971;
    for (l914 = l924; l914; l914 = l914->l8) {
        ++l957;
        l972 = 0;
        for (l202 = l914->l916; l202; l202 = l202->l8) {
            ++l972;
        }
        l972 *= 2;
        fprintf(l88, ",%u", l972);
        for (l202 = l914->l916; l202; l202 = l202->l8) {
            l970 = l202->l177 - l202->l170;
            fprintf(l88, ",%u,%u", l202->l261, l970);
        }
        fputs(" ", l88);
        *l957 = l513;
        l513 += l972 + 1;
        l471 += l972 + 1;
        if (l471 >= 16) {
            l471 = 0;
            fputs("\n", l88);
        }
    }
    fprintf(l88, "\n,0%s;\n\n", l502);
    *++l957 = 0;
    if (l85 & 0x00002000) {
        fputs("var State_row = [0\n\n", l88);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fputs("static slk_size_t State_row[] = {0\n\n", l88);
    }
    else {
        fputs("private static int[] State_row = {0\n\n", l88);
    }
    l957 = l971;
    for (l471 = 1; *++l957; ++l471) {
        fprintf(l88, ",%u", *l957);
        if (l471 >= 16) {
            l471 = 0;
            fputs("\n", l88);
        }
    }
    fprintf(l88, "\n,0%s;\n\n", l502);
    if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fprintf(l88, "slk_size_t *%sGetState ( slk_size_t  state_number )\n"
            "{\n"
            "    return   &State [ State_row [state_number] ];\n"
            "}\n\n",
            l83);
    }
    else {
    }
    switch (l547) {
    case 0x00000800:
    case 0x00000400:
        fprintf(l88, "\n}\n\n");
        break;
    }
    if (l84) {
        switch (l547) {
        case 0x00000200:
        case 0x00000800:
            fprintf(l88, "\n\n}\n");
            break;
        }
    }
    fclose(l88);
}
static void
l973(FILE* l88,
    l3 l85)
{
    register l46*** l367 = l146,
        ** l126;
    l46* l974,
        * l490;
    int l975,
        l471 = 0;
    if (l85 & 0x00002000) {
        fputs("var Action_number = [0\n\n", l88);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fputs("static slk_size_t Action_number[] = {0\n\n", l88);
    }
    else {
        fputs("private static int[] Action_number = {0\n\n", l88);
    }
    while (*++l367) {
        l975 = 0;
        l490 = NULL;
        l974 = NULL;
        for (l126 = *l367; *++l126;) {
            if ((*l126)->l9 == 3) {
                l490 = *l126;
                if (l974) {
                    printf("Warning: Only last action is executed\n");
                    l188("   ", l126);
                }
                l975 = l490->l10;
                l974 = l490;
            }
        }
        if (l490) {
            if (*--l126 != l490) {
                printf("Warning: action is executed at reduction\n");
                l188("   ", *l367);
            }
        }
        fprintf(l88, ",%u", l975);
        if (++l471 >= 16) {
            l471 = 0;
            fputs("\n", l88);
        }
    }
    fprintf(l88, "\n,0%s;\n\n", l502);
}
static void
l976(FILE* l88,
    int* l512,
    l3 l85)
{
    register int* l367;
    register l920* l914;
    register l909* l278;
    int l513,
        l918 = l921,
        l131;
    int l438;
    if (l85 & 0x00002000) {
        fputs("var Parse = [0,0\n\n", l88);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fputs("static slk_size_t Parse[] = {0,0\n\n", l88);
    }
    else {
        fputs("private static short[] Parse = {0,0\n\n", l88);
    }
    l513 = 1;
    l367 = l512;
    for (l914 = l924; l914; l914 = l914->l8) {
        l131 = 0;
        *++l367 = l513;
        for (l278 = l914->l278; l278; l278 = l278->l8) {
            while (++l131 < l278->l131) {
                fputs(",0", l88);
            }
            fprintf(l88, ",%u", l278->l367);
        }
        while (++l131 <= l918) {
            fputs(",0", l88);
        }
        l513 += l918;
        fputs("\n", l88);
    }
    *++l367 = 0;
    fprintf(l88, "%s;\n\n", l502);
    if (l85 & 0x00002000) {
        fputs("var Parse_row = [0\n\n", l88);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fputs("static int Parse_row[] = {0\n\n", l88);
    }
    else {
        fputs("private static int[] Parse_row = {0\n\n", l88);
    }
    l367 = l512;
    for (l438 = 1; *++l367; ++l438) {
        fprintf(l88, ",%u", *l367);
        if (l438 >= 16) {
            l438 = 0;
            fputs("\n", l88);
        }
    }
    fprintf(l88, "\n,0%s;\n\n", l502);
}
static int
l977(void)
{
    register l920* l914;
    int l978 = 0;
    for (l914 = l924; l914; l914 = l914->l8) {
        if (l914->l918 > l978) {
            l978 = l914->l918;
        }
    }
    return l978;
}
static l920*
l979(int* l978,
    l920* l980)
{
    register l920* l914 = NULL;
    if (*l978 <= 0) {
        return NULL;
    }
    if (l980) {
        l914 = l980->l8;
    }
    do {
        if (!l914) {
            l914 = l924;
        }
        for (; l914; l914 = l914->l8) {
            if (l914->l918 == *l978) {
                if (!l914->l8) {
                    --(*l978);
                }
                return l914;
            }
        }
    }
    while (--(*l978) > 0);
    return NULL;
}
typedef struct l981
{
    l3 l668;
    l3 l367;
} l982;
static l982*
l983(l3 l523,
    l982* l524,
    l3 l525,
    int* l512)
{
    register l982* l526;
    register l909* l278;
    l920* l914 = NULL;
    l982* l527 = l524 +
        l525 - l921,
        * l528 = NULL,
        * l529,
        * l20;
    l3 l531;
    int l978 = l977();
    printf("compacting parse table from %u ", l523);
    while (l914 = l979(&l978, l914)) {
        l278 = l914->l278;
        l526 = l524;
        for (;;) {
            while ((++l526)->l367) {
                if (l526 > l527) {
                    putchar('\n');
                    return NULL;
                }
            }
            l278 = l914->l278;
            if (l526 - l278->l131 <= l524) {
                continue;
            }
            l529 = l526;
            l526 -= l278->l131;
            l531 = 1;
            for (l278 = l914->l278; l278; l278 = l278->l8) {
                if ((l526 + l278->l131)->l367) {
                    l531 = 0;
                    break;
                }
            }
            if (l531) {
                l512[l914->l138] = l526 - l524;
                for (l278 = l914->l278; l278; l278 = l278->l8) {
                    l20 = l526 + l278->l131;
                    l20->l668 = l914->l138;
                    l20->l367 = l278->l367;
                    if (l526 + l921 > l528) {
                        l528 = l526 + l921;
                    }
                }
                break;
            }
            l526 = l529;
        }
    }
    l512[l58 + 1] = 0;
    printf("to %lu\n", 2 * (l4)(++l528 - l524 - 1));
    return l528;
}
static void
l984(FILE* l88,
    l982* l327,
    l982* l524,
    register int* l512,
    l3 l85)
{
    register l982* l20;
    l3 l438 = 1,
        l270 = 1;
    l20 = l524;
    if (l85 & 0x00002000) {
        fprintf(l88, "var Parse = [\n\n%u", l20->l367);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fprintf(l88, "static slk_size_t Parse[] = {\n\n%u", l20->l367);
    }
    else {
        fprintf(l88, "private static short[] Parse = {\n\n%u", l20->l367);
    }
    while (++l20 < l327) {
        ++l270;
        if (++l438 > 16) {
            l438 = 0;
            fputs("\n", l88);
        }
        fprintf(l88, ",%u", l20->l367);
    }
    fprintf(l88, "\n%s;\n\n", l502);
    if (l85 & 0x00002000) {
        fputs("var Parse_row = [0\n\n", l88);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        if (l270 < (1024 * 64 - 32)) {
            fputs("static slk_size_t Parse_row[] = {0\n\n", l88);
        }
        else {
            fputs("static int Parse_row[] = {0\n\n", l88);
        }
    }
    else {
        fputs("private static int[] Parse_row = {0\n\n", l88);
    }
    for (l438 = 1; *++l512; ++l438) {
        fprintf(l88, ",%u", *l512);
        if (l438 >= 16) {
            l438 = 0;
            fputs("\n", l88);
        }
    }
    fprintf(l88, "\n,0%s;\n\n", l502);
}
static void
l985(FILE* l88,
    l982* l327,
    l982* l524,
    register int* l512,
    l3 l85)
{
    register l982* l20;
    l3 l438 = 1,
        l270 = 1;
    l20 = l524;
    if (l85 & 0x00002000) {
        fprintf(l88, "var Parse_state = [\n\n%u", l20->l668);
    }
    else if (l85 & (0x00000100 | 0x00001000 | 0x00000200)) {
        fprintf(l88, "static slk_size_t Parse_state[] = {\n\n%u",
            l20->l668);
    }
    else {
        fprintf(l88, "private static short[] Parse_state = {\n\n%u",
            l20->l668);
    }
    while (++l20 < l327) {
        ++l270;
        if (++l438 > 16) {
            l438 = 0;
            fputs("\n", l88);
        }
        fprintf(l88, ",%u", l20->l668);
    }
    fprintf(l88, "\n%s;\n\n", l502);
}
static void
l986(l3 l131,
    l3 l367)
{
    ;
    ;
    if (l367 < l57) {
        ;
        ;
    }
    else if (l367 < l154) {
        ;
        ;
    }
    else {
        ;
        ;
    }
}
static int
l987(l982* l537,
    int* l512)
{
    register l920* l914;
    register l909* l278;
    int l513,
        l131,
        l323 = 0,
        l988,
        l989,
        l367;
    for (l914 = l924; l914; l914 = l914->l8) {
        for (l278 = l914->l278; l278; l278 = l278->l8) {
            l367 = l278->l367;
            l131 = l278->l131;
            l513 = l512[l914->l138];
            l513 += l131;
            l989 = l537[l513].l668;
            l988 = l537[l513].l367;
            if (l914->l138 != l989) {
                l323 = 1;
                printf("row_number %u != compact_row_number %u at offset %u\n",
                    l914->l138, l989, l513);
            }
            if (l367 != l988) {
                l323 = 1;
                printf("\n%3d: ", l914->l138);
                printf("entry %u != compact_entry %u at offset %u\n",
                    l367, l988, l513);
            }
        }
    }
    return l323;
}
void l134(char* l83,
    char* l84,
    l3 l85,
    FILE* l88)
{
    l982* l537,
        * l327;
    int* l512;
    l3 l523 = l58 * l921,
        l542 = 0;
    l969(l83, l84, l85);
    l973(l88, l85);
    l512 = calloc(l58 + 2, sizeof(int));
    if (!l512) {
        l59(2309, "out of memory");
    }
    if (l85 & 0x00000001) {
        for (;;) {
            l542 += 64 * 1024;
            l537 = calloc(l542, sizeof(l982));
            if (!l537) {
                l59(2310, "out of memory");
            }
            l327 = l983(l523, l537,
                l542, l512);
            if (!l327) {
                free(l537);
                continue;
            }
            l984(l88, l327, l537, l512,
                l85);
            l985(l88, l327, l537, l512,
                l85);
            if (l987(l537, l512)) {
                printf("error 1133: table compacting failed\n");
            }
            free(l537);
            break;
        }
    }
    else {
        l976(l88, l512, l85);
    }
    free(l512);
}
static void
l928(register l911* l202)
{
    register l46** l126;
    if (l202) {
        l126 = l202->l170;
        printf("   %2d: %s -->", l202->l261, (*l126)->l11);
        while (*++l126) {
            if (l126 != l202->l177) {
                printf("  %s", (*l126)->l11);
            }
            else {
                printf(" %s %s", l56, (*l126)->l11);
            }
        }
        if (!*l202->l177) {
            printf(" %s", l56);
        }
        putchar('\n');
    }
}
static void
l990(register l911* l202,
    int l136)
{
    register l46** l126;
    l286* l481;
    l46* l609;
    l46* l170;
    char* l991;
    l609 = l66("END_OF_SLK_INPUT");
    l991 = l609->l11;
    if (l66("$")) {
        l609->l11 = "$$$";
    }
    else {
        l609->l11 = "$";
    }
    for (; l202; l202 = l202->l8) {
        l126 = l202->l170;
        printf("   %2d: %s -->", l202->l261, (*l126)->l11);
        while (*++l126) {
            if (l126 != l202->l177) {
                printf("  %s", (*l126)->l11);
            }
            else {
                printf(" %s %s", l56, (*l126)->l11);
            }
        }
        if (!*l202->l177) {
            printf(" %s", l56);
        }
        putchar('\n');
        if (l136) {
            l170 = *l202->l170;
            l481 = l170->l15;
        }
        else {
            l481 = l202->l15;
        };
        ;
        for (; l481; l481 = l481->l8) {
            ;
            ;
        };
        ;
    }
    putchar('\n');
    l609->l11 = l991;
}
void l135(int l136)
{
    register l920* l914;
    register l915* l935;
    for (l914 = l924; l914; l914 = l914->l8) {
        printf("State  %d\n", l914->l138);
        l990(l914->l916, l136);
        for (l935 = l914->l917; l935; l935 = l935->l8) {
            printf("    go to state %d on %s\n", l935->l914->l138,
                l935->l126->l11);
        }
        if (l914->l917) {
            putchar('\n');
        }
    }
    putchar('\n');
}
void l137(int l138)
{
    register l920* l914;
    register l915* l935;
    int l136 = 0;
    for (l914 = l924; l914; l914 = l914->l8) {
        if (l914->l138 != l138) {
            continue;
        }
        printf("State  %d\n", l914->l138);
        l990(l914->l916, l136);
        for (l935 = l914->l917; l935; l935 = l935->l8) {
            printf("    go to state %d on %s\n", l935->l914->l138,
                l935->l126->l11);
        }
        if (l914->l917) {
            putchar('\n');
        }
        break;
    }
    putchar('\n');
}
void l139(void)
{
    register l920* l914;
    register l909* l278;
    l3 l367;
    l46* l609;
    char* l991;
    l609 = l66("END_OF_SLK_INPUT");
    l991 = l609->l11;
    if (l66("$")) {
        l609->l11 = "$$$";
    }
    else {
        l609->l11 = "$";
    }
    for (l914 = l924; l914; l914 = l914->l8) {
        printf("State %d:  ", l914->l138);
        for (l278 = l914->l278; l278; l278 = l278->l8) {
            printf(" %d:", l278->l131);
            l367 = l278->l367;
            if (l367 < l57) {
                printf(" R%d ", l367);
            }
            else if (l367 < l154) {
                printf(" S%d ", l367 - l922);
            }
            else {
                printf(" C%d ", l367 - l923);
            }
        }
        putchar('\n');
    }
    l186();
    l140();
    l609->l11 = l991;
}
void l140(void)
{
    register l46** l244 = l144;
    register l46** l179 = l143;
    int l471;
    printf("\n\n\t\t\t ALL GRAMMAR SYMBOLS \n\n");
    for (l471 = 1; *++l244; ++l471) {
        printf("%2d: %s\n", l471, (*l244)->l11);
    }
    for (; *++l179; ++l471) {
        printf("%2d: %s\n", l471, (*l179)->l11);
    }
    putchar('\n');
}
