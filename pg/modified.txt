这个工程是pg/slk的可编译源码（作者混淆过了变量名，但不影响修改使用）。

在pg.c文件开头各种声明后不久是main函数（直接使用vs.net的CTRL+T来找main即可），这里有命令行开关的解析，-Ps是栈大小参数，记录在一个全局变量里，但只有生成的c++代码使用了此变来定义PARSE_STACK_SIZE符号。
在命令行开关解析后（同时获取了输入文法文件），是对几个文法处理的开关的特殊处理，之后读取文法内容，根据开关选择词法分析函数，然后进行语法解析（l77，感觉语法解析程序也是pg自己生成的）。

接近pg.c文件尾部，在若干代码模板后面，有一个代码结构，记录了每种语言对应的代码结构字符串，第5个l869是package/namespace，最后的l889与l890分别是LL与LR分析算法模板代码
typedef struct l866
{
    char* l867;
    char* l559;
    char* l560;
    char* l868;
    char* l869;
    char* l870;
    char* l871;
    char* l872;
    char* l873;
    char* l874;
    char* l875;
    char* l876;
    char* l877;
    char* l878;
    char* l879;
    char* l880;
    char* l881;
    char* l882;
    char* l883;
    char* l884;
    char* l885;
    char* l886;
    char* l887;
    char* l888;
    char* l889;
    char* l890;
} l891;
static l891 l892 = {
    "java",
    "{",
    "}",
    "",
    "package",
    "public class",
    "(short)",
    "short",
    "private static final short",
    "public static final short",
    "public static final int",
    "private static short",
    "private static short[]",
    "public static short[]",
    "public static String[]",
    l844,
    l845,
    l846,
    l847,
    l848,
    l849,
    l850,
    l851,
    l852,
    l853,
    l854 };
static l891 l893 = {
    "js",
    "[",
    "]",
    "=",
    "",
    "var",
    "",
    "",
    "var",
    "var",
    "var",
    "function",
    "var",
    "var",
    "var",
    l855,
    l856,
    l857,
    l858,
    l859,
    l860,
    l861,
    l862,
    l863,
    l864,
    l865 };
static l891 l894 = {
    "cs",
    "{",
    "}",
    "",
    "namespace",
    "class",
    "(short)",
    "short",
    "private const short",
    "public const short",
    "public const int",
    "private static short",
    "private static short[]",
    "public static short[]",
    "public static string[]",
    l844,
    l845,
    l846,
    l847,
    l848,
    l849,
    l850,
    l851,
    l852,
    l853_cs,
    l854 };

在此之后是生成各个输出文件的函数，生成Constants.cs的函数l902里，package/namespace头需要修改：
    if (l84) {
        if (l85 & 0x00000400)
            fprintf(l566, "%s %s;\n\n", l895.l869, l84);
        else
            fprintf(l566, "%s %s {\n\n", l895.l869, l84);
    }
对应的结尾部分逻辑：
    if (!(l85 & 0x00000400)) {
        if (l84) {
            fprintf(l566, "\n\n}\n");
        }
    }

在l82函数里有各个语言的位掩码：
    if (l85 & (0x00000200)) {
        l547 = 0x00000200;
    }
    else if (l85 & (0x00001000)) {
        l547 = 0x00001000;
    }
    else if (l85 & (0x00000800)) {
        l547 = 0x00000800;
    }
    else if (l85 & (0x00000400)) {
        l547 = 0x00000400;
    }
    else if (l85 & (0x00002000)) {
        l547 = 0x00002000;
        l502 = "]";
    }
    l83[3] = '\0';
    l87 = l508(l76 & 0x00000010);
    strcpy(l75, l83);
    switch (l547) {
    case 0x00000200:
        strcat(l75, "Parse.cpp");
        break;
    case 0x00000100:
    case 0x00001000:
        strcat(l75, "Parse.c");
        break;
    case 0x00000800:
        strcat(l75, "Parser.cs");
        break;
    case 0x00000400:
        strcat(l75, "Parser.java");
        break;
    case 0x00002000:
        strcat(l75, "Parser.js");
        break;
    }

在pg.c里搜索generated by the SLK parser generator字符串可以搜到写各输出文件的函数。
在pg.c里搜索ACTION_SYMBOL可以看到输出这个符号定义的地方，可以在它之后添加一个常量PARSE_STACK_SIZE来记录命令行传入的栈大小，然后在分析代码模板里使用此常量。


主要修改：
0、工程编译选项里加上预处理宏_CRT_SECURE_NO_WARNINGS
1、C#与java共用的代码模板，装LL分析算法部分拆分出C#版本（模板代码里使用PARSE_STACK_SIZE符号来表示栈大小），并按MetaDSL的需求修改，注意这个代码模板有2处引用，一处是结构赋值，一处是替换xxx为指定名称前缀的代码，
2处都要对应修改。
2、在定义ACTION_SYMBOL符号的后面添加PARSE_STACK_SIZE符号常量的定义，值使用-Ps参数传入的值，有一个全局变量l55记录了此值，默认是512
3、xxxConstants.cs的namespace声明，需要从namespace xxx;改为namspace xxx {，此处为C#与java共用，java的package xxx;是对的，需要根据参数进行位运算判断是否java/c#来修改。
4、pg.c里面的main改为cmain，然后在cpp的main里调用cmain，声明为extern "C" int cmain(int, char* []);
5、工程里的SDL检查关掉或者将报错的未初化指针赋初值NULL
6、编译警告看情况是否修改，主要是size_t与int/uint转换或比较的报警，有一处char*转long的报警可以考虑改为指针判空。
7、c++的LL分析算法的predict与error函数原型修改为与c#一致，这个用宏实现，对应的宏也要修改。另外,SLK_PUSH宏的else添加stack overflow提示信息，还有分析程序symbol为0也添加提示信息（与c#一致）。
注意：SLK_PUSH宏也用在c语言代码生成里，会导致c语言版本报错（我们不用先不管了）。